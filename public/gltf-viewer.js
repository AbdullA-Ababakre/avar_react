parcelRequire = (function (e, r, t, n) {
  var i,
    o = "function" == typeof parcelRequire && parcelRequire,
    u = "function" == typeof require && require;
  function f(t, n) {
    if (!r[t]) {
      if (!e[t]) {
        var i = "function" == typeof parcelRequire && parcelRequire;
        if (!n && i) return i(t, !0);
        if (o) return o(t, !0);
        if (u && "string" == typeof t) return u(t);
        var c = new Error("Cannot find module '" + t + "'");
        throw ((c.code = "MODULE_NOT_FOUND"), c);
      }
      (p.resolve = function (r) {
        return e[t][1][r] || r;
      }),
        (p.cache = {});
      var l = (r[t] = new f.Module(t));
      e[t][0].call(l.exports, p, l, l.exports, this);
    }
    return r[t].exports;
    function p(e) {
      return f(p.resolve(e));
    }
  }
  (f.isParcelRequire = !0),
    (f.Module = function (e) {
      (this.id = e), (this.bundle = f), (this.exports = {});
    }),
    (f.modules = e),
    (f.cache = r),
    (f.parent = o),
    (f.register = function (r, t) {
      e[r] = [
        function (e, r) {
          r.exports = t;
        },
        {},
      ];
    });
  for (var c = 0; c < t.length; c++)
    try {
      f(t[c]);
    } catch (e) {
      i || (i = e);
    }
  if (t.length) {
    var l = f(t[t.length - 1]);
    "object" == typeof exports && "undefined" != typeof module
      ? (module.exports = l)
      : "function" == typeof define && define.amd
        ? define(function () {
          return l;
        })
        : n && (this[n] = l);
  }
  if (((parcelRequire = f), i)) throw i;
  return f;
})(
  {
    gBK8: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.AxesHelper =
            exports.AudioLoader =
            exports.AudioListener =
            exports.AudioContext =
            exports.AudioAnalyser =
            exports.Audio =
            exports.ArrowHelper =
            exports.ArrayCamera =
            exports.ArcCurve =
            exports.AnimationUtils =
            exports.AnimationObjectGroup =
            exports.AnimationMixer =
            exports.AnimationLoader =
            exports.AnimationClip =
            exports.AmbientLightProbe =
            exports.AmbientLight =
            exports.AlwaysStencilFunc =
            exports.AlwaysDepth =
            exports.AlphaFormat =
            exports.AdditiveBlending =
            exports.AdditiveAnimationBlendMode =
            exports.AddOperation =
            exports.AddEquation =
            exports.ACESFilmicToneMapping =
            void 0),
          (exports.AxisHelper = kx),
          (exports.BasicShadowMap =
            exports.BasicDepthPacking =
            exports.BackSide =
            void 0),
          (exports.BinaryTextureLoader = Xx),
          (exports.BooleanKeyframeTrack = exports.Bone = void 0),
          (exports.BoundingBoxHelper = Vx),
          (exports.CameraHelper =
            exports.Camera =
            exports.Cache =
            exports.ByteType =
            exports.BufferGeometryLoader =
            exports.BufferGeometry =
            exports.BufferAttribute =
            exports.BoxHelper =
            exports.BoxGeometry =
            exports.BoxBufferGeometry =
            exports.Box3Helper =
            exports.Box3 =
            exports.Box2 =
            void 0),
          (exports.CanvasRenderer = Zx),
          (exports.DstColorFactor =
            exports.DstAlphaFactor =
            exports.DoubleSide =
            exports.DodecahedronGeometry =
            exports.DodecahedronBufferGeometry =
            exports.DiscreteInterpolant =
            exports.DirectionalLightHelper =
            exports.DirectionalLight =
            exports.DepthTexture =
            exports.DepthStencilFormat =
            exports.DepthFormat =
            exports.DefaultLoadingManager =
            exports.DecrementWrapStencilOp =
            exports.DecrementStencilOp =
            exports.DataUtils =
            exports.DataTextureLoader =
            exports.DataTexture3D =
            exports.DataTexture2DArray =
            exports.DataTexture =
            exports.Cylindrical =
            exports.CylinderGeometry =
            exports.CylinderBufferGeometry =
            exports.CustomToneMapping =
            exports.CustomBlending =
            exports.CurvePath =
            exports.Curve =
            exports.CullFaceNone =
            exports.CullFaceFrontBack =
            exports.CullFaceFront =
            exports.CullFaceBack =
            exports.CubicInterpolant =
            exports.CubicBezierCurve3 =
            exports.CubicBezierCurve =
            exports.CubeUVRefractionMapping =
            exports.CubeUVReflectionMapping =
            exports.CubeTextureLoader =
            exports.CubeTexture =
            exports.CubeRefractionMapping =
            exports.CubeReflectionMapping =
            exports.CubeCamera =
            exports.ConeGeometry =
            exports.ConeBufferGeometry =
            exports.CompressedTextureLoader =
            exports.CompressedTexture =
            exports.ColorKeyframeTrack =
            exports.Color =
            exports.Clock =
            exports.ClampToEdgeWrapping =
            exports.CircleGeometry =
            exports.CircleBufferGeometry =
            exports.CineonToneMapping =
            exports.CatmullRomCurve3 =
            exports.CanvasTexture =
            void 0),
          (exports.DynamicBufferAttribute = Dx),
          (exports.EdgesGeometry =
            exports.DynamicReadUsage =
            exports.DynamicDrawUsage =
            exports.DynamicCopyUsage =
            void 0),
          (exports.EdgesHelper = Wx),
          (exports.Float16BufferAttribute =
            exports.FlatShading =
            exports.FileLoader =
            exports.FaceColors =
            exports.ExtrudeGeometry =
            exports.ExtrudeBufferGeometry =
            exports.EventDispatcher =
            exports.Euler =
            exports.EquirectangularRefractionMapping =
            exports.EquirectangularReflectionMapping =
            exports.EqualStencilFunc =
            exports.EqualDepth =
            exports.EllipseCurve =
            void 0),
          (exports.Float32Attribute = Hx),
          (exports.Float32BufferAttribute = void 0),
          (exports.Float64Attribute = Ux),
          (exports.InstancedMesh =
            exports.InstancedInterleavedBuffer =
            exports.InstancedBufferGeometry =
            exports.InstancedBufferAttribute =
            exports.IncrementWrapStencilOp =
            exports.IncrementStencilOp =
            exports.ImmediateRenderObject =
            exports.ImageUtils =
            exports.ImageLoader =
            exports.ImageBitmapLoader =
            exports.IcosahedronGeometry =
            exports.IcosahedronBufferGeometry =
            exports.HemisphereLightProbe =
            exports.HemisphereLightHelper =
            exports.HemisphereLight =
            exports.HalfFloatType =
            exports.Group =
            exports.GridHelper =
            exports.GreaterStencilFunc =
            exports.GreaterEqualStencilFunc =
            exports.GreaterEqualDepth =
            exports.GreaterDepth =
            exports.GammaEncoding =
            exports.GLSL3 =
            exports.GLSL1 =
            exports.GLBufferAttribute =
            exports.Frustum =
            exports.FrontSide =
            exports.FontLoader =
            exports.Font =
            exports.FogExp2 =
            exports.Fog =
            exports.FloatType =
            exports.Float64BufferAttribute =
            void 0),
          (exports.Int16Attribute = Nx),
          (exports.Int16BufferAttribute = void 0),
          (exports.Int32Attribute = zx),
          (exports.Int32BufferAttribute = void 0),
          (exports.Int8Attribute = Ix),
          (exports.InvertStencilOp =
            exports.InterpolateSmooth =
            exports.InterpolateLinear =
            exports.InterpolateDiscrete =
            exports.Interpolant =
            exports.InterleavedBufferAttribute =
            exports.InterleavedBuffer =
            exports.IntType =
            exports.Int8BufferAttribute =
            void 0),
          (exports.JSONLoader = Jx),
          (exports.Layers =
            exports.LatheGeometry =
            exports.LatheBufferGeometry =
            exports.LOD =
            exports.KeyframeTrack =
            exports.KeepStencilOp =
            void 0),
          (exports.LensFlare = Kx),
          (exports.LinearMipmapNearestFilter =
            exports.LinearMipmapLinearFilter =
            exports.LinearMipMapNearestFilter =
            exports.LinearMipMapLinearFilter =
            exports.LinearInterpolant =
            exports.LinearFilter =
            exports.LinearEncoding =
            exports.LineStrip =
            exports.LineSegments =
            exports.LinePieces =
            exports.LineLoop =
            exports.LineDashedMaterial =
            exports.LineCurve3 =
            exports.LineCurve =
            exports.LineBasicMaterial =
            exports.Line3 =
            exports.Line =
            exports.LightProbe =
            exports.Light =
            exports.LessStencilFunc =
            exports.LessEqualStencilFunc =
            exports.LessEqualDepth =
            exports.LessDepth =
            void 0),
          (exports.MeshDistanceMaterial =
            exports.MeshDepthMaterial =
            exports.MeshBasicMaterial =
            exports.Mesh =
            exports.MaxEquation =
            exports.Matrix4 =
            exports.Matrix3 =
            exports.MathUtils =
            exports.Math =
            exports.MaterialLoader =
            exports.Material =
            exports.MOUSE =
            exports.LuminanceFormat =
            exports.LuminanceAlphaFormat =
            exports.LoopRepeat =
            exports.LoopPingPong =
            exports.LoopOnce =
            exports.LogLuvEncoding =
            exports.LoadingManager =
            exports.LoaderUtils =
            exports.Loader =
            exports.LinearToneMapping =
            exports.LinearMipmapNearestFilter =
            exports.LinearMipmapLinearFilter =
            exports.LinearMipMapNearestFilter =
            exports.LinearMipMapLinearFilter =
            exports.LinearInterpolant =
            exports.LinearFilter =
            exports.LinearEncoding =
            exports.LineStrip =
            exports.LineSegments =
            exports.LinePieces =
            exports.LineLoop =
            exports.LineDashedMaterial =
            exports.LineCurve3 =
            exports.LineCurve =
            exports.LineBasicMaterial =
            exports.Line3 =
            exports.Line =
            exports.LightProbe =
            exports.Light =
            exports.LessStencilFunc =
            exports.LessEqualStencilFunc =
            exports.LessEqualDepth =
            exports.LessDepth =
            void 0),
          (exports.MeshFaceMaterial = bx),
          (exports.MixOperation =
            exports.MirroredRepeatWrapping =
            exports.MinEquation =
            exports.MeshToonMaterial =
            exports.MeshStandardMaterial =
            exports.MeshPhysicalMaterial =
            exports.MeshPhongMaterial =
            exports.MeshNormalMaterial =
            exports.MeshMatcapMaterial =
            exports.MeshLambertMaterial =
            void 0),
          (exports.MultiMaterial = Sx),
          (exports.ParametricGeometry =
            exports.ParametricBufferGeometry =
            exports.PMREMGenerator =
            exports.PCFSoftShadowMap =
            exports.PCFShadowMap =
            exports.OrthographicCamera =
            exports.OneMinusSrcColorFactor =
            exports.OneMinusSrcAlphaFactor =
            exports.OneMinusDstColorFactor =
            exports.OneMinusDstAlphaFactor =
            exports.OneFactor =
            exports.OctahedronGeometry =
            exports.OctahedronBufferGeometry =
            exports.ObjectSpaceNormalMap =
            exports.ObjectLoader =
            exports.Object3D =
            exports.NumberKeyframeTrack =
            exports.NotEqualStencilFunc =
            exports.NotEqualDepth =
            exports.NormalBlending =
            exports.NormalAnimationBlendMode =
            exports.NoToneMapping =
            exports.NoColors =
            exports.NoBlending =
            exports.NeverStencilFunc =
            exports.NeverDepth =
            exports.NearestMipmapNearestFilter =
            exports.NearestMipmapLinearFilter =
            exports.NearestMipMapNearestFilter =
            exports.NearestMipMapLinearFilter =
            exports.NearestFilter =
            exports.MultiplyOperation =
            exports.MultiplyBlending =
            void 0),
          (exports.Particle = Ex),
          (exports.ParticleBasicMaterial = Rx),
          (exports.ParticleSystem = Ax),
          (exports.ParticleSystemMaterial = Cx),
          (exports.PlaneHelper =
            exports.PlaneGeometry =
            exports.PlaneBufferGeometry =
            exports.Plane =
            exports.PerspectiveCamera =
            exports.Path =
            void 0),
          (exports.PointCloud = Tx),
          (exports.PointCloudMaterial = Lx),
          (exports.RGBA_ASTC_10x5_Format =
            exports.RGBA_ASTC_10x10_Format =
            exports.RGBAIntegerFormat =
            exports.RGBAFormat =
            exports.RGBADepthPacking =
            exports.REVISION =
            exports.QuaternionLinearInterpolant =
            exports.QuaternionKeyframeTrack =
            exports.Quaternion =
            exports.QuadraticBezierCurve3 =
            exports.QuadraticBezierCurve =
            exports.PropertyMixer =
            exports.PropertyBinding =
            exports.PositionalAudio =
            exports.PolyhedronGeometry =
            exports.PolyhedronBufferGeometry =
            exports.PolarGridHelper =
            exports.PointsMaterial =
            exports.Points =
            exports.PointLightHelper =
            exports.PointLight =
            void 0),
          (exports.TangentSpaceNormalMap =
            exports.TOUCH =
            exports.SubtractiveBlending =
            exports.SubtractEquation =
            exports.StringKeyframeTrack =
            exports.StreamReadUsage =
            exports.StreamDrawUsage =
            exports.StreamCopyUsage =
            exports.StereoCamera =
            exports.StaticReadUsage =
            exports.StaticDrawUsage =
            exports.StaticCopyUsage =
            exports.SrcColorFactor =
            exports.SrcAlphaSaturateFactor =
            exports.SrcAlphaFactor =
            exports.SpriteMaterial =
            exports.Sprite =
            exports.SpotLightHelper =
            exports.SpotLight =
            exports.SplineCurve =
            exports.SphericalHarmonics3 =
            exports.Spherical =
            exports.SphereGeometry =
            exports.SphereBufferGeometry =
            exports.Sphere =
            exports.SmoothShading =
            exports.SkinnedMesh =
            exports.SkeletonHelper =
            exports.Skeleton =
            exports.ShortType =
            exports.ShapeUtils =
            exports.ShapePath =
            exports.ShapeGeometry =
            exports.ShapeBufferGeometry =
            exports.Shape =
            exports.ShadowMaterial =
            exports.ShaderMaterial =
            exports.ShaderLib =
            exports.ShaderChunk =
            exports.SceneUtils =
            exports.Scene =
            exports.SRGB8_ALPHA8_ASTC_8x8_Format =
            exports.SRGB8_ALPHA8_ASTC_8x6_Format =
            exports.SRGB8_ALPHA8_ASTC_8x5_Format =
            exports.SRGB8_ALPHA8_ASTC_6x6_Format =
            exports.SRGB8_ALPHA8_ASTC_6x5_Format =
            exports.SRGB8_ALPHA8_ASTC_5x5_Format =
            exports.SRGB8_ALPHA8_ASTC_5x4_Format =
            exports.SRGB8_ALPHA8_ASTC_4x4_Format =
            exports.SRGB8_ALPHA8_ASTC_12x12_Format =
            exports.SRGB8_ALPHA8_ASTC_12x10_Format =
            exports.SRGB8_ALPHA8_ASTC_10x8_Format =
            exports.SRGB8_ALPHA8_ASTC_10x6_Format =
            exports.SRGB8_ALPHA8_ASTC_10x5_Format =
            exports.SRGB8_ALPHA8_ASTC_10x10_Format =
            exports.RingGeometry =
            exports.RingBufferGeometry =
            exports.ReverseSubtractEquation =
            exports.ReplaceStencilOp =
            exports.RepeatWrapping =
            exports.ReinhardToneMapping =
            exports.RedIntegerFormat =
            exports.RedFormat =
            exports.RectAreaLight =
            exports.Raycaster =
            exports.Ray =
            exports.RawShaderMaterial =
            exports.RGIntegerFormat =
            exports.RGFormat =
            exports.RGB_S3TC_DXT1_Format =
            exports.RGB_PVRTC_4BPPV1_Format =
            exports.RGB_PVRTC_2BPPV1_Format =
            exports.RGB_ETC2_Format =
            exports.RGB_ETC1_Format =
            exports.RGBM7Encoding =
            exports.RGBM16Encoding =
            exports.RGBIntegerFormat =
            exports.RGBFormat =
            exports.RGBEFormat =
            exports.RGBEEncoding =
            exports.RGBDEncoding =
            exports.RGBA_S3TC_DXT5_Format =
            exports.RGBA_S3TC_DXT3_Format =
            exports.RGBA_S3TC_DXT1_Format =
            exports.RGBA_PVRTC_4BPPV1_Format =
            exports.RGBA_PVRTC_2BPPV1_Format =
            exports.RGBA_ETC2_EAC_Format =
            exports.RGBA_BPTC_Format =
            exports.RGBA_ASTC_8x8_Format =
            exports.RGBA_ASTC_8x6_Format =
            exports.RGBA_ASTC_8x5_Format =
            exports.RGBA_ASTC_6x6_Format =
            exports.RGBA_ASTC_6x5_Format =
            exports.RGBA_ASTC_5x5_Format =
            exports.RGBA_ASTC_5x4_Format =
            exports.RGBA_ASTC_4x4_Format =
            exports.RGBA_ASTC_12x12_Format =
            exports.RGBA_ASTC_12x10_Format =
            exports.RGBA_ASTC_10x8_Format =
            exports.RGBA_ASTC_10x6_Format =
            exports.RGBA_ASTC_10x5_Format =
            exports.RGBA_ASTC_10x10_Format =
            exports.RGBAIntegerFormat =
            exports.RGBAFormat =
            exports.RGBADepthPacking =
            exports.REVISION =
            exports.QuaternionLinearInterpolant =
            exports.QuaternionKeyframeTrack =
            exports.Quaternion =
            exports.QuadraticBezierCurve3 =
            exports.QuadraticBezierCurve =
            exports.PropertyMixer =
            exports.PropertyBinding =
            exports.PositionalAudio =
            exports.PolyhedronGeometry =
            exports.PolyhedronBufferGeometry =
            exports.PolarGridHelper =
            exports.PointsMaterial =
            exports.Points =
            exports.PointLightHelper =
            exports.PointLight =
            void 0),
          (exports.UVMapping =
            exports.TubeGeometry =
            exports.TubeBufferGeometry =
            exports.TrianglesDrawMode =
            exports.TriangleStripDrawMode =
            exports.TriangleFanDrawMode =
            exports.Triangle =
            exports.TorusKnotGeometry =
            exports.TorusKnotBufferGeometry =
            exports.TorusGeometry =
            exports.TorusBufferGeometry =
            exports.TextureLoader =
            exports.Texture =
            exports.TextGeometry =
            exports.TextBufferGeometry =
            exports.TetrahedronGeometry =
            exports.TetrahedronBufferGeometry =
            exports.TangentSpaceNormalMap =
            exports.TOUCH =
            exports.SubtractiveBlending =
            exports.SubtractEquation =
            exports.StringKeyframeTrack =
            exports.StreamReadUsage =
            exports.StreamDrawUsage =
            exports.StreamCopyUsage =
            exports.StereoCamera =
            exports.StaticReadUsage =
            exports.StaticDrawUsage =
            exports.StaticCopyUsage =
            exports.SrcColorFactor =
            exports.SrcAlphaSaturateFactor =
            exports.SrcAlphaFactor =
            exports.SpriteMaterial =
            exports.Sprite =
            exports.SpotLightHelper =
            exports.SpotLight =
            exports.SplineCurve =
            exports.SphericalHarmonics3 =
            exports.Spherical =
            exports.SphereGeometry =
            exports.SphereBufferGeometry =
            exports.Sphere =
            exports.SmoothShading =
            exports.SkinnedMesh =
            exports.SkeletonHelper =
            exports.Skeleton =
            exports.ShortType =
            exports.ShapeUtils =
            exports.ShapePath =
            exports.ShapeGeometry =
            exports.ShapeBufferGeometry =
            exports.Shape =
            exports.ShadowMaterial =
            exports.ShaderMaterial =
            exports.ShaderLib =
            exports.ShaderChunk =
            exports.SceneUtils =
            exports.Scene =
            exports.SRGB8_ALPHA8_ASTC_8x8_Format =
            exports.SRGB8_ALPHA8_ASTC_8x6_Format =
            exports.SRGB8_ALPHA8_ASTC_8x5_Format =
            exports.SRGB8_ALPHA8_ASTC_6x6_Format =
            exports.SRGB8_ALPHA8_ASTC_6x5_Format =
            exports.SRGB8_ALPHA8_ASTC_5x5_Format =
            exports.SRGB8_ALPHA8_ASTC_5x4_Format =
            exports.SRGB8_ALPHA8_ASTC_4x4_Format =
            exports.SRGB8_ALPHA8_ASTC_12x12_Format =
            exports.SRGB8_ALPHA8_ASTC_12x10_Format =
            exports.SRGB8_ALPHA8_ASTC_10x8_Format =
            exports.SRGB8_ALPHA8_ASTC_10x6_Format =
            exports.SRGB8_ALPHA8_ASTC_10x5_Format =
            exports.SRGB8_ALPHA8_ASTC_10x10_Format =
            exports.RingGeometry =
            exports.RingBufferGeometry =
            exports.ReverseSubtractEquation =
            exports.ReplaceStencilOp =
            exports.RepeatWrapping =
            exports.ReinhardToneMapping =
            exports.RedIntegerFormat =
            exports.RedFormat =
            exports.RectAreaLight =
            exports.Raycaster =
            exports.Ray =
            exports.RawShaderMaterial =
            exports.RGIntegerFormat =
            exports.RGFormat =
            exports.RGB_S3TC_DXT1_Format =
            exports.RGB_PVRTC_4BPPV1_Format =
            exports.RGB_PVRTC_2BPPV1_Format =
            exports.RGB_ETC2_Format =
            exports.RGB_ETC1_Format =
            exports.RGBM7Encoding =
            exports.RGBM16Encoding =
            exports.RGBIntegerFormat =
            exports.RGBFormat =
            exports.RGBEFormat =
            exports.RGBEEncoding =
            exports.RGBDEncoding =
            exports.RGBA_S3TC_DXT5_Format =
            exports.RGBA_S3TC_DXT3_Format =
            exports.RGBA_S3TC_DXT1_Format =
            exports.RGBA_PVRTC_4BPPV1_Format =
            exports.RGBA_PVRTC_2BPPV1_Format =
            exports.RGBA_ETC2_EAC_Format =
            exports.RGBA_BPTC_Format =
            exports.RGBA_ASTC_8x8_Format =
            exports.RGBA_ASTC_8x6_Format =
            exports.RGBA_ASTC_8x5_Format =
            exports.RGBA_ASTC_6x6_Format =
            exports.RGBA_ASTC_6x5_Format =
            exports.RGBA_ASTC_5x5_Format =
            exports.RGBA_ASTC_5x4_Format =
            exports.RGBA_ASTC_4x4_Format =
            exports.RGBA_ASTC_12x12_Format =
            exports.RGBA_ASTC_12x10_Format =
            exports.RGBA_ASTC_10x8_Format =
            exports.RGBA_ASTC_10x6_Format =
            exports.RGBA_ASTC_10x5_Format =
            exports.RGBA_ASTC_10x10_Format =
            exports.RGBAIntegerFormat =
            exports.RGBAFormat =
            exports.RGBADepthPacking =
            exports.REVISION =
            exports.QuaternionLinearInterpolant =
            exports.QuaternionKeyframeTrack =
            exports.Quaternion =
            exports.QuadraticBezierCurve3 =
            exports.QuadraticBezierCurve =
            exports.PropertyMixer =
            exports.PropertyBinding =
            exports.PositionalAudio =
            exports.PolyhedronGeometry =
            exports.PolyhedronBufferGeometry =
            exports.PolarGridHelper =
            exports.PointsMaterial =
            exports.Points =
            exports.PointLightHelper =
            exports.PointLight =
            void 0),
          (exports.Uint16Attribute = Gx),
          (exports.Uint16BufferAttribute = void 0),
          (exports.Uint32Attribute = Ox),
          (exports.Uint32BufferAttribute = void 0),
          (exports.Uint8Attribute = Bx),
          (exports.Uint8BufferAttribute = void 0),
          (exports.Uint8ClampedAttribute = Fx),
          (exports.VectorKeyframeTrack =
            exports.Vector4 =
            exports.Vector3 =
            exports.Vector2 =
            exports.VSMShadowMap =
            exports.UnsignedShortType =
            exports.UnsignedShort565Type =
            exports.UnsignedShort5551Type =
            exports.UnsignedShort4444Type =
            exports.UnsignedIntType =
            exports.UnsignedInt248Type =
            exports.UnsignedByteType =
            exports.UniformsUtils =
            exports.UniformsLib =
            exports.Uniform =
            exports.Uint8ClampedBufferAttribute =
            void 0),
          (exports.Vertex = Px),
          (exports.WebGLRenderTarget =
            exports.WebGLMultisampleRenderTarget =
            exports.WebGLMultipleRenderTargets =
            exports.WebGLCubeRenderTarget =
            exports.WebGL1Renderer =
            exports.VideoTexture =
            exports.VertexColors =
            void 0),
          (exports.WebGLRenderTargetCube = Yx),
          (exports.WebGLRenderer = Yh),
          (exports.WebGLUtils = Hh),
          (exports.WireframeGeometry = void 0),
          (exports.WireframeHelper = jx),
          (exports.WrapAroundEnding = void 0),
          (exports.XHRLoader = qx),
          (exports.sRGBEncoding =
            exports.ZeroStencilOp =
            exports.ZeroSlopeEnding =
            exports.ZeroFactor =
            exports.ZeroCurvatureEnding =
            void 0);
        const t = "129";
        exports.REVISION = "129";
        const e = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
        exports.MOUSE = e;
        const n = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
        exports.TOUCH = n;
        const r = 0;
        exports.CullFaceNone = r;
        const i = 1;
        exports.CullFaceBack = i;
        const s = 2;
        exports.CullFaceFront = s;
        const o = 3;
        exports.CullFaceFrontBack = 3;
        const a = 0;
        exports.BasicShadowMap = 0;
        const l = 1;
        exports.PCFShadowMap = l;
        const c = 2;
        exports.PCFSoftShadowMap = c;
        const h = 3;
        exports.VSMShadowMap = h;
        const u = 0;
        exports.FrontSide = u;
        const p = 1;
        exports.BackSide = p;
        const d = 2;
        exports.DoubleSide = d;
        const m = 1;
        exports.FlatShading = m;
        const f = 2;
        exports.SmoothShading = 2;
        const g = 0;
        exports.NoBlending = g;
        const x = 1;
        exports.NormalBlending = x;
        const v = 2;
        exports.AdditiveBlending = v;
        const y = 3;
        exports.SubtractiveBlending = y;
        const _ = 4;
        exports.MultiplyBlending = _;
        const M = 5;
        exports.CustomBlending = M;
        const w = 100;
        exports.AddEquation = w;
        const b = 101;
        exports.SubtractEquation = b;
        const S = 102;
        exports.ReverseSubtractEquation = S;
        const T = 103;
        exports.MinEquation = T;
        const E = 104;
        exports.MaxEquation = E;
        const A = 200;
        exports.ZeroFactor = A;
        const L = 201;
        exports.OneFactor = L;
        const R = 202;
        exports.SrcColorFactor = R;
        const C = 203;
        exports.OneMinusSrcColorFactor = C;
        const P = 204;
        exports.SrcAlphaFactor = P;
        const D = 205;
        exports.OneMinusSrcAlphaFactor = D;
        const I = 206;
        exports.DstAlphaFactor = I;
        const B = 207;
        exports.OneMinusDstAlphaFactor = B;
        const F = 208;
        exports.DstColorFactor = F;
        const N = 209;
        exports.OneMinusDstColorFactor = N;
        const G = 210;
        exports.SrcAlphaSaturateFactor = G;
        const z = 0;
        exports.NeverDepth = z;
        const O = 1;
        exports.AlwaysDepth = O;
        const H = 2;
        exports.LessDepth = H;
        const U = 3;
        exports.LessEqualDepth = U;
        const k = 4;
        exports.EqualDepth = k;
        const V = 5;
        exports.GreaterEqualDepth = V;
        const W = 6;
        exports.GreaterDepth = W;
        const j = 7;
        exports.NotEqualDepth = j;
        const q = 0;
        exports.MultiplyOperation = q;
        const X = 1;
        exports.MixOperation = X;
        const Y = 2;
        exports.AddOperation = Y;
        const Z = 0;
        exports.NoToneMapping = Z;
        const J = 1;
        exports.LinearToneMapping = J;
        const Q = 2;
        exports.ReinhardToneMapping = Q;
        const K = 3;
        exports.CineonToneMapping = K;
        const $ = 4;
        exports.ACESFilmicToneMapping = $;
        const tt = 5;
        exports.CustomToneMapping = tt;
        const et = 300;
        exports.UVMapping = et;
        const nt = 301;
        exports.CubeReflectionMapping = nt;
        const rt = 302;
        exports.CubeRefractionMapping = rt;
        const it = 303;
        exports.EquirectangularReflectionMapping = it;
        const st = 304;
        exports.EquirectangularRefractionMapping = st;
        const ot = 306;
        exports.CubeUVReflectionMapping = ot;
        const at = 307;
        exports.CubeUVRefractionMapping = at;
        const lt = 1e3;
        exports.RepeatWrapping = lt;
        const ct = 1001;
        exports.ClampToEdgeWrapping = ct;
        const ht = 1002;
        exports.MirroredRepeatWrapping = ht;
        const ut = 1003;
        exports.NearestFilter = ut;
        const pt = 1004;
        exports.NearestMipmapNearestFilter = pt;
        const dt = 1004;
        exports.NearestMipMapNearestFilter = 1004;
        const mt = 1005;
        exports.NearestMipmapLinearFilter = mt;
        const ft = 1005;
        exports.NearestMipMapLinearFilter = 1005;
        const gt = 1006;
        exports.LinearFilter = gt;
        const xt = 1007;
        exports.LinearMipmapNearestFilter = xt;
        const vt = 1007;
        exports.LinearMipMapNearestFilter = 1007;
        const yt = 1008;
        exports.LinearMipmapLinearFilter = yt;
        const _t = 1008;
        exports.LinearMipMapLinearFilter = 1008;
        const Mt = 1009;
        exports.UnsignedByteType = Mt;
        const wt = 1010;
        exports.ByteType = wt;
        const bt = 1011;
        exports.ShortType = bt;
        const St = 1012;
        exports.UnsignedShortType = St;
        const Tt = 1013;
        exports.IntType = Tt;
        const Et = 1014;
        exports.UnsignedIntType = Et;
        const At = 1015;
        exports.FloatType = At;
        const Lt = 1016;
        exports.HalfFloatType = Lt;
        const Rt = 1017;
        exports.UnsignedShort4444Type = Rt;
        const Ct = 1018;
        exports.UnsignedShort5551Type = Ct;
        const Pt = 1019;
        exports.UnsignedShort565Type = Pt;
        const Dt = 1020;
        exports.UnsignedInt248Type = Dt;
        const It = 1021;
        exports.AlphaFormat = It;
        const Bt = 1022;
        exports.RGBFormat = Bt;
        const Ft = 1023;
        exports.RGBAFormat = Ft;
        const Nt = 1024;
        exports.LuminanceFormat = Nt;
        const Gt = 1025;
        exports.LuminanceAlphaFormat = Gt;
        const zt = Ft;
        exports.RGBEFormat = zt;
        const Ot = 1026;
        exports.DepthFormat = Ot;
        const Ht = 1027;
        exports.DepthStencilFormat = Ht;
        const Ut = 1028;
        exports.RedFormat = Ut;
        const kt = 1029;
        exports.RedIntegerFormat = kt;
        const Vt = 1030;
        exports.RGFormat = Vt;
        const Wt = 1031;
        exports.RGIntegerFormat = Wt;
        const jt = 1032;
        exports.RGBIntegerFormat = jt;
        const qt = 1033;
        exports.RGBAIntegerFormat = qt;
        const Xt = 33776;
        exports.RGB_S3TC_DXT1_Format = Xt;
        const Yt = 33777;
        exports.RGBA_S3TC_DXT1_Format = Yt;
        const Zt = 33778;
        exports.RGBA_S3TC_DXT3_Format = Zt;
        const Jt = 33779;
        exports.RGBA_S3TC_DXT5_Format = Jt;
        const Qt = 35840;
        exports.RGB_PVRTC_4BPPV1_Format = Qt;
        const Kt = 35841;
        exports.RGB_PVRTC_2BPPV1_Format = Kt;
        const $t = 35842;
        exports.RGBA_PVRTC_4BPPV1_Format = $t;
        const te = 35843;
        exports.RGBA_PVRTC_2BPPV1_Format = te;
        const ee = 36196;
        exports.RGB_ETC1_Format = ee;
        const ne = 37492;
        exports.RGB_ETC2_Format = ne;
        const re = 37496;
        exports.RGBA_ETC2_EAC_Format = re;
        const ie = 37808;
        exports.RGBA_ASTC_4x4_Format = ie;
        const se = 37809;
        exports.RGBA_ASTC_5x4_Format = se;
        const oe = 37810;
        exports.RGBA_ASTC_5x5_Format = oe;
        const ae = 37811;
        exports.RGBA_ASTC_6x5_Format = ae;
        const le = 37812;
        exports.RGBA_ASTC_6x6_Format = le;
        const ce = 37813;
        exports.RGBA_ASTC_8x5_Format = ce;
        const he = 37814;
        exports.RGBA_ASTC_8x6_Format = he;
        const ue = 37815;
        exports.RGBA_ASTC_8x8_Format = ue;
        const pe = 37816;
        exports.RGBA_ASTC_10x5_Format = pe;
        const de = 37817;
        exports.RGBA_ASTC_10x6_Format = de;
        const me = 37818;
        exports.RGBA_ASTC_10x8_Format = me;
        const fe = 37819;
        exports.RGBA_ASTC_10x10_Format = fe;
        const ge = 37820;
        exports.RGBA_ASTC_12x10_Format = ge;
        const xe = 37821;
        exports.RGBA_ASTC_12x12_Format = xe;
        const ve = 36492;
        exports.RGBA_BPTC_Format = ve;
        const ye = 37840;
        exports.SRGB8_ALPHA8_ASTC_4x4_Format = ye;
        const _e = 37841;
        exports.SRGB8_ALPHA8_ASTC_5x4_Format = _e;
        const Me = 37842;
        exports.SRGB8_ALPHA8_ASTC_5x5_Format = Me;
        const we = 37843;
        exports.SRGB8_ALPHA8_ASTC_6x5_Format = we;
        const be = 37844;
        exports.SRGB8_ALPHA8_ASTC_6x6_Format = be;
        const Se = 37845;
        exports.SRGB8_ALPHA8_ASTC_8x5_Format = Se;
        const Te = 37846;
        exports.SRGB8_ALPHA8_ASTC_8x6_Format = Te;
        const Ee = 37847;
        exports.SRGB8_ALPHA8_ASTC_8x8_Format = Ee;
        const Ae = 37848;
        exports.SRGB8_ALPHA8_ASTC_10x5_Format = Ae;
        const Le = 37849;
        exports.SRGB8_ALPHA8_ASTC_10x6_Format = Le;
        const Re = 37850;
        exports.SRGB8_ALPHA8_ASTC_10x8_Format = Re;
        const Ce = 37851;
        exports.SRGB8_ALPHA8_ASTC_10x10_Format = Ce;
        const Pe = 37852;
        exports.SRGB8_ALPHA8_ASTC_12x10_Format = Pe;
        const De = 37853;
        exports.SRGB8_ALPHA8_ASTC_12x12_Format = De;
        const Ie = 2200;
        exports.LoopOnce = Ie;
        const Be = 2201;
        exports.LoopRepeat = Be;
        const Fe = 2202;
        exports.LoopPingPong = Fe;
        const Ne = 2300;
        exports.InterpolateDiscrete = Ne;
        const Ge = 2301;
        exports.InterpolateLinear = Ge;
        const ze = 2302;
        exports.InterpolateSmooth = ze;
        const Oe = 2400;
        exports.ZeroCurvatureEnding = Oe;
        const He = 2401;
        exports.ZeroSlopeEnding = He;
        const Ue = 2402;
        exports.WrapAroundEnding = Ue;
        const ke = 2500;
        exports.NormalAnimationBlendMode = ke;
        const Ve = 2501;
        exports.AdditiveAnimationBlendMode = Ve;
        const We = 0;
        exports.TrianglesDrawMode = 0;
        const je = 1;
        exports.TriangleStripDrawMode = 1;
        const qe = 2;
        exports.TriangleFanDrawMode = 2;
        const Xe = 3e3;
        exports.LinearEncoding = Xe;
        const Ye = 3001;
        exports.sRGBEncoding = Ye;
        const Ze = 3007;
        exports.GammaEncoding = Ze;
        const Je = 3002;
        exports.RGBEEncoding = Je;
        const Qe = 3003;
        exports.LogLuvEncoding = Qe;
        const Ke = 3004;
        exports.RGBM7Encoding = Ke;
        const $e = 3005;
        exports.RGBM16Encoding = $e;
        const tn = 3006;
        exports.RGBDEncoding = tn;
        const en = 3200;
        exports.BasicDepthPacking = en;
        const nn = 3201;
        exports.RGBADepthPacking = nn;
        const rn = 0;
        exports.TangentSpaceNormalMap = rn;
        const sn = 1;
        exports.ObjectSpaceNormalMap = sn;
        const on = 0;
        exports.ZeroStencilOp = 0;
        const an = 7680;
        exports.KeepStencilOp = an;
        const ln = 7681;
        exports.ReplaceStencilOp = 7681;
        const cn = 7682;
        exports.IncrementStencilOp = 7682;
        const hn = 7683;
        exports.DecrementStencilOp = 7683;
        const un = 34055;
        exports.IncrementWrapStencilOp = 34055;
        const pn = 34056;
        exports.DecrementWrapStencilOp = 34056;
        const dn = 5386;
        exports.InvertStencilOp = 5386;
        const mn = 512;
        exports.NeverStencilFunc = 512;
        const fn = 513;
        exports.LessStencilFunc = 513;
        const gn = 514;
        exports.EqualStencilFunc = 514;
        const xn = 515;
        exports.LessEqualStencilFunc = 515;
        const vn = 516;
        exports.GreaterStencilFunc = 516;
        const yn = 517;
        exports.NotEqualStencilFunc = 517;
        const _n = 518;
        exports.GreaterEqualStencilFunc = 518;
        const Mn = 519;
        exports.AlwaysStencilFunc = Mn;
        const wn = 35044;
        exports.StaticDrawUsage = wn;
        const bn = 35048;
        exports.DynamicDrawUsage = bn;
        const Sn = 35040;
        exports.StreamDrawUsage = 35040;
        const Tn = 35045;
        exports.StaticReadUsage = 35045;
        const En = 35049;
        exports.DynamicReadUsage = 35049;
        const An = 35041;
        exports.StreamReadUsage = 35041;
        const Ln = 35046;
        exports.StaticCopyUsage = 35046;
        const Rn = 35050;
        exports.DynamicCopyUsage = 35050;
        const Cn = 35042;
        exports.StreamCopyUsage = 35042;
        const Pn = "100";
        exports.GLSL1 = "100";
        const Dn = "300 es";
        exports.GLSL3 = Dn;
        class In {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        exports.EventDispatcher = In;
        const Bn = [];
        for (let $x = 0; $x < 256; $x++)
          Bn[$x] = ($x < 16 ? "0" : "") + $x.toString(16);
        let Fn = 1234567;
        const Nn = Math.PI / 180,
          Gn = 180 / Math.PI;
        function zn() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            r = (4294967295 * Math.random()) | 0;
          return (
            Bn[255 & t] +
            Bn[(t >> 8) & 255] +
            Bn[(t >> 16) & 255] +
            Bn[(t >> 24) & 255] +
            "-" +
            Bn[255 & e] +
            Bn[(e >> 8) & 255] +
            "-" +
            Bn[((e >> 16) & 15) | 64] +
            Bn[(e >> 24) & 255] +
            "-" +
            Bn[(63 & n) | 128] +
            Bn[(n >> 8) & 255] +
            "-" +
            Bn[(n >> 16) & 255] +
            Bn[(n >> 24) & 255] +
            Bn[255 & r] +
            Bn[(r >> 8) & 255] +
            Bn[(r >> 16) & 255] +
            Bn[(r >> 24) & 255]
          ).toUpperCase();
        }
        function On(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function Hn(t, e) {
          return ((t % e) + e) % e;
        }
        function Un(t, e, n, r, i) {
          return r + ((t - e) * (i - r)) / (n - e);
        }
        function kn(t, e, n) {
          return t !== e ? (n - t) / (e - t) : 0;
        }
        function Vn(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function Wn(t, e, n, r) {
          return Vn(t, e, 1 - Math.exp(-n * r));
        }
        function jn(t, e = 1) {
          return e - Math.abs(Hn(t, 2 * e) - e);
        }
        function qn(t, e, n) {
          return t <= e
            ? 0
            : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
        }
        function Xn(t, e, n) {
          return t <= e
            ? 0
            : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
        }
        function Yn(t, e) {
          return t + Math.floor(Math.random() * (e - t + 1));
        }
        function Zn(t, e) {
          return t + Math.random() * (e - t);
        }
        function Jn(t) {
          return t * (0.5 - Math.random());
        }
        function Qn(t) {
          return (
            void 0 !== t && (Fn = t % 2147483647),
            ((Fn = (16807 * Fn) % 2147483647) - 1) / 2147483646
          );
        }
        function Kn(t) {
          return t * Nn;
        }
        function $n(t) {
          return t * Gn;
        }
        function tr(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function er(t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }
        function nr(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        function rr(t, e, n, r, i) {
          const s = Math.cos,
            o = Math.sin,
            a = s(n / 2),
            l = o(n / 2),
            c = s((e + r) / 2),
            h = o((e + r) / 2),
            u = s((e - r) / 2),
            p = o((e - r) / 2),
            d = s((r - e) / 2),
            m = o((r - e) / 2);
          switch (i) {
            case "XYX":
              t.set(a * h, l * u, l * p, a * c);
              break;
            case "YZY":
              t.set(l * p, a * h, l * u, a * c);
              break;
            case "ZXZ":
              t.set(l * u, l * p, a * h, a * c);
              break;
            case "XZX":
              t.set(a * h, l * m, l * d, a * c);
              break;
            case "YXY":
              t.set(l * d, a * h, l * m, a * c);
              break;
            case "ZYZ":
              t.set(l * m, l * d, a * h, a * c);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                i
              );
          }
        }
        var ir = Object.freeze({
          __proto__: null,
          DEG2RAD: Nn,
          RAD2DEG: Gn,
          generateUUID: zn,
          clamp: On,
          euclideanModulo: Hn,
          mapLinear: Un,
          inverseLerp: kn,
          lerp: Vn,
          damp: Wn,
          pingpong: jn,
          smoothstep: qn,
          smootherstep: Xn,
          randInt: Yn,
          randFloat: Zn,
          randFloatSpread: Jn,
          seededRandom: Qn,
          degToRad: Kn,
          radToDeg: $n,
          isPowerOfTwo: tr,
          ceilPowerOfTwo: er,
          floorPowerOfTwo: nr,
          setQuaternionFromProperEuler: rr,
        });
        exports.MathUtils = exports.Math = ir;
        class sr {
          constructor(t = 0, e = 0) {
            (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6]),
              (this.y = r[1] * e + r[4] * n + r[7]),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
              console.warn(
                "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
              ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            );
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              r = Math.sin(e),
              i = this.x - t.x,
              s = this.y - t.y;
            return (
              (this.x = i * n - s * r + t.x),
              (this.y = i * r + s * n + t.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
        }
        (exports.Vector2 = sr), (sr.prototype.isVector2 = !0);
        class or {
          constructor() {
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              arguments.length > 0 &&
              console.error(
                "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
              );
          }
          set(t, e, n, r, i, s, o, a, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = r),
              (c[2] = o),
              (c[3] = e),
              (c[4] = i),
              (c[5] = a),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              r = e.elements,
              i = this.elements,
              s = n[0],
              o = n[3],
              a = n[6],
              l = n[1],
              c = n[4],
              h = n[7],
              u = n[2],
              p = n[5],
              d = n[8],
              m = r[0],
              f = r[3],
              g = r[6],
              x = r[1],
              v = r[4],
              y = r[7],
              _ = r[2],
              M = r[5],
              w = r[8];
            return (
              (i[0] = s * m + o * x + a * _),
              (i[3] = s * f + o * v + a * M),
              (i[6] = s * g + o * y + a * w),
              (i[1] = l * m + c * x + h * _),
              (i[4] = l * f + c * v + h * M),
              (i[7] = l * g + c * y + h * w),
              (i[2] = u * m + p * x + d * _),
              (i[5] = u * f + p * v + d * M),
              (i[8] = u * g + p * y + d * w),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              r = t[2],
              i = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8];
            return (
              e * s * c -
              e * o * l -
              n * i * c +
              n * o * a +
              r * i * l -
              r * s * a
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              r = t[2],
              i = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              h = c * s - o * l,
              u = o * a - c * i,
              p = l * i - s * a,
              d = e * h + n * u + r * p;
            if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / d;
            return (
              (t[0] = h * m),
              (t[1] = (r * l - c * n) * m),
              (t[2] = (o * n - r * s) * m),
              (t[3] = u * m),
              (t[4] = (c * e - r * a) * m),
              (t[5] = (r * i - o * e) * m),
              (t[6] = p * m),
              (t[7] = (n * a - l * e) * m),
              (t[8] = (s * e - n * i) * m),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, r, i, s, o) {
            const a = Math.cos(i),
              l = Math.sin(i);
            return (
              this.set(
                n * a,
                n * l,
                -n * (a * s + l * o) + s + t,
                -r * l,
                r * a,
                -r * (-l * s + a * o) + o + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            const n = this.elements;
            return (
              (n[0] *= t),
              (n[3] *= t),
              (n[6] *= t),
              (n[1] *= e),
              (n[4] *= e),
              (n[7] *= e),
              this
            );
          }
          rotate(t) {
            const e = Math.cos(t),
              n = Math.sin(t),
              r = this.elements,
              i = r[0],
              s = r[3],
              o = r[6],
              a = r[1],
              l = r[4],
              c = r[7];
            return (
              (r[0] = e * i + n * a),
              (r[3] = e * s + n * l),
              (r[6] = e * o + n * c),
              (r[1] = -n * i + e * a),
              (r[4] = -n * s + e * l),
              (r[7] = -n * o + e * c),
              this
            );
          }
          translate(t, e) {
            const n = this.elements;
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let r = 0; r < 9; r++) if (e[r] !== n[r]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        let ar;
        (exports.Matrix3 = or), (or.prototype.isMatrix3 = !0);
        class lr {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === ar &&
                (ar = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                )),
                (ar.width = t.width),
                (ar.height = t.height);
              const n = ar.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = ar);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
        }
        exports.ImageUtils = lr;
        let cr = 0;
        class hr extends In {
          constructor(
            t = hr.DEFAULT_IMAGE,
            e = hr.DEFAULT_MAPPING,
            n = ct,
            r = ct,
            i = gt,
            s = yt,
            o = Ft,
            a = Mt,
            l = 1,
            c = Xe
          ) {
            super(),
              Object.defineProperty(this, "id", { value: cr++ }),
              (this.uuid = zn()),
              (this.name = ""),
              (this.image = t),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.wrapS = n),
              (this.wrapT = r),
              (this.magFilter = i),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = o),
              (this.internalFormat = null),
              (this.type = a),
              (this.offset = new sr(0, 0)),
              (this.repeat = new sr(1, 1)),
              (this.center = new sr(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new or()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = c),
              (this.version = 0),
              (this.onUpdate = null);
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              const r = this.image;
              if (
                (void 0 === r.uuid && (r.uuid = zn()),
                  !e && void 0 === t.images[r.uuid])
              ) {
                let e;
                if (Array.isArray(r)) {
                  e = [];
                  for (let t = 0, n = r.length; t < n; t++)
                    r[t].isDataTexture
                      ? e.push(ur(r[t].image))
                      : e.push(ur(r[t]));
                } else e = ur(r);
                t.images[r.uuid] = { uuid: r.uuid, url: e };
              }
              n.image = r.uuid;
            }
            return e || (t.textures[this.uuid] = n), n;
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(t) {
            if (this.mapping !== et) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case lt:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case ct:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case ht:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case lt:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case ct:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case ht:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        function ur(t) {
          return ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? lr.getDataURL(t)
            : t.data
              ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
              : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        (exports.Texture = hr),
          (hr.DEFAULT_IMAGE = void 0),
          (hr.DEFAULT_MAPPING = et),
          (hr.prototype.isTexture = !0);
        class pr {
          constructor(t = 0, e = 0, n = 0, r = 1) {
            (this.x = t), (this.y = e), (this.z = n), (this.w = r);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, r) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = r), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
                this.addVectors(t, e))
              : ((this.x += t.x),
                (this.y += t.y),
                (this.z += t.z),
                (this.w += t.w),
                this);
          }
          addScalar(t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
                this.subVectors(t, e))
              : ((this.x -= t.x),
                (this.y -= t.y),
                (this.z -= t.z),
                (this.w -= t.w),
                this);
          }
          subScalar(t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (
              (this.x *= t.x),
              (this.y *= t.y),
              (this.z *= t.z),
              (this.w *= t.w),
              this
            );
          }
          multiplyScalar(t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              r = this.z,
              i = this.w,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * i),
              (this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * i),
              (this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * i),
              (this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * i),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, r, i;
            const s = t.elements,
              o = s[0],
              a = s[4],
              l = s[8],
              c = s[1],
              h = s[5],
              u = s[9],
              p = s[2],
              d = s[6],
              m = s[10];
            if (
              Math.abs(a - c) < 0.01 &&
              Math.abs(l - p) < 0.01 &&
              Math.abs(u - d) < 0.01
            ) {
              if (
                Math.abs(a + c) < 0.1 &&
                Math.abs(l + p) < 0.1 &&
                Math.abs(u + d) < 0.1 &&
                Math.abs(o + h + m - 3) < 0.1
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (o + 1) / 2,
                s = (h + 1) / 2,
                f = (m + 1) / 2,
                g = (a + c) / 4,
                x = (l + p) / 4,
                v = (u + d) / 4;
              return (
                t > s && t > f
                  ? t < 0.01
                    ? ((n = 0), (r = 0.707106781), (i = 0.707106781))
                    : ((r = g / (n = Math.sqrt(t))), (i = x / n))
                  : s > f
                    ? s < 0.01
                      ? ((n = 0.707106781), (r = 0), (i = 0.707106781))
                      : ((n = g / (r = Math.sqrt(s))), (i = v / r))
                    : f < 0.01
                      ? ((n = 0.707106781), (r = 0.707106781), (i = 0))
                      : ((n = x / (i = Math.sqrt(f))), (r = v / i)),
                this.set(n, r, i, e),
                this
              );
            }
            let f = Math.sqrt(
              (d - u) * (d - u) + (l - p) * (l - p) + (c - a) * (c - a)
            );
            return (
              Math.abs(f) < 0.001 && (f = 1),
              (this.x = (d - u) / f),
              (this.y = (l - p) / f),
              (this.z = (c - a) / f),
              (this.w = Math.acos((o + h + m - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
              console.warn(
                "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
              ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
        }
        (exports.Vector4 = pr), (pr.prototype.isVector4 = !0);
        class dr extends In {
          constructor(t, e, n) {
            super(),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new pr(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new pr(0, 0, t, e)),
              (n = n || {}),
              (this.texture = new hr(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
              )),
              (this.texture.image = {}),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = 1),
              (this.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== n.minFilter ? n.minFilter : gt),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer =
                void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture =
                void 0 !== n.depthTexture ? n.depthTexture : null);
          }
          setTexture(t) {
            (t.image = {
              width: this.width,
              height: this.height,
              depth: this.depth,
            }),
              (this.texture = t);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
                (this.height = e),
                (this.depth = n),
                (this.texture.image.width = t),
                (this.texture.image.height = e),
                (this.texture.image.depth = n),
                this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.texture.image = { ...this.texture.image }),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        (exports.WebGLRenderTarget = dr),
          (dr.prototype.isWebGLRenderTarget = !0);
        class mr extends dr {
          constructor(t, e, n) {
            super(t, e);
            const r = this.texture;
            this.texture = [];
            for (let i = 0; i < n; i++) this.texture[i] = r.clone();
          }
          setSize(t, e, n = 1) {
            if (this.width !== t || this.height !== e || this.depth !== n) {
              (this.width = t), (this.height = e), (this.depth = n);
              for (let r = 0, i = this.texture.length; r < i; r++)
                (this.texture[r].image.width = t),
                  (this.texture[r].image.height = e),
                  (this.texture[r].image.depth = n);
              this.dispose();
            }
            return (
              this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
            );
          }
          copy(t) {
            this.dispose(),
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.set(0, 0, this.width, this.height),
              this.scissor.set(0, 0, this.width, this.height),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              (this.texture.length = 0);
            for (let e = 0, n = t.texture.length; e < n; e++)
              this.texture[e] = t.texture[e].clone();
            return this;
          }
        }
        (exports.WebGLMultipleRenderTargets = mr),
          (mr.prototype.isWebGLMultipleRenderTargets = !0);
        class fr extends dr {
          constructor(t, e, n) {
            super(t, e, n), (this.samples = 4);
          }
          copy(t) {
            return super.copy.call(this, t), (this.samples = t.samples), this;
          }
        }
        (exports.WebGLMultisampleRenderTarget = fr),
          (fr.prototype.isWebGLMultisampleRenderTarget = !0);
        class gr {
          constructor(t = 0, e = 0, n = 0, r = 1) {
            (this._x = t), (this._y = e), (this._z = n), (this._w = r);
          }
          static slerp(t, e, n, r) {
            return (
              console.warn(
                "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
              ),
              n.slerpQuaternions(t, e, r)
            );
          }
          static slerpFlat(t, e, n, r, i, s, o) {
            let a = n[r + 0],
              l = n[r + 1],
              c = n[r + 2],
              h = n[r + 3];
            const u = i[s + 0],
              p = i[s + 1],
              d = i[s + 2],
              m = i[s + 3];
            if (0 === o)
              return (
                (t[e + 0] = a),
                (t[e + 1] = l),
                (t[e + 2] = c),
                void (t[e + 3] = h)
              );
            if (1 === o)
              return (
                (t[e + 0] = u),
                (t[e + 1] = p),
                (t[e + 2] = d),
                void (t[e + 3] = m)
              );
            if (h !== m || a !== u || l !== p || c !== d) {
              let t = 1 - o;
              const e = a * u + l * p + c * d + h * m,
                n = e >= 0 ? 1 : -1,
                r = 1 - e * e;
              if (r > Number.EPSILON) {
                const i = Math.sqrt(r),
                  s = Math.atan2(i, e * n);
                (t = Math.sin(t * s) / i), (o = Math.sin(o * s) / i);
              }
              const i = o * n;
              if (
                ((a = a * t + u * i),
                  (l = l * t + p * i),
                  (c = c * t + d * i),
                  (h = h * t + m * i),
                  t === 1 - o)
              ) {
                const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
                (a *= t), (l *= t), (c *= t), (h *= t);
              }
            }
            (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
          }
          static multiplyQuaternionsFlat(t, e, n, r, i, s) {
            const o = n[r],
              a = n[r + 1],
              l = n[r + 2],
              c = n[r + 3],
              h = i[s],
              u = i[s + 1],
              p = i[s + 2],
              d = i[s + 3];
            return (
              (t[e] = o * d + c * h + a * p - l * u),
              (t[e + 1] = a * d + c * u + l * h - o * p),
              (t[e + 2] = l * d + c * p + o * u - a * h),
              (t[e + 3] = c * d - o * h - a * u - l * p),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, r) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = r),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            const n = t._x,
              r = t._y,
              i = t._z,
              s = t._order,
              o = Math.cos,
              a = Math.sin,
              l = o(n / 2),
              c = o(r / 2),
              h = o(i / 2),
              u = a(n / 2),
              p = a(r / 2),
              d = a(i / 2);
            switch (s) {
              case "XYZ":
                (this._x = u * c * h + l * p * d),
                  (this._y = l * p * h - u * c * d),
                  (this._z = l * c * d + u * p * h),
                  (this._w = l * c * h - u * p * d);
                break;
              case "YXZ":
                (this._x = u * c * h + l * p * d),
                  (this._y = l * p * h - u * c * d),
                  (this._z = l * c * d - u * p * h),
                  (this._w = l * c * h + u * p * d);
                break;
              case "ZXY":
                (this._x = u * c * h - l * p * d),
                  (this._y = l * p * h + u * c * d),
                  (this._z = l * c * d + u * p * h),
                  (this._w = l * c * h - u * p * d);
                break;
              case "ZYX":
                (this._x = u * c * h - l * p * d),
                  (this._y = l * p * h + u * c * d),
                  (this._z = l * c * d - u * p * h),
                  (this._w = l * c * h + u * p * d);
                break;
              case "YZX":
                (this._x = u * c * h + l * p * d),
                  (this._y = l * p * h + u * c * d),
                  (this._z = l * c * d - u * p * h),
                  (this._w = l * c * h - u * p * d);
                break;
              case "XZY":
                (this._x = u * c * h - l * p * d),
                  (this._y = l * p * h - u * c * d),
                  (this._z = l * c * d + u * p * h),
                  (this._w = l * c * h + u * p * d);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
                );
            }
            return !1 !== e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              r = Math.sin(n);
            return (
              (this._x = t.x * r),
              (this._y = t.y * r),
              (this._z = t.z * r),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              r = e[4],
              i = e[8],
              s = e[1],
              o = e[5],
              a = e[9],
              l = e[2],
              c = e[6],
              h = e[10],
              u = n + o + h;
            if (u > 0) {
              const t = 0.5 / Math.sqrt(u + 1);
              (this._w = 0.25 / t),
                (this._x = (c - a) * t),
                (this._y = (i - l) * t),
                (this._z = (s - r) * t);
            } else if (n > o && n > h) {
              const t = 2 * Math.sqrt(1 + n - o - h);
              (this._w = (c - a) / t),
                (this._x = 0.25 * t),
                (this._y = (r + s) / t),
                (this._z = (i + l) / t);
            } else if (o > h) {
              const t = 2 * Math.sqrt(1 + o - n - h);
              (this._w = (i - l) / t),
                (this._x = (r + s) / t),
                (this._y = 0.25 * t),
                (this._z = (a + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + h - n - o);
              (this._w = (s - r) / t),
                (this._x = (i + l) / t),
                (this._y = (a + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y),
                      (this._y = t.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -t.z),
                      (this._z = t.y),
                      (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(On(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const r = Math.min(1, e / n);
            return this.slerp(t, r), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
              ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              r = t._y,
              i = t._z,
              s = t._w,
              o = e._x,
              a = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + s * o + r * l - i * a),
              (this._y = r * c + s * a + i * o - n * l),
              (this._z = i * c + s * l + n * a - r * o),
              (this._w = s * c - n * o - r * a - i * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              r = this._y,
              i = this._z,
              s = this._w;
            let o = s * t._w + n * t._x + r * t._y + i * t._z;
            if (
              (o < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (o = -o))
                : this.copy(t),
                o >= 1)
            )
              return (
                (this._w = s), (this._x = n), (this._y = r), (this._z = i), this
              );
            const a = 1 - o * o;
            if (a <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * r + e * this._y),
                (this._z = t * i + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            const l = Math.sqrt(a),
              c = Math.atan2(l, o),
              h = Math.sin((1 - e) * c) / l,
              u = Math.sin(e * c) / l;
            return (
              (this._w = s * h + this._w * u),
              (this._x = n * h + this._x * u),
              (this._y = r * h + this._y * u),
              (this._z = i * h + this._z * u),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() { }
        }
        (exports.Quaternion = gr), (gr.prototype.isQuaternion = !0);
        class xr {
          constructor(t = 0, e = 0, n = 0) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return (
              void 0 === n && (n = this.z),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              this
            );
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
              ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
              ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
              ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          }
          applyEuler(t) {
            return (
              (t && t.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
              ),
              this.applyQuaternion(yr.setFromEuler(t))
            );
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(yr.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              r = this.z,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6] * r),
              (this.y = i[1] * e + i[4] * n + i[7] * r),
              (this.z = i[2] * e + i[5] * n + i[8] * r),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              r = this.z,
              i = t.elements,
              s = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
            return (
              (this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * s),
              (this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * s),
              (this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * s),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              r = this.z,
              i = t.x,
              s = t.y,
              o = t.z,
              a = t.w,
              l = a * e + s * r - o * n,
              c = a * n + o * e - i * r,
              h = a * r + i * n - s * e,
              u = -i * e - s * n - o * r;
            return (
              (this.x = l * a + u * -i + c * -o - h * -s),
              (this.y = c * a + u * -s + h * -i - l * -o),
              (this.z = h * a + u * -o + l * -s - c * -i),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
              t.projectionMatrix
            );
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
              t.matrixWorld
            );
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              r = this.z,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[4] * n + i[8] * r),
              (this.y = i[1] * e + i[5] * n + i[9] * r),
              (this.z = i[2] * e + i[6] * n + i[10] * r),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
              ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              r = t.y,
              i = t.z,
              s = e.x,
              o = e.y,
              a = e.z;
            return (
              (this.x = r * a - i * o),
              (this.y = i * s - n * a),
              (this.z = n * o - r * s),
              this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return vr.copy(this).projectOnVector(t), this.sub(vr);
          }
          reflect(t) {
            return this.sub(vr.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(On(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              r = this.z - t.z;
            return e * e + n * n + r * r;
          }
          manhattanDistanceTo(t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const r = Math.sin(e) * t;
            return (
              (this.x = r * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = r * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (
              (this.x = t * Math.sin(e)),
              (this.y = n),
              (this.z = t * Math.cos(e)),
              this
            );
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              r = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = r), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
              console.warn(
                "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
              ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
        }
        (exports.Vector3 = xr), (xr.prototype.isVector3 = !0);
        const vr = new xr(),
          yr = new gr();
        class _r {
          constructor(
            t = new xr(1 / 0, 1 / 0, 1 / 0),
            e = new xr(-1 / 0, -1 / 0, -1 / 0)
          ) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            let e = 1 / 0,
              n = 1 / 0,
              r = 1 / 0,
              i = -1 / 0,
              s = -1 / 0,
              o = -1 / 0;
            for (let a = 0, l = t.length; a < l; a += 3) {
              const l = t[a],
                c = t[a + 1],
                h = t[a + 2];
              l < e && (e = l),
                c < n && (n = c),
                h < r && (r = h),
                l > i && (i = l),
                c > s && (s = c),
                h > o && (o = h);
            }
            return this.min.set(e, n, r), this.max.set(i, s, o), this;
          }
          setFromBufferAttribute(t) {
            let e = 1 / 0,
              n = 1 / 0,
              r = 1 / 0,
              i = -1 / 0,
              s = -1 / 0,
              o = -1 / 0;
            for (let a = 0, l = t.count; a < l; a++) {
              const l = t.getX(a),
                c = t.getY(a),
                h = t.getZ(a);
              l < e && (e = l),
                c < n && (n = c),
                h < r && (r = h),
                l > i && (i = l),
                c > s && (s = c),
                h > o && (o = h);
            }
            return this.min.set(e, n, r), this.max.set(i, s, o), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = wr.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t) {
            return this.makeEmpty(), this.expandByObject(t);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Box3: .getCenter() target is now required"
              ),
                (t = new xr())),
              this.isEmpty()
                ? t.set(0, 0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
              (console.warn("THREE.Box3: .getSize() target is now required"),
                (t = new xr())),
              this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e &&
              (null === e.boundingBox && e.computeBoundingBox(),
                br.copy(e.boundingBox),
                br.applyMatrix4(t.matrixWorld),
                this.union(br));
            const n = t.children;
            for (let r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Box3: .getParameter() target is now required"
              ),
                (e = new xr())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
                (t.z - this.min.z) / (this.max.z - this.min.z)
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, wr),
              wr.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(Cr),
              Pr.subVectors(this.max, Cr),
              Sr.subVectors(t.a, Cr),
              Tr.subVectors(t.b, Cr),
              Er.subVectors(t.c, Cr),
              Ar.subVectors(Tr, Sr),
              Lr.subVectors(Er, Tr),
              Rr.subVectors(Sr, Er);
            let e = [
              0,
              -Ar.z,
              Ar.y,
              0,
              -Lr.z,
              Lr.y,
              0,
              -Rr.z,
              Rr.y,
              Ar.z,
              0,
              -Ar.x,
              Lr.z,
              0,
              -Lr.x,
              Rr.z,
              0,
              -Rr.x,
              -Ar.y,
              Ar.x,
              0,
              -Lr.y,
              Lr.x,
              0,
              -Rr.y,
              Rr.x,
              0,
            ];
            return (
              !!Br(e, Sr, Tr, Er, Pr) &&
              !!Br((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Sr, Tr, Er, Pr) &&
              (Dr.crossVectors(Ar, Lr),
                Br((e = [Dr.x, Dr.y, Dr.z]), Sr, Tr, Er, Pr))
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Box3: .clampPoint() target is now required"
              ),
                (e = new xr())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return wr.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          getBoundingSphere(t) {
            return (
              void 0 === t &&
              console.error(
                "THREE.Box3: .getBoundingSphere() target is now required"
              ),
              this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(wr).length()),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return this.isEmpty()
              ? this
              : (Mr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                Mr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                Mr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                Mr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                Mr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                Mr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                Mr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                Mr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(Mr),
                this);
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        (exports.Box3 = _r), (_r.prototype.isBox3 = !0);
        const Mr = [
          new xr(),
          new xr(),
          new xr(),
          new xr(),
          new xr(),
          new xr(),
          new xr(),
          new xr(),
        ],
          wr = new xr(),
          br = new _r(),
          Sr = new xr(),
          Tr = new xr(),
          Er = new xr(),
          Ar = new xr(),
          Lr = new xr(),
          Rr = new xr(),
          Cr = new xr(),
          Pr = new xr(),
          Dr = new xr(),
          Ir = new xr();
        function Br(t, e, n, r, i) {
          for (let s = 0, o = t.length - 3; s <= o; s += 3) {
            Ir.fromArray(t, s);
            const o =
              i.x * Math.abs(Ir.x) +
              i.y * Math.abs(Ir.y) +
              i.z * Math.abs(Ir.z),
              a = e.dot(Ir),
              l = n.dot(Ir),
              c = r.dot(Ir);
            if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
          }
          return !0;
        }
        const Fr = new _r(),
          Nr = new xr(),
          Gr = new xr(),
          zr = new xr();
        class Or {
          constructor(t = new xr(), e = -1) {
            (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : Fr.setFromPoints(t).getCenter(n);
            let r = 0;
            for (let i = 0, s = t.length; i < s; i++)
              r = Math.max(r, n.distanceToSquared(t[i]));
            return (this.radius = Math.sqrt(r)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Sphere: .clampPoint() target is now required"
              ),
                (e = new xr())),
              e.copy(t),
              n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Sphere: .getBoundingBox() target is now required"
              ),
                (t = new _r())),
              this.isEmpty()
                ? (t.makeEmpty(), t)
                : (t.set(this.center, this.center),
                  t.expandByScalar(this.radius),
                  t)
            );
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            zr.subVectors(t, this.center);
            const e = zr.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.add(zr.multiplyScalar(n / t)), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return (
              Gr.subVectors(t.center, this.center)
                .normalize()
                .multiplyScalar(t.radius),
              this.expandByPoint(Nr.copy(t.center).add(Gr)),
              this.expandByPoint(Nr.copy(t.center).sub(Gr)),
              this
            );
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        exports.Sphere = Or;
        const Hr = new xr(),
          Ur = new xr(),
          kr = new xr(),
          Vr = new xr(),
          Wr = new xr(),
          jr = new xr(),
          qr = new xr();
        class Xr {
          constructor(t = new xr(), e = new xr(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          }
          at(t, e) {
            return (
              void 0 === e &&
              (console.warn("THREE.Ray: .at() target is now required"),
                (e = new xr())),
              e.copy(this.direction).multiplyScalar(t).add(this.origin)
            );
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, Hr)), this;
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Ray: .closestPointToPoint() target is now required"
              ),
                (e = new xr())),
              e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.direction).multiplyScalar(n).add(this.origin);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = Hr.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (Hr.copy(this.direction).multiplyScalar(e).add(this.origin),
                Hr.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, r) {
            Ur.copy(t).add(e).multiplyScalar(0.5),
              kr.copy(e).sub(t).normalize(),
              Vr.copy(this.origin).sub(Ur);
            const i = 0.5 * t.distanceTo(e),
              s = -this.direction.dot(kr),
              o = Vr.dot(this.direction),
              a = -Vr.dot(kr),
              l = Vr.lengthSq(),
              c = Math.abs(1 - s * s);
            let h, u, p, d;
            if (c > 0)
              if (((u = s * o - a), (d = i * c), (h = s * a - o) >= 0))
                if (u >= -d)
                  if (u <= d) {
                    const t = 1 / c;
                    p =
                      (h *= t) * (h + s * (u *= t) + 2 * o) +
                      u * (s * h + u + 2 * a) +
                      l;
                  } else
                    (u = i),
                      (p =
                        -(h = Math.max(0, -(s * u + o))) * h +
                        u * (u + 2 * a) +
                        l);
                else
                  (u = -i),
                    (p =
                      -(h = Math.max(0, -(s * u + o))) * h +
                      u * (u + 2 * a) +
                      l);
              else
                u <= -d
                  ? (p =
                    -(h = Math.max(0, -(-s * i + o))) * h +
                    (u = h > 0 ? -i : Math.min(Math.max(-i, -a), i)) *
                    (u + 2 * a) +
                    l)
                  : u <= d
                    ? ((h = 0),
                      (p = (u = Math.min(Math.max(-i, -a), i)) * (u + 2 * a) + l))
                    : (p =
                      -(h = Math.max(0, -(s * i + o))) * h +
                      (u = h > 0 ? i : Math.min(Math.max(-i, -a), i)) *
                      (u + 2 * a) +
                      l);
            else
              (u = s > 0 ? -i : i),
                (p =
                  -(h = Math.max(0, -(s * u + o))) * h + u * (u + 2 * a) + l);
            return (
              n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
              r && r.copy(kr).multiplyScalar(u).add(Ur),
              p
            );
          }
          intersectSphere(t, e) {
            Hr.subVectors(t.center, this.origin);
            const n = Hr.dot(this.direction),
              r = Hr.dot(Hr) - n * n,
              i = t.radius * t.radius;
            if (r > i) return null;
            const s = Math.sqrt(i - r),
              o = n - s,
              a = n + s;
            return o < 0 && a < 0
              ? null
              : o < 0
                ? this.at(a, e)
                : this.at(o, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            return 0 === e || t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, r, i, s, o, a;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - u.x) * l), (r = (t.max.x - u.x) * l))
                : ((n = (t.max.x - u.x) * l), (r = (t.min.x - u.x) * l)),
              c >= 0
                ? ((i = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                : ((i = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
              n > s || i > r
                ? null
                : ((i > n || n != n) && (n = i),
                  (s < r || r != r) && (r = s),
                  h >= 0
                    ? ((o = (t.min.z - u.z) * h), (a = (t.max.z - u.z) * h))
                    : ((o = (t.max.z - u.z) * h), (a = (t.min.z - u.z) * h)),
                  n > a || o > r
                    ? null
                    : ((o > n || n != n) && (n = o),
                      (a < r || r != r) && (r = a),
                      r < 0 ? null : this.at(n >= 0 ? n : r, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, Hr);
          }
          intersectTriangle(t, e, n, r, i) {
            Wr.subVectors(e, t), jr.subVectors(n, t), qr.crossVectors(Wr, jr);
            let s,
              o = this.direction.dot(qr);
            if (o > 0) {
              if (r) return null;
              s = 1;
            } else {
              if (!(o < 0)) return null;
              (s = -1), (o = -o);
            }
            Vr.subVectors(this.origin, t);
            const a = s * this.direction.dot(jr.crossVectors(Vr, jr));
            if (a < 0) return null;
            const l = s * this.direction.dot(Wr.cross(Vr));
            if (l < 0) return null;
            if (a + l > o) return null;
            const c = -s * Vr.dot(qr);
            return c < 0 ? null : this.at(c / o, i);
          }
          applyMatrix4(t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          }
          equals(t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        exports.Ray = Xr;
        class Yr {
          constructor() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              arguments.length > 0 &&
              console.error(
                "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
              );
          }
          set(t, e, n, r, i, s, o, a, l, c, h, u, p, d, m, f) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = r),
              (g[1] = i),
              (g[5] = s),
              (g[9] = o),
              (g[13] = a),
              (g[2] = l),
              (g[6] = c),
              (g[10] = h),
              (g[14] = u),
              (g[3] = p),
              (g[7] = d),
              (g[11] = m),
              (g[15] = f),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new Yr().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(
                e[0],
                e[3],
                e[6],
                0,
                e[1],
                e[4],
                e[7],
                0,
                e[2],
                e[5],
                e[8],
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              r = 1 / Zr.setFromMatrixColumn(t, 0).length(),
              i = 1 / Zr.setFromMatrixColumn(t, 1).length(),
              s = 1 / Zr.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * r),
              (e[1] = n[1] * r),
              (e[2] = n[2] * r),
              (e[3] = 0),
              (e[4] = n[4] * i),
              (e[5] = n[5] * i),
              (e[6] = n[6] * i),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            (t && t.isEuler) ||
              console.error(
                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
              );
            const e = this.elements,
              n = t.x,
              r = t.y,
              i = t.z,
              s = Math.cos(n),
              o = Math.sin(n),
              a = Math.cos(r),
              l = Math.sin(r),
              c = Math.cos(i),
              h = Math.sin(i);
            if ("XYZ" === t.order) {
              const t = s * c,
                n = s * h,
                r = o * c,
                i = o * h;
              (e[0] = a * c),
                (e[4] = -a * h),
                (e[8] = l),
                (e[1] = n + r * l),
                (e[5] = t - i * l),
                (e[9] = -o * a),
                (e[2] = i - t * l),
                (e[6] = r + n * l),
                (e[10] = s * a);
            } else if ("YXZ" === t.order) {
              const t = a * c,
                n = a * h,
                r = l * c,
                i = l * h;
              (e[0] = t + i * o),
                (e[4] = r * o - n),
                (e[8] = s * l),
                (e[1] = s * h),
                (e[5] = s * c),
                (e[9] = -o),
                (e[2] = n * o - r),
                (e[6] = i + t * o),
                (e[10] = s * a);
            } else if ("ZXY" === t.order) {
              const t = a * c,
                n = a * h,
                r = l * c,
                i = l * h;
              (e[0] = t - i * o),
                (e[4] = -s * h),
                (e[8] = r + n * o),
                (e[1] = n + r * o),
                (e[5] = s * c),
                (e[9] = i - t * o),
                (e[2] = -s * l),
                (e[6] = o),
                (e[10] = s * a);
            } else if ("ZYX" === t.order) {
              const t = s * c,
                n = s * h,
                r = o * c,
                i = o * h;
              (e[0] = a * c),
                (e[4] = r * l - n),
                (e[8] = t * l + i),
                (e[1] = a * h),
                (e[5] = i * l + t),
                (e[9] = n * l - r),
                (e[2] = -l),
                (e[6] = o * a),
                (e[10] = s * a);
            } else if ("YZX" === t.order) {
              const t = s * a,
                n = s * l,
                r = o * a,
                i = o * l;
              (e[0] = a * c),
                (e[4] = i - t * h),
                (e[8] = r * h + n),
                (e[1] = h),
                (e[5] = s * c),
                (e[9] = -o * c),
                (e[2] = -l * c),
                (e[6] = n * h + r),
                (e[10] = t - i * h);
            } else if ("XZY" === t.order) {
              const t = s * a,
                n = s * l,
                r = o * a,
                i = o * l;
              (e[0] = a * c),
                (e[4] = -h),
                (e[8] = l * c),
                (e[1] = t * h + i),
                (e[5] = s * c),
                (e[9] = n * h - r),
                (e[2] = r * h - n),
                (e[6] = o * c),
                (e[10] = i * h + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(Qr, t, Kr);
          }
          lookAt(t, e, n) {
            const r = this.elements;
            return (
              ei.subVectors(t, e),
              0 === ei.lengthSq() && (ei.z = 1),
              ei.normalize(),
              $r.crossVectors(n, ei),
              0 === $r.lengthSq() &&
              (1 === Math.abs(n.z) ? (ei.x += 1e-4) : (ei.z += 1e-4),
                ei.normalize(),
                $r.crossVectors(n, ei)),
              $r.normalize(),
              ti.crossVectors(ei, $r),
              (r[0] = $r.x),
              (r[4] = ti.x),
              (r[8] = ei.x),
              (r[1] = $r.y),
              (r[5] = ti.y),
              (r[9] = ei.y),
              (r[2] = $r.z),
              (r[6] = ti.z),
              (r[10] = ei.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
              ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              r = e.elements,
              i = this.elements,
              s = n[0],
              o = n[4],
              a = n[8],
              l = n[12],
              c = n[1],
              h = n[5],
              u = n[9],
              p = n[13],
              d = n[2],
              m = n[6],
              f = n[10],
              g = n[14],
              x = n[3],
              v = n[7],
              y = n[11],
              _ = n[15],
              M = r[0],
              w = r[4],
              b = r[8],
              S = r[12],
              T = r[1],
              E = r[5],
              A = r[9],
              L = r[13],
              R = r[2],
              C = r[6],
              P = r[10],
              D = r[14],
              I = r[3],
              B = r[7],
              F = r[11],
              N = r[15];
            return (
              (i[0] = s * M + o * T + a * R + l * I),
              (i[4] = s * w + o * E + a * C + l * B),
              (i[8] = s * b + o * A + a * P + l * F),
              (i[12] = s * S + o * L + a * D + l * N),
              (i[1] = c * M + h * T + u * R + p * I),
              (i[5] = c * w + h * E + u * C + p * B),
              (i[9] = c * b + h * A + u * P + p * F),
              (i[13] = c * S + h * L + u * D + p * N),
              (i[2] = d * M + m * T + f * R + g * I),
              (i[6] = d * w + m * E + f * C + g * B),
              (i[10] = d * b + m * A + f * P + g * F),
              (i[14] = d * S + m * L + f * D + g * N),
              (i[3] = x * M + v * T + y * R + _ * I),
              (i[7] = x * w + v * E + y * C + _ * B),
              (i[11] = x * b + v * A + y * P + _ * F),
              (i[15] = x * S + v * L + y * D + _ * N),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              r = t[8],
              i = t[12],
              s = t[1],
              o = t[5],
              a = t[9],
              l = t[13],
              c = t[2],
              h = t[6],
              u = t[10],
              p = t[14];
            return (
              t[3] *
              (+i * a * h -
                r * l * h -
                i * o * u +
                n * l * u +
                r * o * p -
                n * a * p) +
              t[7] *
              (+e * a * p -
                e * l * u +
                i * s * u -
                r * s * p +
                r * l * c -
                i * a * c) +
              t[11] *
              (+e * l * h -
                e * o * p -
                i * s * h +
                n * s * p +
                i * o * c -
                n * l * c) +
              t[15] *
              (-r * o * c -
                e * a * h +
                e * o * u +
                r * s * h -
                n * s * u +
                n * a * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const r = this.elements;
            return (
              t.isVector3
                ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
                : ((r[12] = t), (r[13] = e), (r[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              r = t[2],
              i = t[3],
              s = t[4],
              o = t[5],
              a = t[6],
              l = t[7],
              c = t[8],
              h = t[9],
              u = t[10],
              p = t[11],
              d = t[12],
              m = t[13],
              f = t[14],
              g = t[15],
              x =
                h * f * l -
                m * u * l +
                m * a * p -
                o * f * p -
                h * a * g +
                o * u * g,
              v =
                d * u * l -
                c * f * l -
                d * a * p +
                s * f * p +
                c * a * g -
                s * u * g,
              y =
                c * m * l -
                d * h * l +
                d * o * p -
                s * m * p -
                c * o * g +
                s * h * g,
              _ =
                d * h * a -
                c * m * a -
                d * o * u +
                s * m * u +
                c * o * f -
                s * h * f,
              M = e * x + n * v + r * y + i * _;
            if (0 === M)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / M;
            return (
              (t[0] = x * w),
              (t[1] =
                (m * u * i -
                  h * f * i -
                  m * r * p +
                  n * f * p +
                  h * r * g -
                  n * u * g) *
                w),
              (t[2] =
                (o * f * i -
                  m * a * i +
                  m * r * l -
                  n * f * l -
                  o * r * g +
                  n * a * g) *
                w),
              (t[3] =
                (h * a * i -
                  o * u * i -
                  h * r * l +
                  n * u * l +
                  o * r * p -
                  n * a * p) *
                w),
              (t[4] = v * w),
              (t[5] =
                (c * f * i -
                  d * u * i +
                  d * r * p -
                  e * f * p -
                  c * r * g +
                  e * u * g) *
                w),
              (t[6] =
                (d * a * i -
                  s * f * i -
                  d * r * l +
                  e * f * l +
                  s * r * g -
                  e * a * g) *
                w),
              (t[7] =
                (s * u * i -
                  c * a * i +
                  c * r * l -
                  e * u * l -
                  s * r * p +
                  e * a * p) *
                w),
              (t[8] = y * w),
              (t[9] =
                (d * h * i -
                  c * m * i -
                  d * n * p +
                  e * m * p +
                  c * n * g -
                  e * h * g) *
                w),
              (t[10] =
                (s * m * i -
                  d * o * i +
                  d * n * l -
                  e * m * l -
                  s * n * g +
                  e * o * g) *
                w),
              (t[11] =
                (c * o * i -
                  s * h * i -
                  c * n * l +
                  e * h * l +
                  s * n * p -
                  e * o * p) *
                w),
              (t[12] = _ * w),
              (t[13] =
                (c * m * r -
                  d * h * r +
                  d * n * u -
                  e * m * u -
                  c * n * f +
                  e * h * f) *
                w),
              (t[14] =
                (d * o * r -
                  s * m * r -
                  d * n * a +
                  e * m * a +
                  s * n * f -
                  e * o * f) *
                w),
              (t[15] =
                (s * h * r -
                  c * o * r +
                  c * n * a -
                  e * h * a -
                  s * n * u +
                  e * o * u) *
                w),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              r = t.y,
              i = t.z;
            return (
              (e[0] *= n),
              (e[4] *= r),
              (e[8] *= i),
              (e[1] *= n),
              (e[5] *= r),
              (e[9] *= i),
              (e[2] *= n),
              (e[6] *= r),
              (e[10] *= i),
              (e[3] *= n),
              (e[7] *= r),
              (e[11] *= i),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, r));
          }
          makeTranslation(t, e, n) {
            return (
              this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              r = Math.sin(e),
              i = 1 - n,
              s = t.x,
              o = t.y,
              a = t.z,
              l = i * s,
              c = i * o;
            return (
              this.set(
                l * s + n,
                l * o - r * a,
                l * a + r * o,
                0,
                l * o + r * a,
                c * o + n,
                c * a - r * s,
                0,
                l * a - r * o,
                c * a + r * s,
                i * a * a + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(t, e, n, r, i, s) {
            return (
              this.set(1, n, i, 0, t, 1, s, 0, e, r, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(t, e, n) {
            const r = this.elements,
              i = e._x,
              s = e._y,
              o = e._z,
              a = e._w,
              l = i + i,
              c = s + s,
              h = o + o,
              u = i * l,
              p = i * c,
              d = i * h,
              m = s * c,
              f = s * h,
              g = o * h,
              x = a * l,
              v = a * c,
              y = a * h,
              _ = n.x,
              M = n.y,
              w = n.z;
            return (
              (r[0] = (1 - (m + g)) * _),
              (r[1] = (p + y) * _),
              (r[2] = (d - v) * _),
              (r[3] = 0),
              (r[4] = (p - y) * M),
              (r[5] = (1 - (u + g)) * M),
              (r[6] = (f + x) * M),
              (r[7] = 0),
              (r[8] = (d + v) * w),
              (r[9] = (f - x) * w),
              (r[10] = (1 - (u + m)) * w),
              (r[11] = 0),
              (r[12] = t.x),
              (r[13] = t.y),
              (r[14] = t.z),
              (r[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const r = this.elements;
            let i = Zr.set(r[0], r[1], r[2]).length();
            const s = Zr.set(r[4], r[5], r[6]).length(),
              o = Zr.set(r[8], r[9], r[10]).length();
            this.determinant() < 0 && (i = -i),
              (t.x = r[12]),
              (t.y = r[13]),
              (t.z = r[14]),
              Jr.copy(this);
            const a = 1 / i,
              l = 1 / s,
              c = 1 / o;
            return (
              (Jr.elements[0] *= a),
              (Jr.elements[1] *= a),
              (Jr.elements[2] *= a),
              (Jr.elements[4] *= l),
              (Jr.elements[5] *= l),
              (Jr.elements[6] *= l),
              (Jr.elements[8] *= c),
              (Jr.elements[9] *= c),
              (Jr.elements[10] *= c),
              e.setFromRotationMatrix(Jr),
              (n.x = i),
              (n.y = s),
              (n.z = o),
              this
            );
          }
          makePerspective(t, e, n, r, i, s) {
            void 0 === s &&
              console.warn(
                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
              );
            const o = this.elements,
              a = (2 * i) / (e - t),
              l = (2 * i) / (n - r),
              c = (e + t) / (e - t),
              h = (n + r) / (n - r),
              u = -(s + i) / (s - i),
              p = (-2 * s * i) / (s - i);
            return (
              (o[0] = a),
              (o[4] = 0),
              (o[8] = c),
              (o[12] = 0),
              (o[1] = 0),
              (o[5] = l),
              (o[9] = h),
              (o[13] = 0),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = u),
              (o[14] = p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = -1),
              (o[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, r, i, s) {
            const o = this.elements,
              a = 1 / (e - t),
              l = 1 / (n - r),
              c = 1 / (s - i),
              h = (e + t) * a,
              u = (n + r) * l,
              p = (s + i) * c;
            return (
              (o[0] = 2 * a),
              (o[4] = 0),
              (o[8] = 0),
              (o[12] = -h),
              (o[1] = 0),
              (o[5] = 2 * l),
              (o[9] = 0),
              (o[13] = -u),
              (o[2] = 0),
              (o[6] = 0),
              (o[10] = -2 * c),
              (o[14] = -p),
              (o[3] = 0),
              (o[7] = 0),
              (o[11] = 0),
              (o[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let r = 0; r < 16; r++) if (e[r] !== n[r]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        (exports.Matrix4 = Yr), (Yr.prototype.isMatrix4 = !0);
        const Zr = new xr(),
          Jr = new Yr(),
          Qr = new xr(0, 0, 0),
          Kr = new xr(1, 1, 1),
          $r = new xr(),
          ti = new xr(),
          ei = new xr(),
          ni = new Yr(),
          ri = new gr();
        class ii {
          constructor(t = 0, e = 0, n = 0, r = ii.DefaultOrder) {
            (this._x = t), (this._y = e), (this._z = n), (this._order = r);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, r) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = r || this._order),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e, n) {
            const r = t.elements,
              i = r[0],
              s = r[4],
              o = r[8],
              a = r[1],
              l = r[5],
              c = r[9],
              h = r[2],
              u = r[6],
              p = r[10];
            switch ((e = e || this._order)) {
              case "XYZ":
                (this._y = Math.asin(On(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-c, p)),
                      (this._z = Math.atan2(-s, i)))
                    : ((this._x = Math.atan2(u, l)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-On(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._y = Math.atan2(o, p)),
                      (this._z = Math.atan2(a, l)))
                    : ((this._y = Math.atan2(-h, i)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(On(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(-h, p)),
                      (this._z = Math.atan2(-s, l)))
                    : ((this._y = 0), (this._z = Math.atan2(a, i)));
                break;
              case "ZYX":
                (this._y = Math.asin(-On(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(u, p)),
                      (this._z = Math.atan2(a, i)))
                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                break;
              case "YZX":
                (this._z = Math.asin(On(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-c, l)),
                      (this._y = Math.atan2(-h, i)))
                    : ((this._x = 0), (this._y = Math.atan2(o, p)));
                break;
              case "XZY":
                (this._z = Math.asin(-On(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(u, l)),
                      (this._y = Math.atan2(o, i)))
                    : ((this._x = Math.atan2(-c, p)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
                );
            }
            return (
              (this._order = e), !1 !== n && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, e, n) {
            return (
              ni.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(ni, e, n)
            );
          }
          setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order);
          }
          reorder(t) {
            return ri.setFromEuler(this), this.setFromQuaternion(ri, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          toVector3(t) {
            return t
              ? t.set(this._x, this._y, this._z)
              : new xr(this._x, this._y, this._z);
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() { }
        }
        (exports.Euler = ii),
          (ii.prototype.isEuler = !0),
          (ii.DefaultOrder = "XYZ"),
          (ii.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
        class si {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = (1 << t) | 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
        }
        exports.Layers = si;
        let oi = 0;
        const ai = new xr(),
          li = new gr(),
          ci = new Yr(),
          hi = new xr(),
          ui = new xr(),
          pi = new xr(),
          di = new gr(),
          mi = new xr(1, 0, 0),
          fi = new xr(0, 1, 0),
          gi = new xr(0, 0, 1),
          xi = { type: "added" },
          vi = { type: "removed" };
        class yi extends In {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: oi++ }),
              (this.uuid = zn()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = yi.DefaultUp.clone());
            const t = new xr(),
              e = new ii(),
              n = new gr(),
              r = new xr(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: e },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: r },
                modelViewMatrix: { value: new Yr() },
                normalMatrix: { value: new or() },
              }),
              (this.matrix = new Yr()),
              (this.matrixWorld = new Yr()),
              (this.matrixAutoUpdate = yi.DefaultMatrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = !1),
              (this.layers = new si()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() { }
          onAfterRender() { }
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return (
              li.setFromAxisAngle(t, e), this.quaternion.multiply(li), this
            );
          }
          rotateOnWorldAxis(t, e) {
            return (
              li.setFromAxisAngle(t, e), this.quaternion.premultiply(li), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(mi, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(fi, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(gi, t);
          }
          translateOnAxis(t, e) {
            return (
              ai.copy(t).applyQuaternion(this.quaternion),
              this.position.add(ai.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(mi, t);
          }
          translateY(t) {
            return this.translateOnAxis(fi, t);
          }
          translateZ(t) {
            return this.translateOnAxis(gi, t);
          }
          localToWorld(t) {
            return t.applyMatrix4(this.matrixWorld);
          }
          worldToLocal(t) {
            return t.applyMatrix4(ci.copy(this.matrixWorld).invert());
          }
          lookAt(t, e, n) {
            t.isVector3 ? hi.copy(t) : hi.set(t, e, n);
            const r = this.parent;
            this.updateWorldMatrix(!0, !1),
              ui.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? ci.lookAt(ui, hi, this.up)
                : ci.lookAt(hi, ui, this.up),
              this.quaternion.setFromRotationMatrix(ci),
              r &&
              (ci.extractRotation(r.matrixWorld),
                li.setFromRotationMatrix(ci),
                this.quaternion.premultiply(li.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
                this)
              : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(xi))
                : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  t
                ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++)
                this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e &&
              ((t.parent = null),
                this.children.splice(e, 1),
                t.dispatchEvent(vi)),
              this
            );
          }
          removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this;
          }
          clear() {
            for (let t = 0; t < this.children.length; t++) {
              const e = this.children[t];
              (e.parent = null), e.dispatchEvent(vi);
            }
            return (this.children.length = 0), this;
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              ci.copy(this.matrixWorld).invert(),
              null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
                ci.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(ci),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, r = this.children.length; n < r; n++) {
              const r = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== r) return r;
            }
          }
          getWorldPosition(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldPosition() target is now required"
              ),
                (t = new xr())),
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required"
              ),
                (t = new gr())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(ui, t, pi),
              t
            );
          }
          getWorldScale(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required"
              ),
                (t = new xr())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(ui, di, t),
              t
            );
          }
          getWorldDirection(t) {
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldDirection() target is now required"
              ),
                (t = new xr())),
              this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() { }
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t);
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
                !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++)
                t[e].updateWorldMatrix(!1, !0);
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
              }),
                (n.metadata = {
                  version: 4.5,
                  type: "Object",
                  generator: "Object3D.toJSON",
                }));
            const r = {};
            function i(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((r.uuid = this.uuid),
                (r.type = this.type),
                "" !== this.name && (r.name = this.name),
                !0 === this.castShadow && (r.castShadow = !0),
                !0 === this.receiveShadow && (r.receiveShadow = !0),
                !1 === this.visible && (r.visible = !1),
                !1 === this.frustumCulled && (r.frustumCulled = !1),
                0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
                "{}" !== JSON.stringify(this.userData) &&
                (r.userData = this.userData),
                (r.layers = this.layers.mask),
                (r.matrix = this.matrix.toArray()),
                !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
                this.isInstancedMesh &&
                ((r.type = "InstancedMesh"),
                  (r.count = this.count),
                  (r.instanceMatrix = this.instanceMatrix.toJSON()),
                  null !== this.instanceColor &&
                  (r.instanceColor = this.instanceColor.toJSON())),
                this.isMesh || this.isLine || this.isPoints)
            ) {
              r.geometry = i(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = n[e];
                    i(t.shapes, r);
                  }
                else i(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((r.bindMode = this.bindMode),
                  (r.bindMatrix = this.bindMatrix.toArray()),
                  void 0 !== this.skeleton &&
                  (i(t.skeletons, this.skeleton),
                    (r.skeleton = this.skeleton.uuid))),
                void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, r = this.material.length; n < r; n++)
                  e.push(i(t.materials, this.material[n]));
                r.material = e;
              } else r.material = i(t.materials, this.material);
            if (this.children.length > 0) {
              r.children = [];
              for (let e = 0; e < this.children.length; e++)
                r.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              r.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                r.animations.push(i(t.animations, n));
              }
            }
            if (e) {
              const e = s(t.geometries),
                r = s(t.materials),
                i = s(t.textures),
                o = s(t.images),
                a = s(t.shapes),
                l = s(t.skeletons),
                c = s(t.animations);
              e.length > 0 && (n.geometries = e),
                r.length > 0 && (n.materials = r),
                i.length > 0 && (n.textures = i),
                o.length > 0 && (n.images = o),
                a.length > 0 && (n.shapes = a),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c);
            }
            return (n.object = r), n;
            function s(t) {
              const e = [];
              for (const n in t) {
                const r = t[n];
                delete r.metadata, e.push(r);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
                this.up.copy(t.up),
                this.position.copy(t.position),
                (this.rotation.order = t.rotation.order),
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.matrix.copy(t.matrix),
                this.matrixWorld.copy(t.matrixWorld),
                (this.matrixAutoUpdate = t.matrixAutoUpdate),
                (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                (this.layers.mask = t.layers.mask),
                (this.visible = t.visible),
                (this.castShadow = t.castShadow),
                (this.receiveShadow = t.receiveShadow),
                (this.frustumCulled = t.frustumCulled),
                (this.renderOrder = t.renderOrder),
                (this.userData = JSON.parse(JSON.stringify(t.userData))),
                !0 === e)
            )
              for (let n = 0; n < t.children.length; n++) {
                const e = t.children[n];
                this.add(e.clone());
              }
            return this;
          }
        }
        (exports.Object3D = yi),
          (yi.DefaultUp = new xr(0, 1, 0)),
          (yi.DefaultMatrixAutoUpdate = !0),
          (yi.prototype.isObject3D = !0);
        const _i = new xr(),
          Mi = new xr(),
          wi = new or();
        class bi {
          constructor(t = new xr(1, 0, 0), e = 0) {
            (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, r) {
            return this.normal.set(t, e, n), (this.constant = r), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(t, e, n) {
            const r = _i
              .subVectors(n, e)
              .cross(Mi.subVectors(t, e))
              .normalize();
            return this.setFromNormalAndCoplanarPoint(r, t), this;
          }
          copy(t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Plane: .projectPoint() target is now required"
              ),
                (e = new xr())),
              e
                .copy(this.normal)
                .multiplyScalar(-this.distanceToPoint(t))
                .add(t)
            );
          }
          intersectLine(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Plane: .intersectLine() target is now required"
              ),
                (e = new xr()));
            const n = t.delta(_i),
              r = this.normal.dot(n);
            if (0 === r)
              return 0 === this.distanceToPoint(t.start)
                ? e.copy(t.start)
                : null;
            const i = -(t.start.dot(this.normal) + this.constant) / r;
            return i < 0 || i > 1
              ? null
              : e.copy(n).multiplyScalar(i).add(t.start);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Plane: .coplanarPoint() target is now required"
              ),
                (t = new xr())),
              t.copy(this.normal).multiplyScalar(-this.constant)
            );
          }
          applyMatrix4(t, e) {
            const n = e || wi.getNormalMatrix(t),
              r = this.coplanarPoint(_i).applyMatrix4(t),
              i = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -r.dot(i)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        (exports.Plane = bi), (bi.prototype.isPlane = !0);
        const Si = new xr(),
          Ti = new xr(),
          Ei = new xr(),
          Ai = new xr(),
          Li = new xr(),
          Ri = new xr(),
          Ci = new xr(),
          Pi = new xr(),
          Di = new xr(),
          Ii = new xr();
        class Bi {
          constructor(t = new xr(), e = new xr(), n = new xr()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, r) {
            void 0 === r &&
              (console.warn(
                "THREE.Triangle: .getNormal() target is now required"
              ),
                (r = new xr())),
              r.subVectors(n, e),
              Si.subVectors(t, e),
              r.cross(Si);
            const i = r.lengthSq();
            return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, r, i) {
            Si.subVectors(r, e), Ti.subVectors(n, e), Ei.subVectors(t, e);
            const s = Si.dot(Si),
              o = Si.dot(Ti),
              a = Si.dot(Ei),
              l = Ti.dot(Ti),
              c = Ti.dot(Ei),
              h = s * l - o * o;
            if (
              (void 0 === i &&
                (console.warn(
                  "THREE.Triangle: .getBarycoord() target is now required"
                ),
                  (i = new xr())),
                0 === h)
            )
              return i.set(-2, -1, -1);
            const u = 1 / h,
              p = (l * a - o * c) * u,
              d = (s * c - o * a) * u;
            return i.set(1 - p - d, d, p);
          }
          static containsPoint(t, e, n, r) {
            return (
              this.getBarycoord(t, e, n, r, Ai),
              Ai.x >= 0 && Ai.y >= 0 && Ai.x + Ai.y <= 1
            );
          }
          static getUV(t, e, n, r, i, s, o, a) {
            return (
              this.getBarycoord(t, e, n, r, Ai),
              a.set(0, 0),
              a.addScaledVector(i, Ai.x),
              a.addScaledVector(s, Ai.y),
              a.addScaledVector(o, Ai.z),
              a
            );
          }
          static isFrontFacing(t, e, n, r) {
            return (
              Si.subVectors(n, e), Ti.subVectors(t, e), Si.cross(Ti).dot(r) < 0
            );
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, r) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              Si.subVectors(this.c, this.b),
              Ti.subVectors(this.a, this.b),
              0.5 * Si.cross(Ti).length()
            );
          }
          getMidpoint(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getMidpoint() target is now required"
              ),
                (t = new xr())),
              t
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          }
          getNormal(t) {
            return Bi.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Triangle: .getPlane() target is now required"
              ),
                (t = new bi())),
              t.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          }
          getBarycoord(t, e) {
            return Bi.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, r, i) {
            return Bi.getUV(t, this.a, this.b, this.c, e, n, r, i);
          }
          containsPoint(t) {
            return Bi.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return Bi.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Triangle: .closestPointToPoint() target is now required"
              ),
                (e = new xr()));
            const n = this.a,
              r = this.b,
              i = this.c;
            let s, o;
            Li.subVectors(r, n), Ri.subVectors(i, n), Pi.subVectors(t, n);
            const a = Li.dot(Pi),
              l = Ri.dot(Pi);
            if (a <= 0 && l <= 0) return e.copy(n);
            Di.subVectors(t, r);
            const c = Li.dot(Di),
              h = Ri.dot(Di);
            if (c >= 0 && h <= c) return e.copy(r);
            const u = a * h - c * l;
            if (u <= 0 && a >= 0 && c <= 0)
              return (s = a / (a - c)), e.copy(n).addScaledVector(Li, s);
            Ii.subVectors(t, i);
            const p = Li.dot(Ii),
              d = Ri.dot(Ii);
            if (d >= 0 && p <= d) return e.copy(i);
            const m = p * l - a * d;
            if (m <= 0 && l >= 0 && d <= 0)
              return (o = l / (l - d)), e.copy(n).addScaledVector(Ri, o);
            const f = c * d - p * h;
            if (f <= 0 && h - c >= 0 && p - d >= 0)
              return (
                Ci.subVectors(i, r),
                (o = (h - c) / (h - c + (p - d))),
                e.copy(r).addScaledVector(Ci, o)
              );
            const g = 1 / (f + m + u);
            return (
              (s = m * g),
              (o = u * g),
              e.copy(n).addScaledVector(Li, s).addScaledVector(Ri, o)
            );
          }
          equals(t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          }
        }
        exports.Triangle = Bi;
        let Fi = 0;
        class Ni extends In {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: Fi++ }),
              (this.uuid = zn()),
              (this.name = ""),
              (this.type = "Material"),
              (this.fog = !0),
              (this.blending = x),
              (this.side = u),
              (this.vertexColors = !1),
              (this.opacity = 1),
              (this.transparent = !1),
              (this.blendSrc = P),
              (this.blendDst = D),
              (this.blendEquation = w),
              (this.blendSrcAlpha = null),
              (this.blendDstAlpha = null),
              (this.blendEquationAlpha = null),
              (this.depthFunc = U),
              (this.depthTest = !0),
              (this.depthWrite = !0),
              (this.stencilWriteMask = 255),
              (this.stencilFunc = Mn),
              (this.stencilRef = 0),
              (this.stencilFuncMask = 255),
              (this.stencilFail = an),
              (this.stencilZFail = an),
              (this.stencilZPass = an),
              (this.stencilWrite = !1),
              (this.clippingPlanes = null),
              (this.clipIntersection = !1),
              (this.clipShadows = !1),
              (this.shadowSide = null),
              (this.colorWrite = !0),
              (this.precision = null),
              (this.polygonOffset = !1),
              (this.polygonOffsetFactor = 0),
              (this.polygonOffsetUnits = 0),
              (this.dithering = !1),
              (this.alphaTest = 0),
              (this.alphaToCoverage = !1),
              (this.premultipliedAlpha = !1),
              (this.visible = !0),
              (this.toneMapped = !0),
              (this.userData = {}),
              (this.version = 0);
          }
          onBuild() { }
          onBeforeCompile() { }
          customProgramCacheKey() {
            return this.onBeforeCompile.toString();
          }
          setValues(t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(
                    "THREE.Material: '" + e + "' parameter is undefined."
                  );
                  continue;
                }
                if ("shading" === e) {
                  console.warn(
                    "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = n === m);
                  continue;
                }
                const r = this[e];
                void 0 !== r
                  ? r && r.isColor
                    ? r.set(n)
                    : r && r.isVector3 && n && n.isVector3
                      ? r.copy(n)
                      : (this[e] = n)
                  : console.warn(
                    "THREE." +
                    this.type +
                    ": '" +
                    e +
                    "' is not a property of this material."
                  );
              }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function r(t) {
              const e = [];
              for (const n in t) {
                const r = t[n];
                delete r.metadata, e.push(r);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
                (n.type = this.type),
                "" !== this.name && (n.name = this.name),
                this.color &&
                this.color.isColor &&
                (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                this.sheen &&
                this.sheen.isColor &&
                (n.sheen = this.sheen.getHex()),
                this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
                this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
                this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(t).uuid),
                this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(t).uuid),
                  (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
                this.map &&
                this.map.isTexture &&
                (n.map = this.map.toJSON(t).uuid),
                this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(t).uuid),
                this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                  (n.lightMapIntensity = this.lightMapIntensity)),
                this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                  (n.aoMapIntensity = this.aoMapIntensity)),
                this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                  (n.bumpScale = this.bumpScale)),
                this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                  (n.normalMapType = this.normalMapType),
                  (n.normalScale = this.normalScale.toArray())),
                this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                  (n.displacementScale = this.displacementScale),
                  (n.displacementBias = this.displacementBias)),
                this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
                this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                  void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity &&
                (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio &&
                (n.refractionRatio = this.refractionRatio),
                this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
                void 0 !== this.transmission &&
                (n.transmission = this.transmission),
                this.transmissionMap &&
                this.transmissionMap.isTexture &&
                (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap &&
                this.thicknessMap.isTexture &&
                (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                void 0 !== this.attenuationDistance &&
                (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor &&
                (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation &&
                (n.sizeAttenuation = this.sizeAttenuation),
                this.blending !== x && (n.blending = this.blending),
                this.side !== u && (n.side = this.side),
                this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = this.transparent),
                (n.depthFunc = this.depthFunc),
                (n.depthTest = this.depthTest),
                (n.depthWrite = this.depthWrite),
                (n.colorWrite = this.colorWrite),
                (n.stencilWrite = this.stencilWrite),
                (n.stencilWriteMask = this.stencilWriteMask),
                (n.stencilFunc = this.stencilFunc),
                (n.stencilRef = this.stencilRef),
                (n.stencilFuncMask = this.stencilFuncMask),
                (n.stencilFail = this.stencilFail),
                (n.stencilZFail = this.stencilZFail),
                (n.stencilZPass = this.stencilZPass),
                this.rotation &&
                0 !== this.rotation &&
                (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth &&
                1 !== this.linewidth &&
                (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaToCoverage &&
                (n.alphaToCoverage = this.alphaToCoverage),
                !0 === this.premultipliedAlpha &&
                (n.premultipliedAlpha = this.premultipliedAlpha),
                !0 === this.wireframe && (n.wireframe = this.wireframe),
                this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap &&
                (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.morphTargets && (n.morphTargets = !0),
                !0 === this.morphNormals && (n.morphNormals = !0),
                !0 === this.flatShading && (n.flatShading = this.flatShading),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                "{}" !== JSON.stringify(this.userData) &&
                (n.userData = this.userData),
                e)
            ) {
              const e = r(t.textures),
                i = r(t.images);
              e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i);
            }
            return n;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            (this.name = t.name),
              (this.fog = t.fog),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let r = 0; r !== t; ++r) n[r] = e[r].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        (exports.Material = Ni), (Ni.prototype.isMaterial = !0);
        const Gi = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
          zi = { h: 0, s: 0, l: 0 },
          Oi = { h: 0, s: 0, l: 0 };
        function Hi(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
                ? e
                : n < 2 / 3
                  ? t + 6 * (e - t) * (2 / 3 - n)
                  : t
          );
        }
        function Ui(t) {
          return t < 0.04045
            ? 0.0773993808 * t
            : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function ki(t) {
          return t < 0.0031308
            ? 12.92 * t
            : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        class Vi {
          constructor(t, e, n) {
            return void 0 === e && void 0 === n
              ? this.set(t)
              : this.setRGB(t, e, n);
          }
          set(t) {
            return (
              t && t.isColor
                ? this.copy(t)
                : "number" == typeof t
                  ? this.setHex(t)
                  : "string" == typeof t && this.setStyle(t),
              this
            );
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              this
            );
          }
          setRGB(t, e, n) {
            return (this.r = t), (this.g = e), (this.b = n), this;
          }
          setHSL(t, e, n) {
            if (((t = Hn(t, 1)), (e = On(e, 0, 1)), (n = On(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const r = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                i = 2 * n - r;
              (this.r = Hi(i, r, t + 1 / 3)),
                (this.g = Hi(i, r, t)),
                (this.b = Hi(i, r, t - 1 / 3));
            }
            return this;
          }
          setStyle(t) {
            function e(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn(
                  "THREE.Color: Alpha component of " + t + " will be ignored."
                );
            }
            let n;
            if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
              let t;
              const r = n[1],
                i = n[2];
              switch (r) {
                case "rgb":
                case "rgba":
                  if (
                    (t =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  )
                    return (
                      (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                      e(t[4]),
                      this
                    );
                  if (
                    (t =
                      /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  )
                    return (
                      (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                      e(t[4]),
                      this
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (t =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        i
                      ))
                  ) {
                    const n = parseFloat(t[1]) / 360,
                      r = parseInt(t[2], 10) / 100,
                      i = parseInt(t[3], 10) / 100;
                    return e(t[4]), this.setHSL(n, r, i);
                  }
              }
            } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const t = n[1],
                e = t.length;
              if (3 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                  (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                  (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                  this
                );
              if (6 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                  (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                  (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                  this
                );
            }
            return t && t.length > 0 ? this.setColorName(t) : this;
          }
          setColorName(t) {
            const e = Gi[t.toLowerCase()];
            return (
              void 0 !== e
                ? this.setHex(e)
                : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copyGammaToLinear(t, e = 2) {
            return (
              (this.r = Math.pow(t.r, e)),
              (this.g = Math.pow(t.g, e)),
              (this.b = Math.pow(t.b, e)),
              this
            );
          }
          copyLinearToGamma(t, e = 2) {
            const n = e > 0 ? 1 / e : 1;
            return (
              (this.r = Math.pow(t.r, n)),
              (this.g = Math.pow(t.g, n)),
              (this.b = Math.pow(t.b, n)),
              this
            );
          }
          convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t), this;
          }
          convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t), this;
          }
          copySRGBToLinear(t) {
            return (
              (this.r = Ui(t.r)), (this.g = Ui(t.g)), (this.b = Ui(t.b)), this
            );
          }
          copyLinearToSRGB(t) {
            return (
              (this.r = ki(t.r)), (this.g = ki(t.g)), (this.b = ki(t.b)), this
            );
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex() {
            return (
              ((255 * this.r) << 16) ^
              ((255 * this.g) << 8) ^
              ((255 * this.b) << 0)
            );
          }
          getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
          }
          getHSL(t) {
            void 0 === t &&
              (console.warn("THREE.Color: .getHSL() target is now required"),
                (t = { h: 0, s: 0, l: 0 }));
            const e = this.r,
              n = this.g,
              r = this.b,
              i = Math.max(e, n, r),
              s = Math.min(e, n, r);
            let o, a;
            const l = (s + i) / 2;
            if (s === i) (o = 0), (a = 0);
            else {
              const t = i - s;
              switch (((a = l <= 0.5 ? t / (i + s) : t / (2 - i - s)), i)) {
                case e:
                  o = (n - r) / t + (n < r ? 6 : 0);
                  break;
                case n:
                  o = (r - e) / t + 2;
                  break;
                case r:
                  o = (e - n) / t + 4;
              }
              o /= 6;
            }
            return (t.h = o), (t.s = a), (t.l = l), t;
          }
          getStyle() {
            return (
              "rgb(" +
              ((255 * this.r) | 0) +
              "," +
              ((255 * this.g) | 0) +
              "," +
              ((255 * this.b) | 0) +
              ")"
            );
          }
          offsetHSL(t, e, n) {
            return (
              this.getHSL(zi),
              (zi.h += t),
              (zi.s += e),
              (zi.l += n),
              this.setHSL(zi.h, zi.s, zi.l),
              this
            );
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (
              (this.r = t.r + e.r),
              (this.g = t.g + e.g),
              (this.b = t.b + e.b),
              this
            );
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(zi), t.getHSL(Oi);
            const n = Vn(zi.h, Oi.h, e),
              r = Vn(zi.s, Oi.s, e),
              i = Vn(zi.l, Oi.l, e);
            return this.setHSL(n, r, i), this;
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (
              (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              !0 === t.normalized &&
              ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
              this
            );
          }
          toJSON() {
            return this.getHex();
          }
        }
        (exports.Color = Vi),
          (Vi.NAMES = Gi),
          (Vi.prototype.isColor = !0),
          (Vi.prototype.r = 1),
          (Vi.prototype.g = 1),
          (Vi.prototype.b = 1);
        class Wi extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshBasicMaterial"),
              (this.color = new Vi(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = q),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        (exports.MeshBasicMaterial = Wi),
          (Wi.prototype.isMeshBasicMaterial = !0);
        const ji = new xr(),
          qi = new sr();
        class Xi {
          constructor(t, e, n) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = !0 === n),
              (this.usage = wn),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0);
          }
          onUploadCallback() { }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let r = 0, i = this.itemSize; r < i; r++)
              this.array[t + r] = e.array[n + r];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          copyColorsArray(t) {
            const e = this.array;
            let n = 0;
            for (let r = 0, i = t.length; r < i; r++) {
              let i = t[r];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  r
                ),
                  (i = new Vi())),
                (e[n++] = i.r),
                (e[n++] = i.g),
                (e[n++] = i.b);
            }
            return this;
          }
          copyVector2sArray(t) {
            const e = this.array;
            let n = 0;
            for (let r = 0, i = t.length; r < i; r++) {
              let i = t[r];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  r
                ),
                  (i = new sr())),
                (e[n++] = i.x),
                (e[n++] = i.y);
            }
            return this;
          }
          copyVector3sArray(t) {
            const e = this.array;
            let n = 0;
            for (let r = 0, i = t.length; r < i; r++) {
              let i = t[r];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  r
                ),
                  (i = new xr())),
                (e[n++] = i.x),
                (e[n++] = i.y),
                (e[n++] = i.z);
            }
            return this;
          }
          copyVector4sArray(t) {
            const e = this.array;
            let n = 0;
            for (let r = 0, i = t.length; r < i; r++) {
              let i = t[r];
              void 0 === i &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  r
                ),
                  (i = new pr())),
                (e[n++] = i.x),
                (e[n++] = i.y),
                (e[n++] = i.z),
                (e[n++] = i.w);
            }
            return this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                qi.fromBufferAttribute(this, e),
                  qi.applyMatrix3(t),
                  this.setXY(e, qi.x, qi.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                ji.fromBufferAttribute(this, e),
                  ji.applyMatrix3(t),
                  this.setXYZ(e, ji.x, ji.y, ji.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (ji.x = this.getX(e)),
                (ji.y = this.getY(e)),
                (ji.z = this.getZ(e)),
                ji.applyMatrix4(t),
                this.setXYZ(e, ji.x, ji.y, ji.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (ji.x = this.getX(e)),
                (ji.y = this.getY(e)),
                (ji.z = this.getZ(e)),
                ji.applyNormalMatrix(t),
                this.setXYZ(e, ji.x, ji.y, ji.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (ji.x = this.getX(e)),
                (ji.y = this.getY(e)),
                (ji.z = this.getZ(e)),
                ji.transformDirection(t),
                this.setXYZ(e, ji.x, ji.y, ji.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getX(t) {
            return this.array[t * this.itemSize];
          }
          setX(t, e) {
            return (this.array[t * this.itemSize] = e), this;
          }
          getY(t) {
            return this.array[t * this.itemSize + 1];
          }
          setY(t, e) {
            return (this.array[t * this.itemSize + 1] = e), this;
          }
          getZ(t) {
            return this.array[t * this.itemSize + 2];
          }
          setZ(t, e) {
            return (this.array[t * this.itemSize + 2] = e), this;
          }
          getW(t) {
            return this.array[t * this.itemSize + 3];
          }
          setW(t, e) {
            return (this.array[t * this.itemSize + 3] = e), this;
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, r) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = r),
              this
            );
          }
          setXYZW(t, e, n, r, i) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = r),
              (this.array[t + 3] = i),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== wn && (t.usage = this.usage),
              (0 === this.updateRange.offset &&
                -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
              t
            );
          }
        }
        (exports.BufferAttribute = Xi), (Xi.prototype.isBufferAttribute = !0);
        class Yi extends Xi {
          constructor(t, e, n) {
            super(new Int8Array(t), e, n);
          }
        }
        exports.Int8BufferAttribute = Yi;
        class Zi extends Xi {
          constructor(t, e, n) {
            super(new Uint8Array(t), e, n);
          }
        }
        exports.Uint8BufferAttribute = Zi;
        class Ji extends Xi {
          constructor(t, e, n) {
            super(new Uint8ClampedArray(t), e, n);
          }
        }
        exports.Uint8ClampedBufferAttribute = Ji;
        class Qi extends Xi {
          constructor(t, e, n) {
            super(new Int16Array(t), e, n);
          }
        }
        exports.Int16BufferAttribute = Qi;
        class Ki extends Xi {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        exports.Uint16BufferAttribute = Ki;
        class $i extends Xi {
          constructor(t, e, n) {
            super(new Int32Array(t), e, n);
          }
        }
        exports.Int32BufferAttribute = $i;
        class ts extends Xi {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        exports.Uint32BufferAttribute = ts;
        class es extends Xi {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        (exports.Float16BufferAttribute = es),
          (es.prototype.isFloat16BufferAttribute = !0);
        class ns extends Xi {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        exports.Float32BufferAttribute = ns;
        class rs extends Xi {
          constructor(t, e, n) {
            super(new Float64Array(t), e, n);
          }
        }
        function is(t) {
          if (0 === t.length) return -1 / 0;
          let e = t[0];
          for (let n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
          return e;
        }
        exports.Float64BufferAttribute = rs;
        const ss = {
          Int8Array: Int8Array,
          Uint8Array: Uint8Array,
          Uint8ClampedArray: Uint8ClampedArray,
          Int16Array: Int16Array,
          Uint16Array: Uint16Array,
          Int32Array: Int32Array,
          Uint32Array: Uint32Array,
          Float32Array: Float32Array,
          Float64Array: Float64Array,
        };
        function os(t, e) {
          return new ss[t](e);
        }
        let as = 0;
        const ls = new Yr(),
          cs = new yi(),
          hs = new xr(),
          us = new _r(),
          ps = new _r(),
          ds = new xr();
        class ms extends In {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: as++ }),
              (this.uuid = zn()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t)
                ? (this.index = new (is(t) > 65535 ? ts : Ki)(t, 1))
                : (this.index = t),
              this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new or().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const r = this.attributes.tangent;
            return (
              void 0 !== r && (r.transformDirection(t), (r.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          applyQuaternion(t) {
            return (
              ls.makeRotationFromQuaternion(t), this.applyMatrix4(ls), this
            );
          }
          rotateX(t) {
            return ls.makeRotationX(t), this.applyMatrix4(ls), this;
          }
          rotateY(t) {
            return ls.makeRotationY(t), this.applyMatrix4(ls), this;
          }
          rotateZ(t) {
            return ls.makeRotationZ(t), this.applyMatrix4(ls), this;
          }
          translate(t, e, n) {
            return ls.makeTranslation(t, e, n), this.applyMatrix4(ls), this;
          }
          scale(t, e, n) {
            return ls.makeScale(t, e, n), this.applyMatrix4(ls), this;
          }
          lookAt(t) {
            return (
              cs.lookAt(t),
              cs.updateMatrix(),
              this.applyMatrix4(cs.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(hs).negate(),
              this.translate(hs.x, hs.y, hs.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, r = t.length; n < r; n++) {
              const r = t[n];
              e.push(r.x, r.y, r.z || 0);
            }
            return this.setAttribute("position", new ns(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new _r());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new xr(-1 / 0, -1 / 0, -1 / 0),
                  new xr(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let n = 0, r = e.length; n < r; n++) {
                  const t = e[n];
                  us.setFromBufferAttribute(t),
                    this.morphTargetsRelative
                      ? (ds.addVectors(this.boundingBox.min, us.min),
                        this.boundingBox.expandByPoint(ds),
                        ds.addVectors(this.boundingBox.max, us.max),
                        this.boundingBox.expandByPoint(ds))
                      : (this.boundingBox.expandByPoint(us.min),
                        this.boundingBox.expandByPoint(us.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Or());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new xr(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((us.setFromBufferAttribute(t), e))
                for (let t = 0, i = e.length; t < i; t++) {
                  const n = e[t];
                  ps.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (ds.addVectors(us.min, ps.min),
                        us.expandByPoint(ds),
                        ds.addVectors(us.max, ps.max),
                        us.expandByPoint(ds))
                      : (us.expandByPoint(ps.min), us.expandByPoint(ps.max));
                }
              us.getCenter(n);
              let r = 0;
              for (let e = 0, i = t.count; e < i; e++)
                ds.fromBufferAttribute(t, e),
                  (r = Math.max(r, n.distanceToSquared(ds)));
              if (e)
                for (let i = 0, s = e.length; i < s; i++) {
                  const s = e[i],
                    o = this.morphTargetsRelative;
                  for (let e = 0, i = s.count; e < i; e++)
                    ds.fromBufferAttribute(s, e),
                      o && (hs.fromBufferAttribute(t, e), ds.add(hs)),
                      (r = Math.max(r, n.distanceToSquared(ds)));
                }
              (this.boundingSphere.radius = Math.sqrt(r)),
                isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
            }
          }
          computeFaceNormals() { }
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (
              null === t ||
              void 0 === e.position ||
              void 0 === e.normal ||
              void 0 === e.uv
            )
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              r = e.position.array,
              i = e.normal.array,
              s = e.uv.array,
              o = r.length / 3;
            void 0 === e.tangent &&
              this.setAttribute("tangent", new Xi(new Float32Array(4 * o), 4));
            const a = e.tangent.array,
              l = [],
              c = [];
            for (let T = 0; T < o; T++) (l[T] = new xr()), (c[T] = new xr());
            const h = new xr(),
              u = new xr(),
              p = new xr(),
              d = new sr(),
              m = new sr(),
              f = new sr(),
              g = new xr(),
              x = new xr();
            function v(t, e, n) {
              h.fromArray(r, 3 * t),
                u.fromArray(r, 3 * e),
                p.fromArray(r, 3 * n),
                d.fromArray(s, 2 * t),
                m.fromArray(s, 2 * e),
                f.fromArray(s, 2 * n),
                u.sub(h),
                p.sub(h),
                m.sub(d),
                f.sub(d);
              const i = 1 / (m.x * f.y - f.x * m.y);
              isFinite(i) &&
                (g
                  .copy(u)
                  .multiplyScalar(f.y)
                  .addScaledVector(p, -m.y)
                  .multiplyScalar(i),
                  x
                    .copy(p)
                    .multiplyScalar(m.x)
                    .addScaledVector(u, -f.x)
                    .multiplyScalar(i),
                  l[t].add(g),
                  l[e].add(g),
                  l[n].add(g),
                  c[t].add(x),
                  c[e].add(x),
                  c[n].add(x));
            }
            let y = this.groups;
            0 === y.length && (y = [{ start: 0, count: n.length }]);
            for (let T = 0, E = y.length; T < E; ++T) {
              const t = y[T],
                e = t.start;
              for (let r = e, i = e + t.count; r < i; r += 3)
                v(n[r + 0], n[r + 1], n[r + 2]);
            }
            const _ = new xr(),
              M = new xr(),
              w = new xr(),
              b = new xr();
            function S(t) {
              w.fromArray(i, 3 * t), b.copy(w);
              const e = l[t];
              _.copy(e),
                _.sub(w.multiplyScalar(w.dot(e))).normalize(),
                M.crossVectors(b, e);
              const n = M.dot(c[t]) < 0 ? -1 : 1;
              (a[4 * t] = _.x),
                (a[4 * t + 1] = _.y),
                (a[4 * t + 2] = _.z),
                (a[4 * t + 3] = n);
            }
            for (let T = 0, E = y.length; T < E; ++T) {
              const t = y[T],
                e = t.start;
              for (let r = e, i = e + t.count; r < i; r += 3)
                S(n[r + 0]), S(n[r + 1]), S(n[r + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new Xi(new Float32Array(3 * e.count), 3)),
                  this.setAttribute("normal", n);
              else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const r = new xr(),
                i = new xr(),
                s = new xr(),
                o = new xr(),
                a = new xr(),
                l = new xr(),
                c = new xr(),
                h = new xr();
              if (t)
                for (let u = 0, p = t.count; u < p; u += 3) {
                  const p = t.getX(u + 0),
                    d = t.getX(u + 1),
                    m = t.getX(u + 2);
                  r.fromBufferAttribute(e, p),
                    i.fromBufferAttribute(e, d),
                    s.fromBufferAttribute(e, m),
                    c.subVectors(s, i),
                    h.subVectors(r, i),
                    c.cross(h),
                    o.fromBufferAttribute(n, p),
                    a.fromBufferAttribute(n, d),
                    l.fromBufferAttribute(n, m),
                    o.add(c),
                    a.add(c),
                    l.add(c),
                    n.setXYZ(p, o.x, o.y, o.z),
                    n.setXYZ(d, a.x, a.y, a.z),
                    n.setXYZ(m, l.x, l.y, l.z);
                }
              else
                for (let t = 0, u = e.count; t < u; t += 3)
                  r.fromBufferAttribute(e, t + 0),
                    i.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, i),
                    h.subVectors(r, i),
                    c.cross(h),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          merge(t, e) {
            if (!t || !t.isBufferGeometry)
              return void console.error(
                "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                t
              );
            void 0 === e &&
              ((e = 0),
                console.warn(
                  "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
                ));
            const n = this.attributes;
            for (const r in n) {
              if (void 0 === t.attributes[r]) continue;
              const i = n[r].array,
                s = t.attributes[r],
                o = s.array,
                a = s.itemSize * e,
                l = Math.min(o.length, i.length - a);
              for (let t = 0, e = a; t < l; t++, e++) i[e] = o[t];
            }
            return this;
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              ds.fromBufferAttribute(t, e),
                ds.normalize(),
                t.setXYZ(e, ds.x, ds.y, ds.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                r = t.itemSize,
                i = t.normalized,
                s = new n.constructor(e.length * r);
              let o = 0,
                a = 0;
              for (let l = 0, c = e.length; l < c; l++) {
                o = e[l] * r;
                for (let t = 0; t < r; t++) s[a++] = n[o++];
              }
              return new Xi(s, r, i);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new ms(),
              n = this.index.array,
              r = this.attributes;
            for (const o in r) {
              const i = t(r[o], n);
              e.setAttribute(o, i);
            }
            const i = this.morphAttributes;
            for (const o in i) {
              const r = [],
                s = i[o];
              for (let e = 0, i = s.length; e < i; e++) {
                const i = t(s[e], n);
                r.push(i);
              }
              e.morphAttributes[o] = r;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let o = 0, a = s.length; o < a; o++) {
              const t = s[o];
              e.addGroup(t.start, t.count, t.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
                (t.type = this.type),
                "" !== this.name && (t.name = this.name),
                Object.keys(this.userData).length > 0 &&
                (t.userData = this.userData),
                void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const a in n) {
              const e = n[a];
              t.data.attributes[a] = e.toJSON(t.data);
            }
            const r = {};
            let i = !1;
            for (const a in this.morphAttributes) {
              const e = this.morphAttributes[a],
                n = [];
              for (let r = 0, i = e.length; r < i; r++) {
                const i = e[r];
                n.push(i.toJSON(t.data));
              }
              n.length > 0 && ((r[a] = n), (i = !0));
            }
            i &&
              ((t.data.morphAttributes = r),
                (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const o = this.boundingSphere;
            return (
              null !== o &&
              (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
              t
            );
          }
          clone() {
            return new ms().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const r = t.attributes;
            for (const l in r) {
              const t = r[l];
              this.setAttribute(l, t.clone(e));
            }
            const i = t.morphAttributes;
            for (const l in i) {
              const t = [],
                n = i[l];
              for (let r = 0, i = n.length; r < i; r++) t.push(n[r].clone(e));
              this.morphAttributes[l] = t;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let l = 0, c = s.length; l < c; l++) {
              const t = s[l];
              this.addGroup(t.start, t.count, t.materialIndex);
            }
            const o = t.boundingBox;
            null !== o && (this.boundingBox = o.clone());
            const a = t.boundingSphere;
            return (
              null !== a && (this.boundingSphere = a.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        (exports.BufferGeometry = ms), (ms.prototype.isBufferGeometry = !0);
        const fs = new Yr(),
          gs = new Xr(),
          xs = new Or(),
          vs = new xr(),
          ys = new xr(),
          _s = new xr(),
          Ms = new xr(),
          ws = new xr(),
          bs = new xr(),
          Ss = new xr(),
          Ts = new xr(),
          Es = new xr(),
          As = new sr(),
          Ls = new sr(),
          Rs = new sr(),
          Cs = new xr(),
          Ps = new xr();
        class Ds extends yi {
          constructor(t = new ms(), e = new Wi()) {
            super(),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
          raycast(t, e) {
            const n = this.geometry,
              r = this.material,
              i = this.matrixWorld;
            if (void 0 === r) return;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
                xs.copy(n.boundingSphere),
                xs.applyMatrix4(i),
                !1 === t.ray.intersectsSphere(xs))
            )
              return;
            if (
              (fs.copy(i).invert(),
                gs.copy(t.ray).applyMatrix4(fs),
                null !== n.boundingBox && !1 === gs.intersectsBox(n.boundingBox))
            )
              return;
            let s;
            if (n.isBufferGeometry) {
              const i = n.index,
                o = n.attributes.position,
                a = n.morphAttributes.position,
                l = n.morphTargetsRelative,
                c = n.attributes.uv,
                h = n.attributes.uv2,
                u = n.groups,
                p = n.drawRange;
              if (null !== i)
                if (Array.isArray(r))
                  for (let n = 0, d = u.length; n < d; n++) {
                    const d = u[n],
                      m = r[d.materialIndex];
                    for (
                      let n = Math.max(d.start, p.start),
                      r = Math.min(d.start + d.count, p.start + p.count);
                      n < r;
                      n += 3
                    ) {
                      const r = i.getX(n),
                        u = i.getX(n + 1),
                        p = i.getX(n + 2);
                      (s = Bs(this, m, t, gs, o, a, l, c, h, r, u, p)) &&
                        ((s.faceIndex = Math.floor(n / 3)),
                          (s.face.materialIndex = d.materialIndex),
                          e.push(s));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, p.start),
                    u = Math.min(i.count, p.start + p.count);
                    n < u;
                    n += 3
                  ) {
                    const u = i.getX(n),
                      p = i.getX(n + 1),
                      d = i.getX(n + 2);
                    (s = Bs(this, r, t, gs, o, a, l, c, h, u, p, d)) &&
                      ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                  }
                }
              else if (void 0 !== o)
                if (Array.isArray(r))
                  for (let n = 0, d = u.length; n < d; n++) {
                    const i = u[n],
                      d = r[i.materialIndex];
                    for (
                      let n = Math.max(i.start, p.start),
                      r = Math.min(i.start + i.count, p.start + p.count);
                      n < r;
                      n += 3
                    ) {
                      (s = Bs(
                        this,
                        d,
                        t,
                        gs,
                        o,
                        a,
                        l,
                        c,
                        h,
                        n,
                        n + 1,
                        n + 2
                      )) &&
                        ((s.faceIndex = Math.floor(n / 3)),
                          (s.face.materialIndex = i.materialIndex),
                          e.push(s));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, p.start),
                    i = Math.min(o.count, p.start + p.count);
                    n < i;
                    n += 3
                  ) {
                    (s = Bs(this, r, t, gs, o, a, l, c, h, n, n + 1, n + 2)) &&
                      ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                  }
                }
            } else
              n.isGeometry &&
                console.error(
                  "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
          }
        }
        function Is(t, e, n, r, i, s, o, a) {
          let l;
          if (
            null ===
            (l =
              e.side === p
                ? r.intersectTriangle(o, s, i, !0, a)
                : r.intersectTriangle(i, s, o, e.side !== d, a))
          )
            return null;
          Ps.copy(a), Ps.applyMatrix4(t.matrixWorld);
          const c = n.ray.origin.distanceTo(Ps);
          return c < n.near || c > n.far
            ? null
            : { distance: c, point: Ps.clone(), object: t };
        }
        function Bs(t, e, n, r, i, s, o, a, l, c, h, u) {
          vs.fromBufferAttribute(i, c),
            ys.fromBufferAttribute(i, h),
            _s.fromBufferAttribute(i, u);
          const p = t.morphTargetInfluences;
          if (e.morphTargets && s && p) {
            Ss.set(0, 0, 0), Ts.set(0, 0, 0), Es.set(0, 0, 0);
            for (let t = 0, e = s.length; t < e; t++) {
              const e = p[t],
                n = s[t];
              0 !== e &&
                (Ms.fromBufferAttribute(n, c),
                  ws.fromBufferAttribute(n, h),
                  bs.fromBufferAttribute(n, u),
                  o
                    ? (Ss.addScaledVector(Ms, e),
                      Ts.addScaledVector(ws, e),
                      Es.addScaledVector(bs, e))
                    : (Ss.addScaledVector(Ms.sub(vs), e),
                      Ts.addScaledVector(ws.sub(ys), e),
                      Es.addScaledVector(bs.sub(_s), e)));
            }
            vs.add(Ss), ys.add(Ts), _s.add(Es);
          }
          t.isSkinnedMesh &&
            (t.boneTransform(c, vs),
              t.boneTransform(h, ys),
              t.boneTransform(u, _s));
          const d = Is(t, e, n, r, vs, ys, _s, Cs);
          if (d) {
            a &&
              (As.fromBufferAttribute(a, c),
                Ls.fromBufferAttribute(a, h),
                Rs.fromBufferAttribute(a, u),
                (d.uv = Bi.getUV(Cs, vs, ys, _s, As, Ls, Rs, new sr()))),
              l &&
              (As.fromBufferAttribute(l, c),
                Ls.fromBufferAttribute(l, h),
                Rs.fromBufferAttribute(l, u),
                (d.uv2 = Bi.getUV(Cs, vs, ys, _s, As, Ls, Rs, new sr())));
            const t = { a: c, b: h, c: u, normal: new xr(), materialIndex: 0 };
            Bi.getNormal(vs, ys, _s, t.normal), (d.face = t);
          }
          return d;
        }
        (exports.Mesh = Ds), (Ds.prototype.isMesh = !0);
        class Fs extends ms {
          constructor(t = 1, e = 1, n = 1, r = 1, i = 1, s = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: r,
                heightSegments: i,
                depthSegments: s,
              });
            const o = this;
            (r = Math.floor(r)), (i = Math.floor(i)), (s = Math.floor(s));
            const a = [],
              l = [],
              c = [],
              h = [];
            let u = 0,
              p = 0;
            function d(t, e, n, r, i, s, d, m, f, g, x) {
              const v = s / f,
                y = d / g,
                _ = s / 2,
                M = d / 2,
                w = m / 2,
                b = f + 1,
                S = g + 1;
              let T = 0,
                E = 0;
              const A = new xr();
              for (let o = 0; o < S; o++) {
                const s = o * y - M;
                for (let a = 0; a < b; a++) {
                  const u = a * v - _;
                  (A[t] = u * r),
                    (A[e] = s * i),
                    (A[n] = w),
                    l.push(A.x, A.y, A.z),
                    (A[t] = 0),
                    (A[e] = 0),
                    (A[n] = m > 0 ? 1 : -1),
                    c.push(A.x, A.y, A.z),
                    h.push(a / f),
                    h.push(1 - o / g),
                    (T += 1);
                }
              }
              for (let o = 0; o < g; o++)
                for (let t = 0; t < f; t++) {
                  const e = u + t + b * o,
                    n = u + t + b * (o + 1),
                    r = u + (t + 1) + b * (o + 1),
                    i = u + (t + 1) + b * o;
                  a.push(e, n, i), a.push(n, r, i), (E += 6);
                }
              o.addGroup(p, E, x), (p += E), (u += T);
            }
            d("z", "y", "x", -1, -1, n, e, t, s, i, 0),
              d("z", "y", "x", 1, -1, n, e, -t, s, i, 1),
              d("x", "z", "y", 1, 1, t, n, e, r, s, 2),
              d("x", "z", "y", 1, -1, t, n, -e, r, s, 3),
              d("x", "y", "z", 1, -1, t, e, n, r, i, 4),
              d("x", "y", "z", -1, -1, t, e, -n, r, i, 5),
              this.setIndex(a),
              this.setAttribute("position", new ns(l, 3)),
              this.setAttribute("normal", new ns(c, 3)),
              this.setAttribute("uv", new ns(h, 2));
          }
        }
        function Ns(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const r in t[n]) {
              const i = t[n][r];
              i &&
                (i.isColor ||
                  i.isMatrix3 ||
                  i.isMatrix4 ||
                  i.isVector2 ||
                  i.isVector3 ||
                  i.isVector4 ||
                  i.isTexture ||
                  i.isQuaternion)
                ? (e[n][r] = i.clone())
                : Array.isArray(i)
                  ? (e[n][r] = i.slice())
                  : (e[n][r] = i);
            }
          }
          return e;
        }
        function Gs(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const r = Ns(t[n]);
            for (const t in r) e[t] = r[t];
          }
          return e;
        }
        exports.BoxGeometry = exports.BoxBufferGeometry = Fs;
        const zs = { clone: Ns, merge: Gs };
        exports.UniformsUtils = zs;
        var Os =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
          Hs = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
        class Us extends Ni {
          constructor(t) {
            super(),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.vertexShader = Os),
              (this.fragmentShader = Hs),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t &&
              (void 0 !== t.attributes &&
                console.error(
                  "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                ),
                this.setValues(t));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = Ns(t.uniforms)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const r in this.uniforms) {
              const n = this.uniforms[r].value;
              n && n.isTexture
                ? (e.uniforms[r] = { type: "t", value: n.toJSON(t).uuid })
                : n && n.isColor
                  ? (e.uniforms[r] = { type: "c", value: n.getHex() })
                  : n && n.isVector2
                    ? (e.uniforms[r] = { type: "v2", value: n.toArray() })
                    : n && n.isVector3
                      ? (e.uniforms[r] = { type: "v3", value: n.toArray() })
                      : n && n.isVector4
                        ? (e.uniforms[r] = { type: "v4", value: n.toArray() })
                        : n && n.isMatrix3
                          ? (e.uniforms[r] = { type: "m3", value: n.toArray() })
                          : n && n.isMatrix4
                            ? (e.uniforms[r] = { type: "m4", value: n.toArray() })
                            : (e.uniforms[r] = { value: n });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader);
            const n = {};
            for (const r in this.extensions)
              !0 === this.extensions[r] && (n[r] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        (exports.ShaderMaterial = Us), (Us.prototype.isShaderMaterial = !0);
        class ks extends yi {
          constructor() {
            super(),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new Yr()),
              (this.projectionMatrix = new Yr()),
              (this.projectionMatrixInverse = new Yr());
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              this
            );
          }
          getWorldDirection(t) {
            void 0 === t &&
              (console.warn(
                "THREE.Camera: .getWorldDirection() target is now required"
              ),
                (t = new xr())),
              this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        (exports.Camera = ks), (ks.prototype.isCamera = !0);
        class Vs extends ks {
          constructor(t = 50, e = 1, n = 0.1, r = 2e3) {
            super(),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = r),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * Gn * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * Nn * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return (
              2 * Gn * Math.atan(Math.tan(0.5 * Nn * this.fov) / this.zoom)
            );
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, r, i, s) {
            (this.aspect = t / e),
              null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = r),
              (this.view.width = i),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * Nn * this.fov)) / this.zoom,
              n = 2 * e,
              r = this.aspect * n,
              i = -0.5 * r;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = s.fullWidth,
                o = s.fullHeight;
              (i += (s.offsetX * r) / t),
                (e -= (s.offsetY * n) / o),
                (r *= s.width / t),
                (n *= s.height / o);
            }
            const o = this.filmOffset;
            0 !== o && (i += (t * o) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                i,
                i + r,
                e,
                e - n,
                t,
                this.far
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        (exports.PerspectiveCamera = Vs),
          (Vs.prototype.isPerspectiveCamera = !0);
        const Ws = 90,
          js = 1;
        class qs extends yi {
          constructor(t, e, n) {
            if (
              (super(),
                (this.type = "CubeCamera"),
                !0 !== n.isWebGLCubeRenderTarget)
            )
              return void console.error(
                "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
              );
            this.renderTarget = n;
            const r = new Vs(Ws, js, t, e);
            (r.layers = this.layers),
              r.up.set(0, -1, 0),
              r.lookAt(new xr(1, 0, 0)),
              this.add(r);
            const i = new Vs(Ws, js, t, e);
            (i.layers = this.layers),
              i.up.set(0, -1, 0),
              i.lookAt(new xr(-1, 0, 0)),
              this.add(i);
            const s = new Vs(Ws, js, t, e);
            (s.layers = this.layers),
              s.up.set(0, 0, 1),
              s.lookAt(new xr(0, 1, 0)),
              this.add(s);
            const o = new Vs(Ws, js, t, e);
            (o.layers = this.layers),
              o.up.set(0, 0, -1),
              o.lookAt(new xr(0, -1, 0)),
              this.add(o);
            const a = new Vs(Ws, js, t, e);
            (a.layers = this.layers),
              a.up.set(0, -1, 0),
              a.lookAt(new xr(0, 0, 1)),
              this.add(a);
            const l = new Vs(Ws, js, t, e);
            (l.layers = this.layers),
              l.up.set(0, -1, 0),
              l.lookAt(new xr(0, 0, -1)),
              this.add(l);
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget,
              [r, i, s, o, a, l] = this.children,
              c = t.xr.enabled,
              h = t.getRenderTarget();
            t.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, r),
              t.setRenderTarget(n, 1),
              t.render(e, i),
              t.setRenderTarget(n, 2),
              t.render(e, s),
              t.setRenderTarget(n, 3),
              t.render(e, o),
              t.setRenderTarget(n, 4),
              t.render(e, a),
              (n.texture.generateMipmaps = u),
              t.setRenderTarget(n, 5),
              t.render(e, l),
              t.setRenderTarget(h),
              (t.xr.enabled = c);
          }
        }
        exports.CubeCamera = qs;
        class Xs extends hr {
          constructor(t, e, n, r, i, s, o, a, l, c) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : nt),
              n,
              r,
              i,
              s,
              (o = void 0 !== o ? o : Bt),
              a,
              l,
              c
            ),
              (this._needsFlipEnvMap = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        (exports.CubeTexture = Xs), (Xs.prototype.isCubeTexture = !0);
        class Ys extends dr {
          constructor(t, e, n) {
            Number.isInteger(e) &&
              (console.warn(
                "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
              ),
                (e = n)),
              super(t, t, e),
              (e = e || {}),
              (this.texture = new Xs(
                void 0,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.encoding
              )),
              (this.texture.generateMipmaps =
                void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== e.minFilter ? e.minFilter : gt),
              (this.texture._needsFlipEnvMap = !1);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.format = Ft),
              (this.texture.encoding = e.encoding),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader:
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              fragmentShader:
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            },
              r = new Fs(5, 5, 5),
              i = new Us({
                name: "CubemapFromEquirect",
                uniforms: Ns(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: p,
                blending: g,
              });
            i.uniforms.tEquirect.value = e;
            const s = new Ds(r, i),
              o = e.minFilter;
            return (
              e.minFilter === yt && (e.minFilter = gt),
              new qs(1, 10, this).update(t, s),
              (e.minFilter = o),
              s.geometry.dispose(),
              s.material.dispose(),
              this
            );
          }
          clear(t, e, n, r) {
            const i = t.getRenderTarget();
            for (let s = 0; s < 6; s++)
              t.setRenderTarget(this, s), t.clear(e, n, r);
            t.setRenderTarget(i);
          }
        }
        (exports.WebGLCubeRenderTarget = Ys),
          (Ys.prototype.isWebGLCubeRenderTarget = !0);
        const Zs = new Or(),
          Js = new xr();
        class Qs {
          constructor(
            t = new bi(),
            e = new bi(),
            n = new bi(),
            r = new bi(),
            i = new bi(),
            s = new bi()
          ) {
            this.planes = [t, e, n, r, i, s];
          }
          set(t, e, n, r, i, s) {
            const o = this.planes;
            return (
              o[0].copy(t),
              o[1].copy(e),
              o[2].copy(n),
              o[3].copy(r),
              o[4].copy(i),
              o[5].copy(s),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t) {
            const e = this.planes,
              n = t.elements,
              r = n[0],
              i = n[1],
              s = n[2],
              o = n[3],
              a = n[4],
              l = n[5],
              c = n[6],
              h = n[7],
              u = n[8],
              p = n[9],
              d = n[10],
              m = n[11],
              f = n[12],
              g = n[13],
              x = n[14],
              v = n[15];
            return (
              e[0].setComponents(o - r, h - a, m - u, v - f).normalize(),
              e[1].setComponents(o + r, h + a, m + u, v + f).normalize(),
              e[2].setComponents(o + i, h + l, m + p, v + g).normalize(),
              e[3].setComponents(o - i, h - l, m - p, v - g).normalize(),
              e[4].setComponents(o - s, h - c, m - d, v - x).normalize(),
              e[5].setComponents(o + s, h + c, m + d, v + x).normalize(),
              this
            );
          }
          intersectsObject(t) {
            const e = t.geometry;
            return (
              null === e.boundingSphere && e.computeBoundingSphere(),
              Zs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Zs)
            );
          }
          intersectsSprite(t) {
            return (
              Zs.center.set(0, 0, 0),
              (Zs.radius = 0.7071067811865476),
              Zs.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(Zs)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              r = -t.radius;
            for (let i = 0; i < 6; i++) {
              if (e[i].distanceToPoint(n) < r) return !1;
            }
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const r = e[n];
              if (
                ((Js.x = r.normal.x > 0 ? t.max.x : t.min.x),
                  (Js.y = r.normal.y > 0 ? t.max.y : t.min.y),
                  (Js.z = r.normal.z > 0 ? t.max.z : t.min.z),
                  r.distanceToPoint(Js) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function Ks() {
          let t = null,
            e = !1,
            n = null,
            r = null;
          function i(e, s) {
            n(e, s), (r = t.requestAnimationFrame(i));
          }
          return {
            start: function () {
              !0 !== e &&
                null !== n &&
                ((r = t.requestAnimationFrame(i)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(r), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function $s(t, e) {
          const n = e.isWebGL2,
            r = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), r.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = r.get(e);
              n && (t.deleteBuffer(n.buffer), r.delete(e));
            },
            update: function (e, i) {
              if (e.isGLBufferAttribute) {
                const t = r.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  r.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const s = r.get(e);
              void 0 === s
                ? r.set(
                  e,
                  (function (e, r) {
                    const i = e.array,
                      s = e.usage,
                      o = t.createBuffer();
                    t.bindBuffer(r, o),
                      t.bufferData(r, i, s),
                      e.onUploadCallback();
                    let a = 5126;
                    return (
                      i instanceof Float32Array
                        ? (a = 5126)
                        : i instanceof Float64Array
                          ? console.warn(
                            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                          )
                          : i instanceof Uint16Array
                            ? e.isFloat16BufferAttribute
                              ? n
                                ? (a = 5131)
                                : console.warn(
                                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                                )
                              : (a = 5123)
                            : i instanceof Int16Array
                              ? (a = 5122)
                              : i instanceof Uint32Array
                                ? (a = 5125)
                                : i instanceof Int32Array
                                  ? (a = 5124)
                                  : i instanceof Int8Array
                                    ? (a = 5120)
                                    : i instanceof Uint8Array
                                      ? (a = 5121)
                                      : i instanceof Uint8ClampedArray && (a = 5121),
                      {
                        buffer: o,
                        type: a,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: e.version,
                      }
                    );
                  })(e, i)
                )
                : s.version < e.version &&
                ((function (e, r, i) {
                  const s = r.array,
                    o = r.updateRange;
                  t.bindBuffer(i, e),
                    -1 === o.count
                      ? t.bufferSubData(i, 0, s)
                      : (n
                        ? t.bufferSubData(
                          i,
                          o.offset * s.BYTES_PER_ELEMENT,
                          s,
                          o.offset,
                          o.count
                        )
                        : t.bufferSubData(
                          i,
                          o.offset * s.BYTES_PER_ELEMENT,
                          s.subarray(o.offset, o.offset + o.count)
                        ),
                        (o.count = -1));
                })(s.buffer, e, i),
                  (s.version = e.version));
            },
          };
        }
        exports.Frustum = Qs;
        class to extends ms {
          constructor(t = 1, e = 1, n = 1, r = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: r,
              });
            const i = t / 2,
              s = e / 2,
              o = Math.floor(n),
              a = Math.floor(r),
              l = o + 1,
              c = a + 1,
              h = t / o,
              u = e / a,
              p = [],
              d = [],
              m = [],
              f = [];
            for (let g = 0; g < c; g++) {
              const t = g * u - s;
              for (let e = 0; e < l; e++) {
                const n = e * h - i;
                d.push(n, -t, 0),
                  m.push(0, 0, 1),
                  f.push(e / o),
                  f.push(1 - g / a);
              }
            }
            for (let g = 0; g < a; g++)
              for (let t = 0; t < o; t++) {
                const e = t + l * g,
                  n = t + l * (g + 1),
                  r = t + 1 + l * (g + 1),
                  i = t + 1 + l * g;
                p.push(e, n, i), p.push(n, r, i);
              }
            this.setIndex(p),
              this.setAttribute("position", new ns(d, 3)),
              this.setAttribute("normal", new ns(m, 3)),
              this.setAttribute("uv", new ns(f, 2));
          }
        }
        exports.PlaneGeometry = exports.PlaneBufferGeometry = to;
        var eo =
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
          no = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          ro =
            "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
          io =
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
          so =
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          oo = "vec3 transformed = vec3( position );",
          ao =
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          lo =
            "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
          co =
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          ho =
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          uo =
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          po =
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          mo =
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          fo =
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          go =
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          xo =
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          vo =
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          yo =
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
          _o =
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          Mo =
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          wo =
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          bo =
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
          So =
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          To =
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          Eo = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          Ao =
            "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
          Lo =
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          Ro =
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          Co =
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          Po =
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          Do =
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          Io = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
          Bo = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
          Fo =
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          No =
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          Go =
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
          zo =
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
          Oo =
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          Ho =
            "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
          Uo =
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
          ko =
            "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
          Vo =
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          Wo =
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
          jo =
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          qo =
            "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
          Xo =
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
          Yo =
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          Zo =
            "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          Jo =
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
          Qo =
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
          Ko =
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          $o =
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          ta =
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          ea =
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          na =
            "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
          ra = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          ia =
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          sa =
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          oa =
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          aa =
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          la =
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
          ca =
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
          ha =
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
          ua =
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
          pa =
            "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          da =
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
          ma =
            "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
          fa =
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
          ga =
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
          xa =
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
          va =
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          ya =
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          _a =
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          Ma =
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          wa =
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          ba =
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          Sa =
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          Ta =
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          Ea =
            "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
          Aa =
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          La =
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          Ra =
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
          Ca =
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          Pa =
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          Da =
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          Ia =
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          Ba =
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          Fa =
            "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          Na =
            "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\n\tvec3 f90 = vec3( 1.0 );\n\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\n\t\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance);\n\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\n#endif",
          Ga =
            "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\tfloat NdotV = saturate(dot(n, viewDir));\n\t\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\n\t\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
          za =
            "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
          Oa =
            "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
          Ha =
            "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
          Ua =
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
          ka =
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
          Va =
            "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
          Wa =
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          ja =
            "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          qa =
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          Xa =
            "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          Ya =
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          Za =
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          Ja =
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          Qa =
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          Ka =
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          $a =
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
          tl =
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          el =
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          nl =
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          rl =
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          il =
            "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          sl =
            "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          ol =
            "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          al =
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          ll =
            "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          cl =
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          hl =
            "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          ul =
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          pl =
            "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          dl =
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef USE_TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t\tfloat thicknessFactor = thickness;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\tvec3 rawDiffuseColor = diffuseColor.rgb;\n\t#include <transmission_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          ml =
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
          fl =
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
          gl =
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          xl =
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          vl =
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          yl =
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          _l =
            "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          Ml =
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
          wl =
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
        const bl = {
          alphamap_fragment: eo,
          alphamap_pars_fragment: no,
          alphatest_fragment: ro,
          aomap_fragment: io,
          aomap_pars_fragment: so,
          begin_vertex: oo,
          beginnormal_vertex: ao,
          bsdfs: lo,
          bumpmap_pars_fragment: co,
          clipping_planes_fragment: ho,
          clipping_planes_pars_fragment: uo,
          clipping_planes_pars_vertex: po,
          clipping_planes_vertex: mo,
          color_fragment: fo,
          color_pars_fragment: go,
          color_pars_vertex: xo,
          color_vertex: vo,
          common: yo,
          cube_uv_reflection_fragment: _o,
          defaultnormal_vertex: Mo,
          displacementmap_pars_vertex: wo,
          displacementmap_vertex: bo,
          emissivemap_fragment: So,
          emissivemap_pars_fragment: To,
          encodings_fragment: Eo,
          encodings_pars_fragment: Ao,
          envmap_fragment: Lo,
          envmap_common_pars_fragment: Ro,
          envmap_pars_fragment: Co,
          envmap_pars_vertex: Po,
          envmap_physical_pars_fragment: ko,
          envmap_vertex: Do,
          fog_vertex: Io,
          fog_pars_vertex: Bo,
          fog_fragment: Fo,
          fog_pars_fragment: No,
          gradientmap_pars_fragment: Go,
          lightmap_fragment: zo,
          lightmap_pars_fragment: Oo,
          lights_lambert_vertex: Ho,
          lights_pars_begin: Uo,
          lights_toon_fragment: Vo,
          lights_toon_pars_fragment: Wo,
          lights_phong_fragment: jo,
          lights_phong_pars_fragment: qo,
          lights_physical_fragment: Xo,
          lights_physical_pars_fragment: Yo,
          lights_fragment_begin: Zo,
          lights_fragment_maps: Jo,
          lights_fragment_end: Qo,
          logdepthbuf_fragment: Ko,
          logdepthbuf_pars_fragment: $o,
          logdepthbuf_pars_vertex: ta,
          logdepthbuf_vertex: ea,
          map_fragment: na,
          map_pars_fragment: ra,
          map_particle_fragment: ia,
          map_particle_pars_fragment: sa,
          metalnessmap_fragment: oa,
          metalnessmap_pars_fragment: aa,
          morphnormal_vertex: la,
          morphtarget_pars_vertex: ca,
          morphtarget_vertex: ha,
          normal_fragment_begin: ua,
          normal_fragment_maps: pa,
          normalmap_pars_fragment: da,
          clearcoat_normal_fragment_begin: ma,
          clearcoat_normal_fragment_maps: fa,
          clearcoat_pars_fragment: ga,
          packing: xa,
          premultiplied_alpha_fragment: va,
          project_vertex: ya,
          dithering_fragment: _a,
          dithering_pars_fragment: Ma,
          roughnessmap_fragment: wa,
          roughnessmap_pars_fragment: ba,
          shadowmap_pars_fragment: Sa,
          shadowmap_pars_vertex: Ta,
          shadowmap_vertex: Ea,
          shadowmask_pars_fragment: Aa,
          skinbase_vertex: La,
          skinning_pars_vertex: Ra,
          skinning_vertex: Ca,
          skinnormal_vertex: Pa,
          specularmap_fragment: Da,
          specularmap_pars_fragment: Ia,
          tonemapping_fragment: Ba,
          tonemapping_pars_fragment: Fa,
          transmission_fragment: Na,
          transmission_pars_fragment: Ga,
          uv_pars_fragment: za,
          uv_pars_vertex: Oa,
          uv_vertex: Ha,
          uv2_pars_fragment: Ua,
          uv2_pars_vertex: ka,
          uv2_vertex: Va,
          worldpos_vertex: Wa,
          background_frag: ja,
          background_vert: qa,
          cube_frag: Xa,
          cube_vert: Ya,
          depth_frag: Za,
          depth_vert: Ja,
          distanceRGBA_frag: Qa,
          distanceRGBA_vert: Ka,
          equirect_frag: $a,
          equirect_vert: tl,
          linedashed_frag: el,
          linedashed_vert: nl,
          meshbasic_frag: rl,
          meshbasic_vert: il,
          meshlambert_frag: sl,
          meshlambert_vert: ol,
          meshmatcap_frag: al,
          meshmatcap_vert: ll,
          meshtoon_frag: cl,
          meshtoon_vert: hl,
          meshphong_frag: ul,
          meshphong_vert: pl,
          meshphysical_frag: dl,
          meshphysical_vert: ml,
          normal_frag: fl,
          normal_vert: gl,
          points_frag: xl,
          points_vert: vl,
          shadow_frag: yl,
          shadow_vert: _l,
          sprite_frag: Ml,
          sprite_vert: wl,
        };
        exports.ShaderChunk = bl;
        const Sl = {
          common: {
            diffuse: { value: new Vi(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            uvTransform: { value: new or() },
            uv2Transform: { value: new or() },
            alphaMap: { value: null },
          },
          specularmap: { specularMap: { value: null } },
          envmap: {
            envMap: { value: null },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 },
          },
          aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
          },
          emissivemap: { emissiveMap: { value: null } },
          bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
          normalmap: {
            normalMap: { value: null },
            normalScale: { value: new sr(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          roughnessmap: { roughnessMap: { value: null } },
          metalnessmap: { metalnessMap: { value: null } },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Vi(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Vi(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new or() },
          },
          sprite: {
            diffuse: { value: new Vi(16777215) },
            opacity: { value: 1 },
            center: { value: new sr(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new or() },
          },
        };
        exports.UniformsLib = Sl;
        const Tl = {
          basic: {
            uniforms: Gs([
              Sl.common,
              Sl.specularmap,
              Sl.envmap,
              Sl.aomap,
              Sl.lightmap,
              Sl.fog,
            ]),
            vertexShader: bl.meshbasic_vert,
            fragmentShader: bl.meshbasic_frag,
          },
          lambert: {
            uniforms: Gs([
              Sl.common,
              Sl.specularmap,
              Sl.envmap,
              Sl.aomap,
              Sl.lightmap,
              Sl.emissivemap,
              Sl.fog,
              Sl.lights,
              { emissive: { value: new Vi(0) } },
            ]),
            vertexShader: bl.meshlambert_vert,
            fragmentShader: bl.meshlambert_frag,
          },
          phong: {
            uniforms: Gs([
              Sl.common,
              Sl.specularmap,
              Sl.envmap,
              Sl.aomap,
              Sl.lightmap,
              Sl.emissivemap,
              Sl.bumpmap,
              Sl.normalmap,
              Sl.displacementmap,
              Sl.fog,
              Sl.lights,
              {
                emissive: { value: new Vi(0) },
                specular: { value: new Vi(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: bl.meshphong_vert,
            fragmentShader: bl.meshphong_frag,
          },
          standard: {
            uniforms: Gs([
              Sl.common,
              Sl.envmap,
              Sl.aomap,
              Sl.lightmap,
              Sl.emissivemap,
              Sl.bumpmap,
              Sl.normalmap,
              Sl.displacementmap,
              Sl.roughnessmap,
              Sl.metalnessmap,
              Sl.fog,
              Sl.lights,
              {
                emissive: { value: new Vi(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: bl.meshphysical_vert,
            fragmentShader: bl.meshphysical_frag,
          },
          toon: {
            uniforms: Gs([
              Sl.common,
              Sl.aomap,
              Sl.lightmap,
              Sl.emissivemap,
              Sl.bumpmap,
              Sl.normalmap,
              Sl.displacementmap,
              Sl.gradientmap,
              Sl.fog,
              Sl.lights,
              { emissive: { value: new Vi(0) } },
            ]),
            vertexShader: bl.meshtoon_vert,
            fragmentShader: bl.meshtoon_frag,
          },
          matcap: {
            uniforms: Gs([
              Sl.common,
              Sl.bumpmap,
              Sl.normalmap,
              Sl.displacementmap,
              Sl.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: bl.meshmatcap_vert,
            fragmentShader: bl.meshmatcap_frag,
          },
          points: {
            uniforms: Gs([Sl.points, Sl.fog]),
            vertexShader: bl.points_vert,
            fragmentShader: bl.points_frag,
          },
          dashed: {
            uniforms: Gs([
              Sl.common,
              Sl.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: bl.linedashed_vert,
            fragmentShader: bl.linedashed_frag,
          },
          depth: {
            uniforms: Gs([Sl.common, Sl.displacementmap]),
            vertexShader: bl.depth_vert,
            fragmentShader: bl.depth_frag,
          },
          normal: {
            uniforms: Gs([
              Sl.common,
              Sl.bumpmap,
              Sl.normalmap,
              Sl.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: bl.normal_vert,
            fragmentShader: bl.normal_frag,
          },
          sprite: {
            uniforms: Gs([Sl.sprite, Sl.fog]),
            vertexShader: bl.sprite_vert,
            fragmentShader: bl.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new or() },
              t2D: { value: null },
            },
            vertexShader: bl.background_vert,
            fragmentShader: bl.background_frag,
          },
          cube: {
            uniforms: Gs([Sl.envmap, { opacity: { value: 1 } }]),
            vertexShader: bl.cube_vert,
            fragmentShader: bl.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: bl.equirect_vert,
            fragmentShader: bl.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Gs([
              Sl.common,
              Sl.displacementmap,
              {
                referencePosition: { value: new xr() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: bl.distanceRGBA_vert,
            fragmentShader: bl.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Gs([
              Sl.lights,
              Sl.fog,
              { color: { value: new Vi(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: bl.shadow_vert,
            fragmentShader: bl.shadow_frag,
          },
        };
        function El(t, e, n, r, i) {
          const s = new Vi(0);
          let o,
            a,
            l = 0,
            c = null,
            h = 0,
            d = null;
          function m(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, i);
          }
          return {
            getClearColor: function () {
              return s;
            },
            setClearColor: function (t, e = 1) {
              s.set(t), m(s, (l = e));
            },
            getClearAlpha: function () {
              return l;
            },
            setClearAlpha: function (t) {
              m(s, (l = t));
            },
            render: function (n, i) {
              let f = !1,
                g = !0 === i.isScene ? i.background : null;
              g && g.isTexture && (g = e.get(g));
              const x = t.xr,
                v = x.getSession && x.getSession();
              v && "additive" === v.environmentBlendMode && (g = null),
                null === g ? m(s, l) : g && g.isColor && (m(g, 1), (f = !0)),
                (t.autoClear || f) &&
                t.clear(
                  t.autoClearColor,
                  t.autoClearDepth,
                  t.autoClearStencil
                ),
                g && (g.isCubeTexture || g.mapping === ot)
                  ? (void 0 === a &&
                    ((a = new Ds(
                      new Fs(1, 1, 1),
                      new Us({
                        name: "BackgroundCubeMaterial",
                        uniforms: Ns(Tl.cube.uniforms),
                        vertexShader: Tl.cube.vertexShader,
                        fragmentShader: Tl.cube.fragmentShader,
                        side: p,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                      a.geometry.deleteAttribute("uv"),
                      (a.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(a.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      r.update(a)),
                    (a.material.uniforms.envMap.value = g),
                    (a.material.uniforms.flipEnvMap.value =
                      g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1),
                    (c === g && h === g.version && d === t.toneMapping) ||
                    ((a.material.needsUpdate = !0),
                      (c = g),
                      (h = g.version),
                      (d = t.toneMapping)),
                    n.unshift(a, a.geometry, a.material, 0, 0, null))
                  : g &&
                  g.isTexture &&
                  (void 0 === o &&
                    ((o = new Ds(
                      new to(2, 2),
                      new Us({
                        name: "BackgroundMaterial",
                        uniforms: Ns(Tl.background.uniforms),
                        vertexShader: Tl.background.vertexShader,
                        fragmentShader: Tl.background.fragmentShader,
                        side: u,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )).geometry.deleteAttribute("normal"),
                      Object.defineProperty(o.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      r.update(o)),
                    (o.material.uniforms.t2D.value = g),
                    !0 === g.matrixAutoUpdate && g.updateMatrix(),
                    o.material.uniforms.uvTransform.value.copy(g.matrix),
                    (c === g && h === g.version && d === t.toneMapping) ||
                    ((o.material.needsUpdate = !0),
                      (c = g),
                      (h = g.version),
                      (d = t.toneMapping)),
                    n.unshift(o, o.geometry, o.material, 0, 0, null));
            },
          };
        }
        function Al(t, e, n, r) {
          const i = t.getParameter(34921),
            s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            o = r.isWebGL2 || null !== s,
            a = {},
            l = p(null);
          let c = l;
          function h(e) {
            return r.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
          }
          function u(e) {
            return r.isWebGL2
              ? t.deleteVertexArray(e)
              : s.deleteVertexArrayOES(e);
          }
          function p(t) {
            const e = [],
              n = [],
              r = [];
            for (let s = 0; s < i; s++) (e[s] = 0), (n[s] = 0), (r[s] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: r,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function d() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            f(t, 0);
          }
          function f(n, i) {
            const s = c.newAttributes,
              o = c.enabledAttributes,
              a = c.attributeDivisors;
            if (
              ((s[n] = 1),
                0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
                a[n] !== i)
            ) {
              (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, i),
                (a[n] = i);
            }
          }
          function g() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let r = 0, i = n.length; r < i; r++)
              n[r] !== e[r] && (t.disableVertexAttribArray(r), (n[r] = 0));
          }
          function x(e, n, i, s, o, a) {
            !0 !== r.isWebGL2 || (5124 !== i && 5125 !== i)
              ? t.vertexAttribPointer(e, n, i, s, o, a)
              : t.vertexAttribIPointer(e, n, i, o, a);
          }
          function v() {
            y(), c !== l && h((c = l).object);
          }
          function y() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (i, l, u, v, y) {
              let _ = !1;
              if (o) {
                const e = (function (e, n, i) {
                  const o = !0 === i.wireframe;
                  let l = a[e.id];
                  void 0 === l && ((l = {}), (a[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let h = c[o];
                  return (
                    void 0 === h &&
                    ((h = p(
                      r.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                      (c[o] = h)),
                    h
                  );
                })(v, u, l);
                c !== e && h((c = e).object),
                  (_ = (function (t, e) {
                    const n = c.attributes,
                      r = t.attributes;
                    let i = 0;
                    for (const s in r) {
                      const t = n[s],
                        e = r[s];
                      if (void 0 === t) return !0;
                      if (t.attribute !== e) return !0;
                      if (t.data !== e.data) return !0;
                      i++;
                    }
                    return c.attributesNum !== i || c.index !== e;
                  })(v, y)) &&
                  (function (t, e) {
                    const n = {},
                      r = t.attributes;
                    let i = 0;
                    for (const s in r) {
                      const t = r[s],
                        e = {};
                      (e.attribute = t),
                        t.data && (e.data = t.data),
                        (n[s] = e),
                        i++;
                    }
                    (c.attributes = n), (c.attributesNum = i), (c.index = e);
                  })(v, y);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === v.id &&
                  c.program === u.id &&
                  c.wireframe === t) ||
                  ((c.geometry = v.id),
                    (c.program = u.id),
                    (c.wireframe = t),
                    (_ = !0));
              }
              !0 === i.isInstancedMesh && (_ = !0),
                null !== y && n.update(y, 34963),
                _ &&
                ((function (i, s, o, a) {
                  if (
                    !1 === r.isWebGL2 &&
                    (i.isInstancedMesh || a.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  d();
                  const l = a.attributes,
                    c = o.getAttributes(),
                    h = s.defaultAttributeValues;
                  for (const e in c) {
                    const r = c[e];
                    if (r >= 0) {
                      const s = l[e];
                      if (void 0 !== s) {
                        const e = s.normalized,
                          i = s.itemSize,
                          o = n.get(s);
                        if (void 0 === o) continue;
                        const l = o.buffer,
                          c = o.type,
                          h = o.bytesPerElement;
                        if (s.isInterleavedBufferAttribute) {
                          const n = s.data,
                            o = n.stride,
                            u = s.offset;
                          n && n.isInstancedInterleavedBuffer
                            ? (f(r, n.meshPerAttribute),
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                n.meshPerAttribute * n.count))
                            : m(r),
                            t.bindBuffer(34962, l),
                            x(r, i, c, e, o * h, u * h);
                        } else
                          s.isInstancedBufferAttribute
                            ? (f(r, s.meshPerAttribute),
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                s.meshPerAttribute * s.count))
                            : m(r),
                            t.bindBuffer(34962, l),
                            x(r, i, c, e, 0, 0);
                      } else if ("instanceMatrix" === e) {
                        const e = n.get(i.instanceMatrix);
                        if (void 0 === e) continue;
                        const s = e.buffer,
                          o = e.type;
                        f(r + 0, 1),
                          f(r + 1, 1),
                          f(r + 2, 1),
                          f(r + 3, 1),
                          t.bindBuffer(34962, s),
                          t.vertexAttribPointer(r + 0, 4, o, !1, 64, 0),
                          t.vertexAttribPointer(r + 1, 4, o, !1, 64, 16),
                          t.vertexAttribPointer(r + 2, 4, o, !1, 64, 32),
                          t.vertexAttribPointer(r + 3, 4, o, !1, 64, 48);
                      } else if ("instanceColor" === e) {
                        const e = n.get(i.instanceColor);
                        if (void 0 === e) continue;
                        const s = e.buffer,
                          o = e.type;
                        f(r, 1),
                          t.bindBuffer(34962, s),
                          t.vertexAttribPointer(r, 3, o, !1, 12, 0);
                      } else if (void 0 !== h) {
                        const n = h[e];
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              t.vertexAttrib2fv(r, n);
                              break;
                            case 3:
                              t.vertexAttrib3fv(r, n);
                              break;
                            case 4:
                              t.vertexAttrib4fv(r, n);
                              break;
                            default:
                              t.vertexAttrib1fv(r, n);
                          }
                      }
                    }
                  }
                  g();
                })(i, l, u, v),
                  null !== y && t.bindBuffer(34963, n.get(y).buffer));
            },
            reset: v,
            resetDefaultState: y,
            dispose: function () {
              v();
              for (const t in a) {
                const e = a[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) u(n[t].object), delete n[t];
                  delete e[t];
                }
                delete a[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === a[t.id]) return;
              const e = a[t.id];
              for (const n in e) {
                const t = e[n];
                for (const e in t) u(t[e].object), delete t[e];
                delete e[n];
              }
              delete a[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in a) {
                const n = a[e];
                if (void 0 === n[t.id]) continue;
                const r = n[t.id];
                for (const t in r) u(r[t].object), delete r[t];
                delete n[t.id];
              }
            },
            initAttributes: d,
            enableAttribute: m,
            disableUnusedAttributes: g,
          };
        }
        function Ll(t, e, n, r) {
          const i = r.isWebGL2;
          let s;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.render = function (e, r) {
              t.drawArrays(s, e, r), n.update(r, s, 1);
            }),
            (this.renderInstances = function (r, o, a) {
              if (0 === a) return;
              let l, c;
              if (i) (l = t), (c = "drawArraysInstanced");
              else if (
                ((c = "drawArraysInstancedANGLE"),
                  null === (l = e.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              l[c](s, r, o, a), n.update(o, s, a);
            });
        }
        function Rl(t, e, n) {
          let r;
          function i(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                t.getShaderPrecisionFormat(35632, 36338).precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36337).precision > 0
              ? "mediump"
              : "lowp";
          }
          const s =
            ("undefined" != typeof WebGL2RenderingContext &&
              t instanceof WebGL2RenderingContext) ||
            ("undefined" != typeof WebGL2ComputeRenderingContext &&
              t instanceof WebGL2ComputeRenderingContext);
          let o = void 0 !== n.precision ? n.precision : "highp";
          const a = i(o);
          a !== o &&
            (console.warn(
              "THREE.WebGLRenderer:",
              o,
              "not supported, using",
              a,
              "instead."
            ),
              (o = a));
          const l = s || e.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            h = t.getParameter(34930),
            u = t.getParameter(35660),
            p = t.getParameter(3379),
            d = t.getParameter(34076),
            m = t.getParameter(34921),
            f = t.getParameter(36347),
            g = t.getParameter(36348),
            x = t.getParameter(36349),
            v = u > 0,
            y = s || e.has("OES_texture_float");
          return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
              if (void 0 !== r) return r;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else r = 0;
              return r;
            },
            getMaxPrecision: i,
            precision: o,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: p,
            maxCubemapSize: d,
            maxAttributes: m,
            maxVertexUniforms: f,
            maxVaryings: g,
            maxFragmentUniforms: x,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? t.getParameter(36183) : 0,
          };
        }
        function Cl(t) {
          const e = this;
          let n = null,
            r = 0,
            i = !1,
            s = !1;
          const o = new bi(),
            a = new or(),
            l = { value: null, needsUpdate: !1 };
          function c() {
            l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
              (e.numPlanes = r),
              (e.numIntersection = 0);
          }
          function h(t, n, r, i) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
              if (((c = l.value), !0 !== i || null === c)) {
                const e = r + 4 * s,
                  i = n.matrixWorldInverse;
                a.getNormalMatrix(i),
                  (null === c || c.length < e) && (c = new Float32Array(e));
                for (let n = 0, l = r; n !== s; ++n, l += 4)
                  o.copy(t[n]).applyMatrix4(i, a),
                    o.normal.toArray(c, l),
                    (c[l + 3] = o.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e, s) {
              const o = 0 !== t.length || e || 0 !== r || i;
              return (i = e), (n = h(t, s, 0)), (r = t.length), o;
            }),
            (this.beginShadows = function () {
              (s = !0), h(null);
            }),
            (this.endShadows = function () {
              (s = !1), c();
            }),
            (this.setState = function (e, o, a) {
              const u = e.clippingPlanes,
                p = e.clipIntersection,
                d = e.clipShadows,
                m = t.get(e);
              if (!i || null === u || 0 === u.length || (s && !d))
                s ? h(null) : c();
              else {
                const t = s ? 0 : r,
                  e = 4 * t;
                let i = m.clippingState || null;
                (l.value = i), (i = h(u, o, e, a));
                for (let r = 0; r !== e; ++r) i[r] = n[r];
                (m.clippingState = i),
                  (this.numIntersection = p ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function Pl(t) {
          let e = new WeakMap();
          function n(t, e) {
            return (
              e === it ? (t.mapping = nt) : e === st && (t.mapping = rt), t
            );
          }
          function r(t) {
            const n = t.target;
            n.removeEventListener("dispose", r);
            const i = e.get(n);
            void 0 !== i && (e.delete(n), i.dispose());
          }
          return {
            get: function (i) {
              if (i && i.isTexture) {
                const s = i.mapping;
                if (s === it || s === st) {
                  if (e.has(i)) return n(e.get(i).texture, i.mapping);
                  {
                    const s = i.image;
                    if (s && s.height > 0) {
                      const o = t.getRenderTarget(),
                        a = new Ys(s.height / 2);
                      return (
                        a.fromEquirectangularTexture(t, i),
                        e.set(i, a),
                        t.setRenderTarget(o),
                        i.addEventListener("dispose", r),
                        n(a.texture, i.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return i;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function Dl(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let r;
            switch (n) {
              case "WEBGL_depth_texture":
                r =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                r =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                r =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                r =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                r = t.getExtension(n);
            }
            return (e[n] = r), r;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? n("EXT_color_buffer_float")
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                console.warn(
                  "THREE.WebGLRenderer: " + t + " extension not supported."
                ),
                e
              );
            },
          };
        }
        function Il(t, e, n, r) {
          const i = {},
            s = new WeakMap();
          function o(t) {
            const a = t.target;
            null !== a.index && e.remove(a.index);
            for (const n in a.attributes) e.remove(a.attributes[n]);
            a.removeEventListener("dispose", o), delete i[a.id];
            const l = s.get(a);
            l && (e.remove(l), s.delete(a)),
              r.releaseStatesOfGeometry(a),
              !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
              n.memory.geometries--;
          }
          function a(t) {
            const n = [],
              r = t.index,
              i = t.attributes.position;
            let o = 0;
            if (null !== r) {
              const t = r.array;
              o = r.version;
              for (let e = 0, r = t.length; e < r; e += 3) {
                const r = t[e + 0],
                  i = t[e + 1],
                  s = t[e + 2];
                n.push(r, i, i, s, s, r);
              }
            } else {
              const t = i.array;
              o = i.version;
              for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
                const t = e + 0,
                  r = e + 1,
                  i = e + 2;
                n.push(t, r, r, i, i, t);
              }
            }
            const a = new (is(n) > 65535 ? ts : Ki)(n, 1);
            a.version = o;
            const l = s.get(t);
            l && e.remove(l), s.set(t, a);
          }
          return {
            get: function (t, e) {
              return !0 === i[e.id]
                ? e
                : (e.addEventListener("dispose", o),
                  (i[e.id] = !0),
                  n.memory.geometries++,
                  e);
            },
            update: function (t) {
              const n = t.attributes;
              for (const i in n) e.update(n[i], 34962);
              const r = t.morphAttributes;
              for (const i in r) {
                const t = r[i];
                for (let n = 0, r = t.length; n < r; n++) e.update(t[n], 34962);
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && a(t);
              } else a(t);
              return s.get(t);
            },
          };
        }
        function Bl(t, e, n, r) {
          const i = r.isWebGL2;
          let s, o, a;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.setIndex = function (t) {
              (o = t.type), (a = t.bytesPerElement);
            }),
            (this.render = function (e, r) {
              t.drawElements(s, r, o, e * a), n.update(r, s, 1);
            }),
            (this.renderInstances = function (r, l, c) {
              if (0 === c) return;
              let h, u;
              if (i) (h = t), (u = "drawElementsInstanced");
              else if (
                ((u = "drawElementsInstancedANGLE"),
                  null === (h = e.get("ANGLE_instanced_arrays")))
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              h[u](s, l, o, r * a, c), n.update(l, s, c);
            });
        }
        function Fl(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              e.frame++,
                (e.calls = 0),
                (e.triangles = 0),
                (e.points = 0),
                (e.lines = 0);
            },
            update: function (t, n, r) {
              switch ((e.calls++, n)) {
                case 4:
                  e.triangles += r * (t / 3);
                  break;
                case 1:
                  e.lines += r * (t / 2);
                  break;
                case 3:
                  e.lines += r * (t - 1);
                  break;
                case 2:
                  e.lines += r * t;
                  break;
                case 0:
                  e.points += r * t;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", n);
              }
            },
          };
        }
        function Nl(t, e) {
          return t[0] - e[0];
        }
        function Gl(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function zl(t) {
          const e = {},
            n = new Float32Array(8),
            r = [];
          for (let i = 0; i < 8; i++) r[i] = [i, 0];
          return {
            update: function (i, s, o, a) {
              const l = i.morphTargetInfluences,
                c = void 0 === l ? 0 : l.length;
              let h = e[s.id];
              if (void 0 === h) {
                h = [];
                for (let t = 0; t < c; t++) h[t] = [t, 0];
                e[s.id] = h;
              }
              for (let t = 0; t < c; t++) {
                const e = h[t];
                (e[0] = t), (e[1] = l[t]);
              }
              h.sort(Gl);
              for (let t = 0; t < 8; t++)
                t < c && h[t][1]
                  ? ((r[t][0] = h[t][0]), (r[t][1] = h[t][1]))
                  : ((r[t][0] = Number.MAX_SAFE_INTEGER), (r[t][1] = 0));
              r.sort(Nl);
              const u = o.morphTargets && s.morphAttributes.position,
                p = o.morphNormals && s.morphAttributes.normal;
              let d = 0;
              for (let t = 0; t < 8; t++) {
                const e = r[t],
                  i = e[0],
                  o = e[1];
                i !== Number.MAX_SAFE_INTEGER && o
                  ? (u &&
                    s.getAttribute("morphTarget" + t) !== u[i] &&
                    s.setAttribute("morphTarget" + t, u[i]),
                    p &&
                    s.getAttribute("morphNormal" + t) !== p[i] &&
                    s.setAttribute("morphNormal" + t, p[i]),
                    (n[t] = o),
                    (d += o))
                  : (u &&
                    !0 === s.hasAttribute("morphTarget" + t) &&
                    s.deleteAttribute("morphTarget" + t),
                    p &&
                    !0 === s.hasAttribute("morphNormal" + t) &&
                    s.deleteAttribute("morphNormal" + t),
                    (n[t] = 0));
              }
              const m = s.morphTargetsRelative ? 1 : 1 - d;
              a.getUniforms().setValue(t, "morphTargetBaseInfluence", m),
                a.getUniforms().setValue(t, "morphTargetInfluences", n);
            },
          };
        }
        function Ol(t, e, n, r) {
          let i = new WeakMap();
          function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (t) {
              const o = r.render.frame,
                a = t.geometry,
                l = e.get(t, a);
              return (
                i.get(l) !== o && (e.update(l), i.set(l, o)),
                t.isInstancedMesh &&
                (!1 === t.hasEventListener("dispose", s) &&
                  t.addEventListener("dispose", s),
                  n.update(t.instanceMatrix, 34962),
                  null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
              );
            },
            dispose: function () {
              i = new WeakMap();
            },
          };
        }
        (exports.ShaderLib = Tl),
          (Tl.physical = {
            uniforms: Gs([
              Tl.standard.uniforms,
              {
                clearcoat: { value: 0 },
                clearcoatMap: { value: null },
                clearcoatRoughness: { value: 0 },
                clearcoatRoughnessMap: { value: null },
                clearcoatNormalScale: { value: new sr(1, 1) },
                clearcoatNormalMap: { value: null },
                sheen: { value: new Vi(0) },
                transmission: { value: 0 },
                transmissionMap: { value: null },
                transmissionSamplerSize: { value: new sr() },
                transmissionSamplerMap: { value: null },
                thickness: { value: 0 },
                thicknessMap: { value: null },
                attenuationDistance: { value: 0 },
                attenuationColor: { value: new Vi(0) },
              },
            ]),
            vertexShader: bl.meshphysical_vert,
            fragmentShader: bl.meshphysical_frag,
          });
        class Hl extends hr {
          constructor(t = null, e = 1, n = 1, r = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: r }),
              (this.magFilter = ut),
              (this.minFilter = ut),
              (this.wrapR = ct),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        (exports.DataTexture2DArray = Hl),
          (Hl.prototype.isDataTexture2DArray = !0);
        class Ul extends hr {
          constructor(t = null, e = 1, n = 1, r = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: r }),
              (this.magFilter = ut),
              (this.minFilter = ut),
              (this.wrapR = ct),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        (exports.DataTexture3D = Ul), (Ul.prototype.isDataTexture3D = !0);
        const kl = new hr(),
          Vl = new Hl(),
          Wl = new Ul(),
          jl = new Xs(),
          ql = [],
          Xl = [],
          Yl = new Float32Array(16),
          Zl = new Float32Array(9),
          Jl = new Float32Array(4);
        function Ql(t, e, n) {
          const r = t[0];
          if (r <= 0 || r > 0) return t;
          const i = e * n;
          let s = ql[i];
          if (
            (void 0 === s && ((s = new Float32Array(i)), (ql[i] = s)), 0 !== e)
          ) {
            r.toArray(s, 0);
            for (let r = 1, i = 0; r !== e; ++r) (i += n), t[r].toArray(s, i);
          }
          return s;
        }
        function Kl(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, r = t.length; n < r; n++)
            if (t[n] !== e[n]) return !1;
          return !0;
        }
        function $l(t, e) {
          for (let n = 0, r = e.length; n < r; n++) t[n] = e[n];
        }
        function tc(t, e) {
          let n = Xl[e];
          void 0 === n && ((n = new Int32Array(e)), (Xl[e] = n));
          for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
          return n;
        }
        function ec(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function nc(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (Kl(n, e)) return;
            t.uniform2fv(this.addr, e), $l(n, e);
          }
        }
        function rc(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z),
                (n[0] = e.x),
                (n[1] = e.y),
                (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b),
                (n[0] = e.r),
                (n[1] = e.g),
                (n[2] = e.b));
          else {
            if (Kl(n, e)) return;
            t.uniform3fv(this.addr, e), $l(n, e);
          }
        }
        function ic(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                (n[0] = e.x),
                (n[1] = e.y),
                (n[2] = e.z),
                (n[3] = e.w));
          else {
            if (Kl(n, e)) return;
            t.uniform4fv(this.addr, e), $l(n, e);
          }
        }
        function sc(t, e) {
          const n = this.cache,
            r = e.elements;
          if (void 0 === r) {
            if (Kl(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), $l(n, e);
          } else {
            if (Kl(n, r)) return;
            Jl.set(r), t.uniformMatrix2fv(this.addr, !1, Jl), $l(n, r);
          }
        }
        function oc(t, e) {
          const n = this.cache,
            r = e.elements;
          if (void 0 === r) {
            if (Kl(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), $l(n, e);
          } else {
            if (Kl(n, r)) return;
            Zl.set(r), t.uniformMatrix3fv(this.addr, !1, Zl), $l(n, r);
          }
        }
        function ac(t, e) {
          const n = this.cache,
            r = e.elements;
          if (void 0 === r) {
            if (Kl(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), $l(n, e);
          } else {
            if (Kl(n, r)) return;
            Yl.set(r), t.uniformMatrix4fv(this.addr, !1, Yl), $l(n, r);
          }
        }
        function lc(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function cc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform2iv(this.addr, e), $l(n, e));
        }
        function hc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform3iv(this.addr, e), $l(n, e));
        }
        function uc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform4iv(this.addr, e), $l(n, e));
        }
        function pc(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function dc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform2uiv(this.addr, e), $l(n, e));
        }
        function mc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform3uiv(this.addr, e), $l(n, e));
        }
        function fc(t, e) {
          const n = this.cache;
          Kl(n, e) || (t.uniform4uiv(this.addr, e), $l(n, e));
        }
        function gc(t, e, n) {
          const r = this.cache,
            i = n.allocateTextureUnit();
          r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
            n.safeSetTexture2D(e || kl, i);
        }
        function xc(t, e, n) {
          const r = this.cache,
            i = n.allocateTextureUnit();
          r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
            n.setTexture3D(e || Wl, i);
        }
        function vc(t, e, n) {
          const r = this.cache,
            i = n.allocateTextureUnit();
          r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
            n.safeSetTextureCube(e || jl, i);
        }
        function yc(t, e, n) {
          const r = this.cache,
            i = n.allocateTextureUnit();
          r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
            n.setTexture2DArray(e || Vl, i);
        }
        function _c(t) {
          switch (t) {
            case 5126:
              return ec;
            case 35664:
              return nc;
            case 35665:
              return rc;
            case 35666:
              return ic;
            case 35674:
              return sc;
            case 35675:
              return oc;
            case 35676:
              return ac;
            case 5124:
            case 35670:
              return lc;
            case 35667:
            case 35671:
              return cc;
            case 35668:
            case 35672:
              return hc;
            case 35669:
            case 35673:
              return uc;
            case 5125:
              return pc;
            case 36294:
              return dc;
            case 36295:
              return mc;
            case 36296:
              return fc;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return gc;
            case 35679:
            case 36299:
            case 36307:
              return xc;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return vc;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return yc;
          }
        }
        function Mc(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function wc(t, e) {
          const n = Ql(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function bc(t, e) {
          const n = Ql(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function Sc(t, e) {
          const n = Ql(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function Tc(t, e) {
          const n = Ql(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function Ec(t, e) {
          const n = Ql(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function Ac(t, e) {
          const n = Ql(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function Lc(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function Rc(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function Cc(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function Pc(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function Dc(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function Ic(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function Bc(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function Fc(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function Nc(t, e, n) {
          const r = e.length,
            i = tc(n, r);
          t.uniform1iv(this.addr, i);
          for (let s = 0; s !== r; ++s) n.safeSetTexture2D(e[s] || kl, i[s]);
        }
        function Gc(t, e, n) {
          const r = e.length,
            i = tc(n, r);
          t.uniform1iv(this.addr, i);
          for (let s = 0; s !== r; ++s) n.safeSetTextureCube(e[s] || jl, i[s]);
        }
        function zc(t) {
          switch (t) {
            case 5126:
              return Mc;
            case 35664:
              return wc;
            case 35665:
              return bc;
            case 35666:
              return Sc;
            case 35674:
              return Tc;
            case 35675:
              return Ec;
            case 35676:
              return Ac;
            case 5124:
            case 35670:
              return Lc;
            case 35667:
            case 35671:
              return Rc;
            case 35668:
            case 35672:
              return Cc;
            case 35669:
            case 35673:
              return Pc;
            case 5125:
              return Dc;
            case 36294:
              return Ic;
            case 36295:
              return Bc;
            case 36296:
              return Fc;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Nc;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Gc;
          }
        }
        function Oc(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = _c(e.type));
        }
        function Hc(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = zc(e.type));
        }
        function Uc(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        (Hc.prototype.updateCache = function (t) {
          const e = this.cache;
          t instanceof Float32Array &&
            e.length !== t.length &&
            (this.cache = new Float32Array(t.length)),
            $l(e, t);
        }),
          (Uc.prototype.setValue = function (t, e, n) {
            const r = this.seq;
            for (let i = 0, s = r.length; i !== s; ++i) {
              const s = r[i];
              s.setValue(t, e[s.id], n);
            }
          });
        const kc = /(\w+)(\])?(\[|\.)?/g;
        function Vc(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function Wc(t, e, n) {
          const r = t.name,
            i = r.length;
          for (kc.lastIndex = 0; ;) {
            const s = kc.exec(r),
              o = kc.lastIndex;
            let a = s[1];
            const l = "]" === s[2],
              c = s[3];
            if ((l && (a |= 0), void 0 === c || ("[" === c && o + 2 === i))) {
              Vc(n, void 0 === c ? new Oc(a, t, e) : new Hc(a, t, e));
              break;
            }
            {
              let t = n.map[a];
              void 0 === t && Vc(n, (t = new Uc(a))), (n = t);
            }
          }
        }
        function jc(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, 35718);
          for (let r = 0; r < n; ++r) {
            const n = t.getActiveUniform(e, r);
            Wc(n, t.getUniformLocation(e, n.name), this);
          }
        }
        function qc(t, e, n) {
          const r = t.createShader(e);
          return t.shaderSource(r, n), t.compileShader(r), r;
        }
        (jc.prototype.setValue = function (t, e, n, r) {
          const i = this.map[e];
          void 0 !== i && i.setValue(t, n, r);
        }),
          (jc.prototype.setOptional = function (t, e, n) {
            const r = e[n];
            void 0 !== r && this.setValue(t, n, r);
          }),
          (jc.upload = function (t, e, n, r) {
            for (let i = 0, s = e.length; i !== s; ++i) {
              const s = e[i],
                o = n[s.id];
              !1 !== o.needsUpdate && s.setValue(t, o.value, r);
            }
          }),
          (jc.seqWithValue = function (t, e) {
            const n = [];
            for (let r = 0, i = t.length; r !== i; ++r) {
              const i = t[r];
              i.id in e && n.push(i);
            }
            return n;
          });
        let Xc = 0;
        function Yc(t) {
          const e = t.split("\n");
          for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
          return e.join("\n");
        }
        function Zc(t) {
          switch (t) {
            case Xe:
              return ["Linear", "( value )"];
            case Ye:
              return ["sRGB", "( value )"];
            case Je:
              return ["RGBE", "( value )"];
            case Ke:
              return ["RGBM", "( value, 7.0 )"];
            case $e:
              return ["RGBM", "( value, 16.0 )"];
            case tn:
              return ["RGBD", "( value, 256.0 )"];
            case Ze:
              return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case Qe:
              return ["LogLuv", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
              );
          }
        }
        function Jc(t, e, n) {
          const r = t.getShaderParameter(e, 35713),
            i = t.getShaderInfoLog(e).trim();
          return r && "" === i
            ? ""
            : "THREE.WebGLShader: gl.getShaderInfoLog() " +
            n +
            "\n" +
            i +
            Yc(t.getShaderSource(e));
        }
        function Qc(t, e) {
          const n = Zc(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return " +
            n[0] +
            "ToLinear" +
            n[1] +
            "; }"
          );
        }
        function Kc(t, e) {
          const n = Zc(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return LinearTo" +
            n[0] +
            n[1] +
            "; }"
          );
        }
        function $c(t, e) {
          let n;
          switch (e) {
            case J:
              n = "Linear";
              break;
            case Q:
              n = "Reinhard";
              break;
            case K:
              n = "OptimizedCineon";
              break;
            case $:
              n = "ACESFilmic";
              break;
            case tt:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                (n = "Linear");
          }
          return (
            "vec3 " +
            t +
            "( vec3 color ) { return " +
            n +
            "ToneMapping( color ); }"
          );
        }
        function th(t) {
          return [
            t.extensionDerivatives ||
              t.envMapCubeUV ||
              t.bumpMap ||
              t.tangentSpaceNormalMap ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              "physical" === t.shaderID
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) &&
              t.rendererExtensionShaderTextureLod
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(rh)
            .join("\n");
        }
        function eh(t) {
          const e = [];
          for (const n in t) {
            const r = t[n];
            !1 !== r && e.push("#define " + n + " " + r);
          }
          return e.join("\n");
        }
        function nh(t, e) {
          const n = {},
            r = t.getProgramParameter(e, 35721);
          for (let i = 0; i < r; i++) {
            const r = t.getActiveAttrib(e, i).name;
            n[r] = t.getAttribLocation(e, r);
          }
          return n;
        }
        function rh(t) {
          return "" !== t;
        }
        function ih(t, e) {
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function sh(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              e.numClippingPlanes - e.numClipIntersection
            );
        }
        const oh = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function ah(t) {
          return t.replace(oh, lh);
        }
        function lh(t, e) {
          const n = bl[e];
          if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
          return ah(n);
        }
        const ch =
          /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          hh =
            /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function uh(t) {
          return t.replace(hh, dh).replace(ch, ph);
        }
        function ph(t, e, n, r) {
          return (
            console.warn(
              "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
            ),
            dh(t, e, n, r)
          );
        }
        function dh(t, e, n, r) {
          let i = "";
          for (let s = parseInt(e); s < parseInt(n); s++)
            i += r
              .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
              .replace(/UNROLLED_LOOP_INDEX/g, s);
          return i;
        }
        function mh(t) {
          let e =
            "precision " +
            t.precision +
            " float;\nprecision " +
            t.precision +
            " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
                ? (e += "\n#define MEDIUM_PRECISION")
                : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function fh(t) {
          let e = "SHADOWMAP_TYPE_BASIC";
          return (
            t.shadowMapType === l
              ? (e = "SHADOWMAP_TYPE_PCF")
              : t.shadowMapType === c
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        }
        function gh(t) {
          let e = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (t.envMapMode) {
              case nt:
              case rt:
                e = "ENVMAP_TYPE_CUBE";
                break;
              case ot:
              case at:
                e = "ENVMAP_TYPE_CUBE_UV";
            }
          return e;
        }
        function xh(t) {
          let e = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (t.envMapMode) {
              case rt:
              case at:
                e = "ENVMAP_MODE_REFRACTION";
            }
          return e;
        }
        function vh(t) {
          let e = "ENVMAP_BLENDING_NONE";
          if (t.envMap)
            switch (t.combine) {
              case q:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case X:
                e = "ENVMAP_BLENDING_MIX";
                break;
              case Y:
                e = "ENVMAP_BLENDING_ADD";
            }
          return e;
        }
        function yh(t, e, n, r) {
          const i = t.getContext(),
            s = n.defines;
          let o = n.vertexShader,
            a = n.fragmentShader;
          const l = fh(n),
            c = gh(n),
            h = xh(n),
            u = vh(n),
            p = t.gammaFactor > 0 ? t.gammaFactor : 1,
            d = n.isWebGL2 ? "" : th(n),
            m = eh(s),
            f = i.createProgram();
          let g,
            x,
            v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((g = [m].filter(rh).join("\n")).length > 0 && (g += "\n"),
              (x = [d, m].filter(rh).join("\n")).length > 0 && (x += "\n"))
            : ((g = [
              mh(n),
              "#define SHADER_NAME " + n.shaderName,
              m,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
              "#define GAMMA_FACTOR " + p,
              "#define MAX_BONES " + n.maxBones,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + h : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMap && n.objectSpaceNormalMap
                ? "#define OBJECTSPACE_NORMALMAP"
                : "",
              n.normalMap && n.tangentSpaceNormalMap
                ? "#define TANGENTSPACE_NORMALMAP"
                : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.displacementMap && n.supportsVertexTextures
                ? "#define USE_DISPLACEMENTMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents ? "#define USE_TANGENT" : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUvs ? "#define USE_UV" : "",
              n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.useVertexTexture ? "#define BONE_TEXTURE" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + l : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_MORPHTARGETS",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(rh)
              .join("\n")),
              (x = [
                d,
                mh(n),
                "#define SHADER_NAME " + n.shaderName,
                m,
                n.alphaTest
                  ? "#define ALPHATEST " +
                  n.alphaTest +
                  (n.alphaTest % 1 ? "" : ".0")
                  : "",
                "#define GAMMA_FACTOR " + p,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + c : "",
                n.envMap ? "#define " + h : "",
                n.envMap ? "#define " + u : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.transmission ? "#define USE_TRANSMISSION" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + l : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                (n.extensionShaderTextureLOD || n.envMap) &&
                  n.rendererExtensionShaderTextureLod
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                n.toneMapping !== Z ? "#define TONE_MAPPING" : "",
                n.toneMapping !== Z ? bl.tonemapping_pars_fragment : "",
                n.toneMapping !== Z ? $c("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                bl.encodings_pars_fragment,
                n.map ? Qc("mapTexelToLinear", n.mapEncoding) : "",
                n.matcap ? Qc("matcapTexelToLinear", n.matcapEncoding) : "",
                n.envMap ? Qc("envMapTexelToLinear", n.envMapEncoding) : "",
                n.emissiveMap
                  ? Qc("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                  : "",
                n.lightMap
                  ? Qc("lightMapTexelToLinear", n.lightMapEncoding)
                  : "",
                Kc("linearToOutputTexel", n.outputEncoding),
                n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(rh)
                .join("\n"))),
            (o = sh((o = ih((o = ah(o)), n)), n)),
            (a = sh((a = ih((a = ah(a)), n)), n)),
            (o = uh(o)),
            (a = uh(a)),
            n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((v = "#version 300 es\n"),
              (g =
                [
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                g),
              (x =
                [
                  "#define varying in",
                  n.glslVersion === Dn ? "" : "out highp vec4 pc_fragColor;",
                  n.glslVersion === Dn
                    ? ""
                    : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                x));
          const y = v + x + a,
            _ = qc(i, 35633, v + g + o),
            M = qc(i, 35632, y);
          if (
            (i.attachShader(f, _),
              i.attachShader(f, M),
              void 0 !== n.index0AttributeName
                ? i.bindAttribLocation(f, 0, n.index0AttributeName)
                : !0 === n.morphTargets && i.bindAttribLocation(f, 0, "position"),
              i.linkProgram(f),
              t.debug.checkShaderErrors)
          ) {
            const t = i.getProgramInfoLog(f).trim(),
              e = i.getShaderInfoLog(_).trim(),
              n = i.getShaderInfoLog(M).trim();
            let r = !0,
              s = !0;
            if (!1 === i.getProgramParameter(f, 35714)) {
              r = !1;
              const e = Jc(i, _, "vertex"),
                n = Jc(i, M, "fragment");
              console.error(
                "THREE.WebGLProgram: shader error: ",
                i.getError(),
                "35715",
                i.getProgramParameter(f, 35715),
                "gl.getProgramInfoLog",
                t,
                e,
                n
              );
            } else
              "" !== t
                ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
                : ("" !== e && "" !== n) || (s = !1);
            s &&
              (this.diagnostics = {
                runnable: r,
                programLog: t,
                vertexShader: { log: e, prefix: g },
                fragmentShader: { log: n, prefix: x },
              });
          }
          let w, b;
          return (
            i.deleteShader(_),
            i.deleteShader(M),
            (this.getUniforms = function () {
              return void 0 === w && (w = new jc(i, f)), w;
            }),
            (this.getAttributes = function () {
              return void 0 === b && (b = nh(i, f)), b;
            }),
            (this.destroy = function () {
              r.releaseStatesOfProgram(this),
                i.deleteProgram(f),
                (this.program = void 0);
            }),
            (this.name = n.shaderName),
            (this.id = Xc++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = f),
            (this.vertexShader = _),
            (this.fragmentShader = M),
            this
          );
        }
        function _h(t, e, n, r, i, s) {
          const o = [],
            a = r.isWebGL2,
            l = r.logarithmicDepthBuffer,
            c = r.floatVertexTextures,
            h = r.maxVertexUniforms,
            u = r.vertexTextures;
          let m = r.precision;
          const f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite",
          },
            g = [
              "precision",
              "isWebGL2",
              "supportsVertexTextures",
              "outputEncoding",
              "instancing",
              "instancingColor",
              "map",
              "mapEncoding",
              "matcap",
              "matcapEncoding",
              "envMap",
              "envMapMode",
              "envMapEncoding",
              "envMapCubeUV",
              "lightMap",
              "lightMapEncoding",
              "aoMap",
              "emissiveMap",
              "emissiveMapEncoding",
              "bumpMap",
              "normalMap",
              "objectSpaceNormalMap",
              "tangentSpaceNormalMap",
              "clearcoatMap",
              "clearcoatRoughnessMap",
              "clearcoatNormalMap",
              "displacementMap",
              "specularMap",
              "roughnessMap",
              "metalnessMap",
              "gradientMap",
              "alphaMap",
              "combine",
              "vertexColors",
              "vertexAlphas",
              "vertexTangents",
              "vertexUvs",
              "uvsVertexOnly",
              "fog",
              "useFog",
              "fogExp2",
              "flatShading",
              "sizeAttenuation",
              "logarithmicDepthBuffer",
              "skinning",
              "maxBones",
              "useVertexTexture",
              "morphTargets",
              "morphNormals",
              "premultipliedAlpha",
              "numDirLights",
              "numPointLights",
              "numSpotLights",
              "numHemiLights",
              "numRectAreaLights",
              "numDirLightShadows",
              "numPointLightShadows",
              "numSpotLightShadows",
              "shadowMapEnabled",
              "shadowMapType",
              "toneMapping",
              "physicallyCorrectLights",
              "alphaTest",
              "doubleSided",
              "flipSided",
              "numClippingPlanes",
              "numClipIntersection",
              "depthPacking",
              "dithering",
              "sheen",
              "transmission",
              "transmissionMap",
              "thicknessMap",
            ];
          function x(t) {
            let e;
            return (
              t && t.isTexture
                ? (e = t.encoding)
                : t && t.isWebGLRenderTarget
                  ? (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                    (e = t.texture.encoding))
                  : (e = Xe),
              e
            );
          }
          return {
            getParameters: function (i, o, g, v, y) {
              const _ = v.fog,
                M = i.isMeshStandardMaterial ? v.environment : null,
                w = e.get(i.envMap || M),
                b = f[i.type],
                S = y.isSkinnedMesh
                  ? (function (t) {
                    const e = t.skeleton.bones;
                    if (c) return 1024;
                    {
                      const t = h,
                        n = Math.floor((t - 20) / 4),
                        r = Math.min(n, e.length);
                      return r < e.length
                        ? (console.warn(
                          "THREE.WebGLRenderer: Skeleton has " +
                          e.length +
                          " bones. This GPU supports " +
                          r +
                          "."
                        ),
                          0)
                        : r;
                    }
                  })(y)
                  : 0;
              let T, E;
              if (
                (null !== i.precision &&
                  (m = r.getMaxPrecision(i.precision)) !== i.precision &&
                  console.warn(
                    "THREE.WebGLProgram.getParameters:",
                    i.precision,
                    "not supported, using",
                    m,
                    "instead."
                  ),
                  b)
              ) {
                const t = Tl[b];
                (T = t.vertexShader), (E = t.fragmentShader);
              } else (T = i.vertexShader), (E = i.fragmentShader);
              const A = t.getRenderTarget();
              return {
                isWebGL2: a,
                shaderID: b,
                shaderName: i.type,
                vertexShader: T,
                fragmentShader: E,
                defines: i.defines,
                isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                glslVersion: i.glslVersion,
                precision: m,
                instancing: !0 === y.isInstancedMesh,
                instancingColor:
                  !0 === y.isInstancedMesh && null !== y.instanceColor,
                supportsVertexTextures: u,
                outputEncoding: null !== A ? x(A.texture) : t.outputEncoding,
                map: !!i.map,
                mapEncoding: x(i.map),
                matcap: !!i.matcap,
                matcapEncoding: x(i.matcap),
                envMap: !!w,
                envMapMode: w && w.mapping,
                envMapEncoding: x(w),
                envMapCubeUV: !!w && (w.mapping === ot || w.mapping === at),
                lightMap: !!i.lightMap,
                lightMapEncoding: x(i.lightMap),
                aoMap: !!i.aoMap,
                emissiveMap: !!i.emissiveMap,
                emissiveMapEncoding: x(i.emissiveMap),
                bumpMap: !!i.bumpMap,
                normalMap: !!i.normalMap,
                objectSpaceNormalMap: i.normalMapType === sn,
                tangentSpaceNormalMap: i.normalMapType === rn,
                clearcoatMap: !!i.clearcoatMap,
                clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                clearcoatNormalMap: !!i.clearcoatNormalMap,
                displacementMap: !!i.displacementMap,
                roughnessMap: !!i.roughnessMap,
                metalnessMap: !!i.metalnessMap,
                specularMap: !!i.specularMap,
                alphaMap: !!i.alphaMap,
                gradientMap: !!i.gradientMap,
                sheen: !!i.sheen,
                transmission: !!i.transmission,
                transmissionMap: !!i.transmissionMap,
                thicknessMap: !!i.thicknessMap,
                combine: i.combine,
                vertexTangents: i.normalMap && i.vertexTangents,
                vertexColors: i.vertexColors,
                vertexAlphas:
                  !0 === i.vertexColors &&
                  y.geometry &&
                  y.geometry.attributes.color &&
                  4 === y.geometry.attributes.color.itemSize,
                vertexUvs: !!(
                  i.map ||
                  i.bumpMap ||
                  i.normalMap ||
                  i.specularMap ||
                  i.alphaMap ||
                  i.emissiveMap ||
                  i.roughnessMap ||
                  i.metalnessMap ||
                  i.clearcoatMap ||
                  i.clearcoatRoughnessMap ||
                  i.clearcoatNormalMap ||
                  i.displacementMap ||
                  i.transmission ||
                  i.transmissionMap ||
                  i.thicknessMap
                ),
                uvsVertexOnly: !(
                  i.map ||
                  i.bumpMap ||
                  i.normalMap ||
                  i.specularMap ||
                  i.alphaMap ||
                  i.emissiveMap ||
                  i.roughnessMap ||
                  i.metalnessMap ||
                  i.clearcoatNormalMap ||
                  i.transmission ||
                  i.transmissionMap ||
                  i.thicknessMap ||
                  !i.displacementMap
                ),
                fog: !!_,
                useFog: i.fog,
                fogExp2: _ && _.isFogExp2,
                flatShading: !!i.flatShading,
                sizeAttenuation: i.sizeAttenuation,
                logarithmicDepthBuffer: l,
                skinning: !0 === y.isSkinnedMesh && S > 0,
                maxBones: S,
                useVertexTexture: c,
                morphTargets: i.morphTargets,
                morphNormals: i.morphNormals,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numClippingPlanes: s.numPlanes,
                numClipIntersection: s.numIntersection,
                dithering: i.dithering,
                shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: i.toneMapped ? t.toneMapping : Z,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: i.premultipliedAlpha,
                alphaTest: i.alphaTest,
                doubleSided: i.side === d,
                flipSided: i.side === p,
                depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                index0AttributeName: i.index0AttributeName,
                extensionDerivatives: i.extensions && i.extensions.derivatives,
                extensionFragDepth: i.extensions && i.extensions.fragDepth,
                extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  i.extensions && i.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod:
                  a || n.has("EXT_shader_texture_lod"),
                customProgramCacheKey: i.customProgramCacheKey(),
              };
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                  void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < g.length; t++) n.push(e[g[t]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor);
              }
              return n.push(e.customProgramCacheKey), n.join();
            },
            getUniforms: function (t) {
              const e = f[t.type];
              let n;
              if (e) {
                const t = Tl[e];
                n = zs.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let r;
              for (let t = 0, i = o.length; t < i; t++) {
                const e = o[t];
                if (e.cacheKey === n) {
                  ++(r = e).usedTimes;
                  break;
                }
              }
              return void 0 === r && ((r = new yh(t, n, e, i)), o.push(r)), r;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = o.indexOf(t);
                (o[e] = o[o.length - 1]), o.pop(), t.destroy();
              }
            },
            programs: o,
          };
        }
        function Mh() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, r) {
              t.get(e)[n] = r;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function wh(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
              ? t.renderOrder - e.renderOrder
              : t.program !== e.program
                ? t.program.id - e.program.id
                : t.material.id !== e.material.id
                  ? t.material.id - e.material.id
                  : t.z !== e.z
                    ? t.z - e.z
                    : t.id - e.id;
        }
        function bh(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
              ? t.renderOrder - e.renderOrder
              : t.z !== e.z
                ? e.z - t.z
                : t.id - e.id;
        }
        function Sh(t) {
          const e = [];
          let n = 0;
          const r = [],
            i = [],
            s = [],
            o = { id: -1 };
          function a(r, i, s, a, l, c) {
            let h = e[n];
            const u = t.get(s);
            return (
              void 0 === h
                ? ((h = {
                  id: r.id,
                  object: r,
                  geometry: i,
                  material: s,
                  program: u.program || o,
                  groupOrder: a,
                  renderOrder: r.renderOrder,
                  z: l,
                  group: c,
                }),
                  (e[n] = h))
                : ((h.id = r.id),
                  (h.object = r),
                  (h.geometry = i),
                  (h.material = s),
                  (h.program = u.program || o),
                  (h.groupOrder = a),
                  (h.renderOrder = r.renderOrder),
                  (h.z = l),
                  (h.group = c)),
              n++,
              h
            );
          }
          return {
            opaque: r,
            transmissive: i,
            transparent: s,
            init: function () {
              (n = 0), (r.length = 0), (i.length = 0), (s.length = 0);
            },
            push: function (t, e, n, o, l, c) {
              const h = a(t, e, n, o, l, c);
              n.transmission > 0
                ? i.push(h)
                : !0 === n.transparent
                  ? s.push(h)
                  : r.push(h);
            },
            unshift: function (t, e, n, o, l, c) {
              const h = a(t, e, n, o, l, c);
              n.transmission > 0
                ? i.unshift(h)
                : !0 === n.transparent
                  ? s.unshift(h)
                  : r.unshift(h);
            },
            finish: function () {
              for (let t = n, r = e.length; t < r; t++) {
                const n = e[t];
                if (null === n.id) break;
                (n.id = null),
                  (n.object = null),
                  (n.geometry = null),
                  (n.material = null),
                  (n.program = null),
                  (n.group = null);
              }
            },
            sort: function (t, e) {
              r.length > 1 && r.sort(t || wh),
                i.length > 1 && i.sort(e || bh),
                s.length > 1 && s.sort(e || bh);
            },
          };
        }
        function Th(t) {
          let e = new WeakMap();
          return {
            get: function (n, r) {
              let i;
              return (
                !1 === e.has(n)
                  ? ((i = new Sh(t)), e.set(n, [i]))
                  : r >= e.get(n).length
                    ? ((i = new Sh(t)), e.get(n).push(i))
                    : (i = e.get(n)[r]),
                i
              );
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function Eh() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = { direction: new xr(), color: new Vi() };
                  break;
                case "SpotLight":
                  n = {
                    position: new xr(),
                    direction: new xr(),
                    color: new Vi(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = {
                    position: new xr(),
                    color: new Vi(),
                    distance: 0,
                    decay: 0,
                  };
                  break;
                case "HemisphereLight":
                  n = {
                    direction: new xr(),
                    skyColor: new Vi(),
                    groundColor: new Vi(),
                  };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new Vi(),
                    position: new xr(),
                    halfWidth: new xr(),
                    halfHeight: new xr(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        function Ah() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new sr(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new sr(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let Lh = 0;
        function Rh(t, e) {
          return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
        }
        function Ch(t, e) {
          const n = new Eh(),
            r = Ah(),
            i = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            };
          for (let l = 0; l < 9; l++) i.probe.push(new xr());
          const s = new xr(),
            o = new Yr(),
            a = new Yr();
          return {
            setup: function (s) {
              let o = 0,
                a = 0,
                l = 0;
              for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
              let c = 0,
                h = 0,
                u = 0,
                p = 0,
                d = 0,
                m = 0,
                f = 0,
                g = 0;
              s.sort(Rh);
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  x = e.color,
                  v = e.intensity,
                  y = e.distance,
                  _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight)
                  (o += x.r * v), (a += x.g * v), (l += x.b * v);
                else if (e.isLightProbe)
                  for (let t = 0; t < 9; t++)
                    i.probe[t].addScaledVector(e.sh.coefficients[t], v);
                else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                      e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = r.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (i.directionalShadow[c] = n),
                      (i.directionalShadowMap[c] = _),
                      (i.directionalShadowMatrix[c] = e.shadow.matrix),
                      m++;
                  }
                  (i.directional[c] = t), c++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  if (
                    (t.position.setFromMatrixPosition(e.matrixWorld),
                      t.color.copy(x).multiplyScalar(v),
                      (t.distance = y),
                      (t.coneCos = Math.cos(e.angle)),
                      (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                      (t.decay = e.decay),
                      e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = r.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (i.spotShadow[u] = n),
                      (i.spotShadowMap[u] = _),
                      (i.spotShadowMatrix[u] = e.shadow.matrix),
                      g++;
                  }
                  (i.spot[u] = t), u++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(x).multiplyScalar(v),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (i.rectArea[p] = t),
                    p++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                      (t.distance = e.distance),
                      (t.decay = e.decay),
                      e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = r.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (i.pointShadow[h] = n),
                      (i.pointShadowMap[h] = _),
                      (i.pointShadowMatrix[h] = e.shadow.matrix),
                      f++;
                  }
                  (i.point[h] = t), h++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(v),
                    t.groundColor.copy(e.groundColor).multiplyScalar(v),
                    (i.hemi[d] = t),
                    d++;
                }
              }
              p > 0 &&
                (e.isWebGL2
                  ? ((i.rectAreaLTC1 = Sl.LTC_FLOAT_1),
                    (i.rectAreaLTC2 = Sl.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_float_linear")
                    ? ((i.rectAreaLTC1 = Sl.LTC_FLOAT_1),
                      (i.rectAreaLTC2 = Sl.LTC_FLOAT_2))
                    : !0 === t.has("OES_texture_half_float_linear")
                      ? ((i.rectAreaLTC1 = Sl.LTC_HALF_1),
                        (i.rectAreaLTC2 = Sl.LTC_HALF_2))
                      : console.error(
                        "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                      )),
                (i.ambient[0] = o),
                (i.ambient[1] = a),
                (i.ambient[2] = l);
              const x = i.hash;
              (x.directionalLength === c &&
                x.pointLength === h &&
                x.spotLength === u &&
                x.rectAreaLength === p &&
                x.hemiLength === d &&
                x.numDirectionalShadows === m &&
                x.numPointShadows === f &&
                x.numSpotShadows === g) ||
                ((i.directional.length = c),
                  (i.spot.length = u),
                  (i.rectArea.length = p),
                  (i.point.length = h),
                  (i.hemi.length = d),
                  (i.directionalShadow.length = m),
                  (i.directionalShadowMap.length = m),
                  (i.pointShadow.length = f),
                  (i.pointShadowMap.length = f),
                  (i.spotShadow.length = g),
                  (i.spotShadowMap.length = g),
                  (i.directionalShadowMatrix.length = m),
                  (i.pointShadowMatrix.length = f),
                  (i.spotShadowMatrix.length = g),
                  (x.directionalLength = c),
                  (x.pointLength = h),
                  (x.spotLength = u),
                  (x.rectAreaLength = p),
                  (x.hemiLength = d),
                  (x.numDirectionalShadows = m),
                  (x.numPointShadows = f),
                  (x.numSpotShadows = g),
                  (i.version = Lh++));
            },
            setupView: function (t, e) {
              let n = 0,
                r = 0,
                l = 0,
                c = 0,
                h = 0;
              const u = e.matrixWorldInverse;
              for (let p = 0, d = t.length; p < d; p++) {
                const e = t[p];
                if (e.isDirectionalLight) {
                  const t = i.directional[n];
                  t.direction.setFromMatrixPosition(e.matrixWorld),
                    s.setFromMatrixPosition(e.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    n++;
                } else if (e.isSpotLight) {
                  const t = i.spot[l];
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.position.applyMatrix4(u),
                    t.direction.setFromMatrixPosition(e.matrixWorld),
                    s.setFromMatrixPosition(e.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    l++;
                } else if (e.isRectAreaLight) {
                  const t = i.rectArea[c];
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.position.applyMatrix4(u),
                    a.identity(),
                    o.copy(e.matrixWorld),
                    o.premultiply(u),
                    a.extractRotation(o),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    t.halfWidth.applyMatrix4(a),
                    t.halfHeight.applyMatrix4(a),
                    c++;
                } else if (e.isPointLight) {
                  const t = i.point[r];
                  t.position.setFromMatrixPosition(e.matrixWorld),
                    t.position.applyMatrix4(u),
                    r++;
                } else if (e.isHemisphereLight) {
                  const t = i.hemi[h];
                  t.direction.setFromMatrixPosition(e.matrixWorld),
                    t.direction.transformDirection(u),
                    t.direction.normalize(),
                    h++;
                }
              }
            },
            state: i,
          };
        }
        function Ph(t, e) {
          const n = new Ch(t, e),
            r = [],
            i = [];
          return {
            init: function () {
              (r.length = 0), (i.length = 0);
            },
            state: { lightsArray: r, shadowsArray: i, lights: n },
            setupLights: function () {
              n.setup(r);
            },
            setupLightsView: function (t) {
              n.setupView(r, t);
            },
            pushLight: function (t) {
              r.push(t);
            },
            pushShadow: function (t) {
              i.push(t);
            },
          };
        }
        function Dh(t, e) {
          let n = new WeakMap();
          return {
            get: function (r, i = 0) {
              let s;
              return (
                !1 === n.has(r)
                  ? ((s = new Ph(t, e)), n.set(r, [s]))
                  : i >= n.get(r).length
                    ? ((s = new Ph(t, e)), n.get(r).push(s))
                    : (s = n.get(r)[i]),
                s
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class Ih extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = en),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        (exports.MeshDepthMaterial = Ih),
          (Ih.prototype.isMeshDepthMaterial = !0);
        class Bh extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshDistanceMaterial"),
              (this.referencePosition = new xr()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.referencePosition.copy(t.referencePosition),
              (this.nearDistance = t.nearDistance),
              (this.farDistance = t.farDistance),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        (exports.MeshDistanceMaterial = Bh),
          (Bh.prototype.isMeshDistanceMaterial = !0);
        var Fh =
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          Nh = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
        function Gh(t, e, n) {
          let r = new Qs();
          const i = new sr(),
            s = new sr(),
            o = new pr(),
            a = [],
            c = [],
            m = {},
            f = n.maxTextureSize,
            x = { 0: p, 1: u, 2: d },
            v = new Us({
              defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new sr() },
                radius: { value: 4 },
              },
              vertexShader: Nh,
              fragmentShader: Fh,
            }),
            y = v.clone();
          y.defines.HORIZONTAL_PASS = 1;
          const _ = new ms();
          _.setAttribute(
            "position",
            new Xi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const M = new Ds(_, v),
            w = this;
          function b(n, r) {
            const i = e.update(M);
            (v.uniforms.shadow_pass.value = n.map.texture),
              (v.uniforms.resolution.value = n.mapSize),
              (v.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(r, null, i, v, M, null),
              (y.uniforms.shadow_pass.value = n.mapPass.texture),
              (y.uniforms.resolution.value = n.mapSize),
              (y.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(r, null, i, y, M, null);
          }
          function S(t) {
            const e = t << 0;
            let n = a[e];
            return (
              void 0 === n &&
              ((n = new Ih({ depthPacking: nn, morphTargets: t })),
                (a[e] = n)),
              n
            );
          }
          function T(t) {
            const e = t << 0;
            let n = c[e];
            return (
              void 0 === n && ((n = new Bh({ morphTargets: t })), (c[e] = n)), n
            );
          }
          function E(e, n, r, i, s, o, a) {
            let l = null,
              c = S,
              u = e.customDepthMaterial;
            if (
              (!0 === i.isPointLight &&
                ((c = T), (u = e.customDistanceMaterial)),
                void 0 === u)
            ) {
              let t = !1;
              !0 === r.morphTargets &&
                (t =
                  n.morphAttributes &&
                  n.morphAttributes.position &&
                  n.morphAttributes.position.length > 0),
                (l = c(t));
            } else l = u;
            if (
              t.localClippingEnabled &&
              !0 === r.clipShadows &&
              0 !== r.clippingPlanes.length
            ) {
              const t = l.uuid,
                e = r.uuid;
              let n = m[t];
              void 0 === n && ((n = {}), (m[t] = n));
              let i = n[e];
              void 0 === i && ((i = l.clone()), (n[e] = i)), (l = i);
            }
            return (
              (l.visible = r.visible),
              (l.wireframe = r.wireframe),
              (l.side =
                a === h
                  ? null !== r.shadowSide
                    ? r.shadowSide
                    : r.side
                  : null !== r.shadowSide
                    ? r.shadowSide
                    : x[r.side]),
              (l.clipShadows = r.clipShadows),
              (l.clippingPlanes = r.clippingPlanes),
              (l.clipIntersection = r.clipIntersection),
              (l.wireframeLinewidth = r.wireframeLinewidth),
              (l.linewidth = r.linewidth),
              !0 === i.isPointLight &&
              !0 === l.isMeshDistanceMaterial &&
              (l.referencePosition.setFromMatrixPosition(i.matrixWorld),
                (l.nearDistance = s),
                (l.farDistance = o)),
              l
            );
          }
          function A(n, i, s, o, a) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(i.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && a === h)) &&
              (!n.frustumCulled || r.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                s.matrixWorldInverse,
                n.matrixWorld
              );
              const r = e.update(n),
                i = n.material;
              if (Array.isArray(i)) {
                const e = r.groups;
                for (let l = 0, c = e.length; l < c; l++) {
                  const c = e[l],
                    h = i[c.materialIndex];
                  if (h && h.visible) {
                    const e = E(n, r, h, o, s.near, s.far, a);
                    t.renderBufferDirect(s, null, r, e, n, c);
                  }
                }
              } else if (i.visible) {
                const e = E(n, r, i, o, s.near, s.far, a);
                t.renderBufferDirect(s, null, r, e, n, null);
              }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++) A(l[t], i, s, o, a);
          }
          (this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = l),
            (this.render = function (e, n, a) {
              if (!1 === w.enabled) return;
              if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
              if (0 === e.length) return;
              const l = t.getRenderTarget(),
                c = t.getActiveCubeFace(),
                u = t.getActiveMipmapLevel(),
                p = t.state;
              p.setBlending(g),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
              for (let d = 0, m = e.length; d < m; d++) {
                const l = e[d],
                  c = l.shadow;
                if (void 0 === c) {
                  console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                  continue;
                }
                if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
                i.copy(c.mapSize);
                const u = c.getFrameExtents();
                if (
                  (i.multiply(u),
                    s.copy(c.mapSize),
                    (i.x > f || i.y > f) &&
                    (i.x > f &&
                      ((s.x = Math.floor(f / u.x)),
                        (i.x = s.x * u.x),
                        (c.mapSize.x = s.x)),
                      i.y > f &&
                      ((s.y = Math.floor(f / u.y)),
                        (i.y = s.y * u.y),
                        (c.mapSize.y = s.y))),
                    null === c.map && !c.isPointLightShadow && this.type === h)
                ) {
                  const t = { minFilter: gt, magFilter: gt, format: Ft };
                  (c.map = new dr(i.x, i.y, t)),
                    (c.map.texture.name = l.name + ".shadowMap"),
                    (c.mapPass = new dr(i.x, i.y, t)),
                    c.camera.updateProjectionMatrix();
                }
                if (null === c.map) {
                  const t = { minFilter: ut, magFilter: ut, format: Ft };
                  (c.map = new dr(i.x, i.y, t)),
                    (c.map.texture.name = l.name + ".shadowMap"),
                    c.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(c.map), t.clear();
                const m = c.getViewportCount();
                for (let t = 0; t < m; t++) {
                  const e = c.getViewport(t);
                  o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                    p.viewport(o),
                    c.updateMatrices(l, t),
                    (r = c.getFrustum()),
                    A(n, a, c.camera, l, this.type);
                }
                c.isPointLightShadow || this.type !== h || b(c, a),
                  (c.needsUpdate = !1);
              }
              (w.needsUpdate = !1), t.setRenderTarget(l, c, u);
            });
        }
        function zh(t, e, n) {
          const o = n.isWebGL2;
          const a = new (function () {
            let e = !1;
            const n = new pr();
            let r = null;
            const i = new pr(0, 0, 0, 0);
            return {
              setMask: function (n) {
                r === n || e || (t.colorMask(n, n, n, n), (r = n));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e, r, s, o, a) {
                !0 === a && ((e *= o), (r *= o), (s *= o)),
                  n.set(e, r, s, o),
                  !1 === i.equals(n) && (t.clearColor(e, r, s, o), i.copy(n));
              },
              reset: function () {
                (e = !1), (r = null), i.set(-1, 0, 0, 0);
              },
            };
          })(),
            l = new (function () {
              let e = !1,
                n = null,
                r = null,
                i = null;
              return {
                setTest: function (t) {
                  t ? vt(2929) : yt(2929);
                },
                setMask: function (r) {
                  n === r || e || (t.depthMask(r), (n = r));
                },
                setFunc: function (e) {
                  if (r !== e) {
                    if (e)
                      switch (e) {
                        case z:
                          t.depthFunc(512);
                          break;
                        case O:
                          t.depthFunc(519);
                          break;
                        case H:
                          t.depthFunc(513);
                          break;
                        case U:
                          t.depthFunc(515);
                          break;
                        case k:
                          t.depthFunc(514);
                          break;
                        case V:
                          t.depthFunc(518);
                          break;
                        case W:
                          t.depthFunc(516);
                          break;
                        case j:
                          t.depthFunc(517);
                          break;
                        default:
                          t.depthFunc(515);
                      }
                    else t.depthFunc(515);
                    r = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  i !== e && (t.clearDepth(e), (i = e));
                },
                reset: function () {
                  (e = !1), (n = null), (r = null), (i = null);
                },
              };
            })(),
            c = new (function () {
              let e = !1,
                n = null,
                r = null,
                i = null,
                s = null,
                o = null,
                a = null,
                l = null,
                c = null;
              return {
                setTest: function (t) {
                  e || (t ? vt(2960) : yt(2960));
                },
                setMask: function (r) {
                  n === r || e || (t.stencilMask(r), (n = r));
                },
                setFunc: function (e, n, o) {
                  (r === e && i === n && s === o) ||
                    (t.stencilFunc(e, n, o), (r = e), (i = n), (s = o));
                },
                setOp: function (e, n, r) {
                  (o === e && a === n && l === r) ||
                    (t.stencilOp(e, n, r), (o = e), (a = n), (l = r));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (r = null),
                    (i = null),
                    (s = null),
                    (o = null),
                    (a = null),
                    (l = null),
                    (c = null);
                },
              };
            })();
          let h = {},
            u = null,
            m = {},
            f = null,
            q = !1,
            X = null,
            Y = null,
            Z = null,
            J = null,
            Q = null,
            K = null,
            $ = null,
            tt = !1,
            et = null,
            nt = null,
            rt = null,
            it = null,
            st = null;
          const ot = t.getParameter(35661);
          let at = !1,
            lt = 0;
          const ct = t.getParameter(7938);
          -1 !== ct.indexOf("WebGL")
            ? ((lt = parseFloat(/^WebGL (\d)/.exec(ct)[1])), (at = lt >= 1))
            : -1 !== ct.indexOf("OpenGL ES") &&
            ((lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1])),
              (at = lt >= 2));
          let ht = null,
            ut = {};
          const pt = t.getParameter(3088),
            dt = t.getParameter(2978),
            mt = new pr().fromArray(pt),
            ft = new pr().fromArray(dt);
          function gt(e, n, r) {
            const i = new Uint8Array(4),
              s = t.createTexture();
            t.bindTexture(e, s),
              t.texParameteri(e, 10241, 9728),
              t.texParameteri(e, 10240, 9728);
            for (let o = 0; o < r; o++)
              t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
            return s;
          }
          const xt = {};
          function vt(e) {
            !0 !== h[e] && (t.enable(e), (h[e] = !0));
          }
          function yt(e) {
            !1 !== h[e] && (t.disable(e), (h[e] = !1));
          }
          (xt[3553] = gt(3553, 3553, 1)),
            (xt[34067] = gt(34067, 34069, 6)),
            a.setClear(0, 0, 0, 1),
            l.setClear(1),
            c.setClear(0),
            vt(2929),
            l.setFunc(U),
            bt(!1),
            St(i),
            vt(2884),
            wt(g);
          const _t = { [w]: 32774, [b]: 32778, [S]: 32779 };
          if (o) (_t[T] = 32775), (_t[E] = 32776);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((_t[T] = t.MIN_EXT), (_t[E] = t.MAX_EXT));
          }
          const Mt = {
            [A]: 0,
            [L]: 1,
            [R]: 768,
            [P]: 770,
            [G]: 776,
            [F]: 774,
            [I]: 772,
            [C]: 769,
            [D]: 771,
            [N]: 775,
            [B]: 773,
          };
          function wt(e, n, r, i, s, o, a, l) {
            if (e !== g) {
              if ((!1 === q && (vt(3042), (q = !0)), e === M))
                (s = s || n),
                  (o = o || r),
                  (a = a || i),
                  (n === Y && s === Q) ||
                  (t.blendEquationSeparate(_t[n], _t[s]), (Y = n), (Q = s)),
                  (r === Z && i === J && o === K && a === $) ||
                  (t.blendFuncSeparate(Mt[r], Mt[i], Mt[o], Mt[a]),
                    (Z = r),
                    (J = i),
                    (K = o),
                    ($ = a)),
                  (X = e),
                  (tt = null);
              else if (e !== X || l !== tt) {
                if (
                  ((Y === w && Q === w) ||
                    (t.blendEquation(32774), (Y = w), (Q = w)),
                    l)
                )
                  switch (e) {
                    case x:
                      t.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case v:
                      t.blendFunc(1, 1);
                      break;
                    case y:
                      t.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case _:
                      t.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case x:
                      t.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case v:
                      t.blendFunc(770, 1);
                      break;
                    case y:
                      t.blendFunc(0, 769);
                      break;
                    case _:
                      t.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (Z = null),
                  (J = null),
                  (K = null),
                  ($ = null),
                  (X = e),
                  (tt = l);
              }
            } else !0 === q && (yt(3042), (q = !1));
          }
          function bt(e) {
            et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (et = e));
          }
          function St(e) {
            e !== r
              ? (vt(2884),
                e !== nt &&
                (e === i
                  ? t.cullFace(1029)
                  : e === s
                    ? t.cullFace(1028)
                    : t.cullFace(1032)))
              : yt(2884),
              (nt = e);
          }
          function Tt(e, n, r) {
            e
              ? (vt(32823),
                (it === n && st === r) ||
                (t.polygonOffset(n, r), (it = n), (st = r)))
              : yt(32823);
          }
          function Et(e) {
            void 0 === e && (e = 33984 + ot - 1),
              ht !== e && (t.activeTexture(e), (ht = e));
          }
          return {
            buffers: { color: a, depth: l, stencil: c },
            enable: vt,
            disable: yt,
            bindFramebuffer: function (e, n) {
              return (
                null === n && null !== u && (n = u),
                m[e] !== n &&
                (t.bindFramebuffer(e, n),
                  (m[e] = n),
                  o &&
                  (36009 === e && (m[36160] = n),
                    36160 === e && (m[36009] = n)),
                  !0)
              );
            },
            bindXRFramebuffer: function (e) {
              e !== u && (t.bindFramebuffer(36160, e), (u = e));
            },
            useProgram: function (e) {
              return f !== e && (t.useProgram(e), (f = e), !0);
            },
            setBlending: wt,
            setMaterial: function (t, e) {
              t.side === d ? yt(2884) : vt(2884);
              let n = t.side === p;
              e && (n = !n),
                bt(n),
                t.blending === x && !1 === t.transparent
                  ? wt(g)
                  : wt(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.premultipliedAlpha
                  ),
                l.setFunc(t.depthFunc),
                l.setTest(t.depthTest),
                l.setMask(t.depthWrite),
                a.setMask(t.colorWrite);
              const r = t.stencilWrite;
              c.setTest(r),
                r &&
                (c.setMask(t.stencilWriteMask),
                  c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                  c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                Tt(
                  t.polygonOffset,
                  t.polygonOffsetFactor,
                  t.polygonOffsetUnits
                ),
                !0 === t.alphaToCoverage ? vt(32926) : yt(32926);
            },
            setFlipSided: bt,
            setCullFace: St,
            setLineWidth: function (e) {
              e !== rt && (at && t.lineWidth(e), (rt = e));
            },
            setPolygonOffset: Tt,
            setScissorTest: function (t) {
              t ? vt(3089) : yt(3089);
            },
            activeTexture: Et,
            bindTexture: function (e, n) {
              null === ht && Et();
              let r = ut[ht];
              void 0 === r &&
                ((r = { type: void 0, texture: void 0 }), (ut[ht] = r)),
                (r.type === e && r.texture === n) ||
                (t.bindTexture(e, n || xt[e]), (r.type = e), (r.texture = n));
            },
            unbindTexture: function () {
              const e = ut[ht];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null),
                  (e.type = void 0),
                  (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (e) {
                console.error("THREE.WebGLState:", e);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (e) {
                console.error("THREE.WebGLState:", e);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (e) {
                console.error("THREE.WebGLState:", e);
              }
            },
            scissor: function (e) {
              !1 === mt.equals(e) &&
                (t.scissor(e.x, e.y, e.z, e.w), mt.copy(e));
            },
            viewport: function (e) {
              !1 === ft.equals(e) &&
                (t.viewport(e.x, e.y, e.z, e.w), ft.copy(e));
            },
            reset: function () {
              t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === o &&
                (t.bindFramebuffer(36009, null),
                  t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (h = {}),
                (ht = null),
                (ut = {}),
                (u = null),
                (m = {}),
                (f = null),
                (q = !1),
                (X = null),
                (Y = null),
                (Z = null),
                (J = null),
                (Q = null),
                (K = null),
                ($ = null),
                (tt = !1),
                (et = null),
                (nt = null),
                (rt = null),
                (it = null),
                (st = null),
                mt.set(0, 0, t.canvas.width, t.canvas.height),
                ft.set(0, 0, t.canvas.width, t.canvas.height),
                a.reset(),
                l.reset(),
                c.reset();
            },
          };
        }
        function Oh(t, e, n, r, i, s, o) {
          const a = i.isWebGL2,
            l = i.maxTextures,
            c = i.maxCubemapSize,
            h = i.maxTextureSize,
            u = i.maxSamples,
            p = new WeakMap();
          let d,
            m = !1;
          try {
            m =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (z) { }
          function f(t, e) {
            return m
              ? new OffscreenCanvas(t, e)
              : document.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "canvas"
              );
          }
          function g(t, e, n, r) {
            let i = 1;
            if (
              ((t.width > r || t.height > r) &&
                (i = r / Math.max(t.width, t.height)),
                i < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement &&
                  t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement &&
                  t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const r = e ? nr : Math.floor,
                  s = r(i * t.width),
                  o = r(i * t.height);
                void 0 === d && (d = f(s, o));
                const a = n ? f(s, o) : d;
                return (
                  (a.width = s),
                  (a.height = o),
                  a.getContext("2d").drawImage(t, 0, 0, s, o),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                    t.width +
                    "x" +
                    t.height +
                    ") to (" +
                    s +
                    "x" +
                    o +
                    ")."
                  ),
                  a
                );
              }
              return (
                "data" in t &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
                ),
                t
              );
            }
            return t;
          }
          function x(t) {
            return tr(t.width) && tr(t.height);
          }
          function v(t, e) {
            return (
              t.generateMipmaps && e && t.minFilter !== ut && t.minFilter !== gt
            );
          }
          function y(e, n, i, s) {
            t.generateMipmap(e),
              (r.get(n).__maxMipLevel = Math.log2(Math.max(i, s)));
          }
          function _(n, r, i) {
            if (!1 === a) return r;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
              );
            }
            let s = r;
            return (
              6403 === r &&
              (5126 === i && (s = 33326),
                5131 === i && (s = 33325),
                5121 === i && (s = 33321)),
              6407 === r &&
              (5126 === i && (s = 34837),
                5131 === i && (s = 34843),
                5121 === i && (s = 32849)),
              6408 === r &&
              (5126 === i && (s = 34836),
                5131 === i && (s = 34842),
                5121 === i && (s = 32856)),
              (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) ||
              e.get("EXT_color_buffer_float"),
              s
            );
          }
          function M(t) {
            return t === ut || t === pt || t === mt ? 9728 : 9729;
          }
          function w(e) {
            const n = e.target;
            n.removeEventListener("dispose", w),
              (function (e) {
                const n = r.get(e);
                if (void 0 === n.__webglInit) return;
                t.deleteTexture(n.__webglTexture), r.remove(e);
              })(n),
              n.isVideoTexture && p.delete(n),
              o.memory.textures--;
          }
          function b(e) {
            const n = e.target;
            n.removeEventListener("dispose", b),
              (function (e) {
                const n = e.texture,
                  i = r.get(e),
                  s = r.get(n);
                if (!e) return;
                void 0 !== s.__webglTexture &&
                  (t.deleteTexture(s.__webglTexture), o.memory.textures--);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                  for (let r = 0; r < 6; r++)
                    t.deleteFramebuffer(i.__webglFramebuffer[r]),
                      i.__webglDepthbuffer &&
                      t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
                else
                  t.deleteFramebuffer(i.__webglFramebuffer),
                    i.__webglDepthbuffer &&
                    t.deleteRenderbuffer(i.__webglDepthbuffer),
                    i.__webglMultisampledFramebuffer &&
                    t.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                    i.__webglColorRenderbuffer &&
                    t.deleteRenderbuffer(i.__webglColorRenderbuffer),
                    i.__webglDepthRenderbuffer &&
                    t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                if (e.isWebGLMultipleRenderTargets)
                  for (let a = 0, l = n.length; a < l; a++) {
                    const e = r.get(n[a]);
                    e.__webglTexture &&
                      (t.deleteTexture(e.__webglTexture), o.memory.textures--),
                      r.remove(n[a]);
                  }
                r.remove(n), r.remove(e);
              })(n);
          }
          let S = 0;
          function T(t, e) {
            const i = r.get(t);
            if (
              (t.isVideoTexture &&
                (function (t) {
                  const e = o.render.frame;
                  p.get(t) !== e && (p.set(t, e), t.update());
                })(t),
                t.version > 0 && i.__version !== t.version)
            ) {
              const n = t.image;
              if (void 0 === n)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                );
              else {
                if (!1 !== n.complete) return void P(i, t, e);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture);
          }
          function E(e, i) {
            const o = r.get(e);
            e.version > 0 && o.__version !== e.version
              ? (function (e, r, i) {
                if (6 !== r.image.length) return;
                C(e, r),
                  n.activeTexture(33984 + i),
                  n.bindTexture(34067, e.__webglTexture),
                  t.pixelStorei(37440, r.flipY),
                  t.pixelStorei(37441, r.premultiplyAlpha),
                  t.pixelStorei(3317, r.unpackAlignment),
                  t.pixelStorei(37443, 0);
                const o =
                  r &&
                  (r.isCompressedTexture || r.image[0].isCompressedTexture),
                  l = r.image[0] && r.image[0].isDataTexture,
                  h = [];
                for (let t = 0; t < 6; t++)
                  h[t] =
                    o || l
                      ? l
                        ? r.image[t].image
                        : r.image[t]
                      : g(r.image[t], !1, !0, c);
                const u = h[0],
                  p = x(u) || a,
                  d = s.convert(r.format),
                  m = s.convert(r.type),
                  f = _(r.internalFormat, d, m);
                let M;
                if ((R(34067, r, p), o)) {
                  for (let t = 0; t < 6; t++) {
                    M = h[t].mipmaps;
                    for (let e = 0; e < M.length; e++) {
                      const i = M[e];
                      r.format !== Ft && r.format !== Bt
                        ? null !== d
                          ? n.compressedTexImage2D(
                            34069 + t,
                            e,
                            f,
                            i.width,
                            i.height,
                            0,
                            i.data
                          )
                          : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                        : n.texImage2D(
                          34069 + t,
                          e,
                          f,
                          i.width,
                          i.height,
                          0,
                          d,
                          m,
                          i.data
                        );
                    }
                  }
                  e.__maxMipLevel = M.length - 1;
                } else {
                  M = r.mipmaps;
                  for (let t = 0; t < 6; t++)
                    if (l) {
                      n.texImage2D(
                        34069 + t,
                        0,
                        f,
                        h[t].width,
                        h[t].height,
                        0,
                        d,
                        m,
                        h[t].data
                      );
                      for (let e = 0; e < M.length; e++) {
                        const r = M[e],
                          i = r.image[t].image;
                        n.texImage2D(
                          34069 + t,
                          e + 1,
                          f,
                          i.width,
                          i.height,
                          0,
                          d,
                          m,
                          i.data
                        );
                      }
                    } else {
                      n.texImage2D(34069 + t, 0, f, d, m, h[t]);
                      for (let e = 0; e < M.length; e++) {
                        const r = M[e];
                        n.texImage2D(34069 + t, e + 1, f, d, m, r.image[t]);
                      }
                    }
                  e.__maxMipLevel = M.length;
                }
                v(r, p) && y(34067, r, u.width, u.height);
                (e.__version = r.version), r.onUpdate && r.onUpdate(r);
              })(o, e, i)
              : (n.activeTexture(33984 + i),
                n.bindTexture(34067, o.__webglTexture));
          }
          const A = { [lt]: 10497, [ct]: 33071, [ht]: 33648 },
            L = {
              [ut]: 9728,
              [pt]: 9984,
              [mt]: 9986,
              [gt]: 9729,
              [xt]: 9985,
              [yt]: 9987,
            };
          function R(n, s, o) {
            if (
              (o
                ? (t.texParameteri(n, 10242, A[s.wrapS]),
                  t.texParameteri(n, 10243, A[s.wrapT]),
                  (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, A[s.wrapR]),
                  t.texParameteri(n, 10240, L[s.magFilter]),
                  t.texParameteri(n, 10241, L[s.minFilter]))
                : (t.texParameteri(n, 10242, 33071),
                  t.texParameteri(n, 10243, 33071),
                  (32879 !== n && 35866 !== n) ||
                  t.texParameteri(n, 32882, 33071),
                  (s.wrapS === ct && s.wrapT === ct) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                  t.texParameteri(n, 10240, M(s.magFilter)),
                  t.texParameteri(n, 10241, M(s.minFilter)),
                  s.minFilter !== ut &&
                  s.minFilter !== gt &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
                !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const o = e.get("EXT_texture_filter_anisotropic");
              if (s.type === At && !1 === e.has("OES_texture_float_linear"))
                return;
              if (
                !1 === a &&
                s.type === Lt &&
                !1 === e.has("OES_texture_half_float_linear")
              )
                return;
              (s.anisotropy > 1 || r.get(s).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  o.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(s.anisotropy, i.getMaxAnisotropy())
                ),
                  (r.get(s).__currentAnisotropy = s.anisotropy));
            }
          }
          function C(e, n) {
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0),
                n.addEventListener("dispose", w),
                (e.__webglTexture = t.createTexture()),
                o.memory.textures++);
          }
          function P(e, r, i) {
            let o = 3553;
            r.isDataTexture2DArray && (o = 35866),
              r.isDataTexture3D && (o = 32879),
              C(e, r),
              n.activeTexture(33984 + i),
              n.bindTexture(o, e.__webglTexture),
              t.pixelStorei(37440, r.flipY),
              t.pixelStorei(37441, r.premultiplyAlpha),
              t.pixelStorei(3317, r.unpackAlignment),
              t.pixelStorei(37443, 0);
            const l =
              (function (t) {
                return (
                  !a &&
                  (t.wrapS !== ct ||
                    t.wrapT !== ct ||
                    (t.minFilter !== ut && t.minFilter !== gt))
                );
              })(r) && !1 === x(r.image),
              c = g(r.image, l, !1, h),
              u = x(c) || a,
              p = s.convert(r.format);
            let d,
              m = s.convert(r.type),
              f = _(r.internalFormat, p, m);
            R(o, r, u);
            const M = r.mipmaps;
            if (r.isDepthTexture)
              (f = 6402),
                a
                  ? (f =
                    r.type === At
                      ? 36012
                      : r.type === Et
                        ? 33190
                        : r.type === Dt
                          ? 35056
                          : 33189)
                  : r.type === At &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
                r.format === Ot &&
                6402 === f &&
                r.type !== St &&
                r.type !== Et &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                  (r.type = St),
                  (m = s.convert(r.type))),
                r.format === Ht &&
                6402 === f &&
                ((f = 34041),
                  r.type !== Dt &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                    (r.type = Dt),
                    (m = s.convert(r.type)))),
                n.texImage2D(3553, 0, f, c.width, c.height, 0, p, m, null);
            else if (r.isDataTexture)
              if (M.length > 0 && u) {
                for (let t = 0, e = M.length; t < e; t++)
                  (d = M[t]),
                    n.texImage2D(
                      3553,
                      t,
                      f,
                      d.width,
                      d.height,
                      0,
                      p,
                      m,
                      d.data
                    );
                (r.generateMipmaps = !1), (e.__maxMipLevel = M.length - 1);
              } else
                n.texImage2D(3553, 0, f, c.width, c.height, 0, p, m, c.data),
                  (e.__maxMipLevel = 0);
            else if (r.isCompressedTexture) {
              for (let t = 0, e = M.length; t < e; t++)
                (d = M[t]),
                  r.format !== Ft && r.format !== Bt
                    ? null !== p
                      ? n.compressedTexImage2D(
                        3553,
                        t,
                        f,
                        d.width,
                        d.height,
                        0,
                        d.data
                      )
                      : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                    : n.texImage2D(
                      3553,
                      t,
                      f,
                      d.width,
                      d.height,
                      0,
                      p,
                      m,
                      d.data
                    );
              e.__maxMipLevel = M.length - 1;
            } else if (r.isDataTexture2DArray)
              n.texImage3D(
                35866,
                0,
                f,
                c.width,
                c.height,
                c.depth,
                0,
                p,
                m,
                c.data
              ),
                (e.__maxMipLevel = 0);
            else if (r.isDataTexture3D)
              n.texImage3D(
                32879,
                0,
                f,
                c.width,
                c.height,
                c.depth,
                0,
                p,
                m,
                c.data
              ),
                (e.__maxMipLevel = 0);
            else if (M.length > 0 && u) {
              for (let t = 0, e = M.length; t < e; t++)
                (d = M[t]), n.texImage2D(3553, t, f, p, m, d);
              (r.generateMipmaps = !1), (e.__maxMipLevel = M.length - 1);
            } else n.texImage2D(3553, 0, f, p, m, c), (e.__maxMipLevel = 0);
            v(r, u) && y(o, r, c.width, c.height),
              (e.__version = r.version),
              r.onUpdate && r.onUpdate(r);
          }
          function D(e, i, o, a, l) {
            const c = s.convert(o.format),
              h = s.convert(o.type),
              u = _(o.internalFormat, c, h);
            32879 === l || 35866 === l
              ? n.texImage3D(l, 0, u, i.width, i.height, i.depth, 0, c, h, null)
              : n.texImage2D(l, 0, u, i.width, i.height, 0, c, h, null),
              n.bindFramebuffer(36160, e),
              t.framebufferTexture2D(36160, a, l, r.get(o).__webglTexture, 0),
              n.bindFramebuffer(36160, null);
          }
          function I(e, n, r) {
            if (
              (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
            ) {
              let i = 33189;
              if (r) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === At ? (i = 36012) : e.type === Et && (i = 33190));
                const r = F(n);
                t.renderbufferStorageMultisample(
                  36161,
                  r,
                  i,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, i, n.width, n.height);
              t.framebufferRenderbuffer(36160, 36096, 36161, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              if (r) {
                const e = F(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  35056,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, 34041, n.width, n.height);
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
            } else {
              const e =
                !0 === n.isWebGLMultipleRenderTargets
                  ? n.texture[0]
                  : n.texture,
                i = s.convert(e.format),
                o = s.convert(e.type),
                a = _(e.internalFormat, i, o);
              if (r) {
                const e = F(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  a,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, a, n.width, n.height);
            }
            t.bindRenderbuffer(36161, null);
          }
          function B(e) {
            const i = r.get(e),
              s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
              if (s)
                throw new Error(
                  "target.depthTexture not supported in Cube render targets"
                );
              !(function (e, i) {
                if (i && i.isWebGLCubeRenderTarget)
                  throw new Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                if (
                  (n.bindFramebuffer(36160, e),
                    !i.depthTexture || !i.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (r.get(i.depthTexture).__webglTexture &&
                  i.depthTexture.image.width === i.width &&
                  i.depthTexture.image.height === i.height) ||
                  ((i.depthTexture.image.width = i.width),
                    (i.depthTexture.image.height = i.height),
                    (i.depthTexture.needsUpdate = !0)),
                  T(i.depthTexture, 0);
                const s = r.get(i.depthTexture).__webglTexture;
                if (i.depthTexture.format === Ot)
                  t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                else {
                  if (i.depthTexture.format !== Ht)
                    throw new Error("Unknown depthTexture format");
                  t.framebufferTexture2D(36160, 33306, 3553, s, 0);
                }
              })(i.__webglFramebuffer, e);
            } else if (s) {
              i.__webglDepthbuffer = [];
              for (let r = 0; r < 6; r++)
                n.bindFramebuffer(36160, i.__webglFramebuffer[r]),
                  (i.__webglDepthbuffer[r] = t.createRenderbuffer()),
                  I(i.__webglDepthbuffer[r], e, !1);
            } else
              n.bindFramebuffer(36160, i.__webglFramebuffer),
                (i.__webglDepthbuffer = t.createRenderbuffer()),
                I(i.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(36160, null);
          }
          function F(t) {
            return a && t.isWebGLMultisampleRenderTarget
              ? Math.min(u, t.samples)
              : 0;
          }
          let N = !1,
            G = !1;
          (this.allocateTextureUnit = function () {
            const t = S;
            return (
              t >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l
              ),
              (S += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              S = 0;
            }),
            (this.setTexture2D = T),
            (this.setTexture2DArray = function (t, e) {
              const i = r.get(t);
              t.version > 0 && i.__version !== t.version
                ? P(i, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(35866, i.__webglTexture));
            }),
            (this.setTexture3D = function (t, e) {
              const i = r.get(t);
              t.version > 0 && i.__version !== t.version
                ? P(i, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(32879, i.__webglTexture));
            }),
            (this.setTextureCube = E),
            (this.setupRenderTarget = function (e) {
              const l = e.texture,
                c = r.get(e),
                h = r.get(l);
              e.addEventListener("dispose", b),
                !0 !== e.isWebGLMultipleRenderTargets &&
                ((h.__webglTexture = t.createTexture()),
                  (h.__version = l.version),
                  o.memory.textures++);
              const u = !0 === e.isWebGLCubeRenderTarget,
                p = !0 === e.isWebGLMultipleRenderTargets,
                d = !0 === e.isWebGLMultisampleRenderTarget,
                m = l.isDataTexture3D || l.isDataTexture2DArray,
                f = x(e) || a;
              if (
                (!a ||
                  l.format !== Bt ||
                  (l.type !== At && l.type !== Lt) ||
                  ((l.format = Ft),
                    console.warn(
                      "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                    )),
                  u)
              ) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  c.__webglFramebuffer[e] = t.createFramebuffer();
              } else if (((c.__webglFramebuffer = t.createFramebuffer()), p))
                if (i.drawBuffers) {
                  const n = e.texture;
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = r.get(n[e]);
                    void 0 === i.__webglTexture &&
                      ((i.__webglTexture = t.createTexture()),
                        o.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              else if (d)
                if (a) {
                  (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (c.__webglColorRenderbuffer = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                  const r = s.convert(l.format),
                    i = s.convert(l.type),
                    o = _(l.internalFormat, r, i),
                    a = F(e);
                  t.renderbufferStorageMultisample(
                    36161,
                    a,
                    o,
                    e.width,
                    e.height
                  ),
                    n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(
                      36160,
                      36064,
                      36161,
                      c.__webglColorRenderbuffer
                    ),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer &&
                    ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      I(c.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
              if (u) {
                n.bindTexture(34067, h.__webglTexture), R(34067, l, f);
                for (let t = 0; t < 6; t++)
                  D(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                v(l, f) && y(34067, l, e.width, e.height),
                  n.bindTexture(34067, null);
              } else if (p) {
                const t = e.texture;
                for (let i = 0, s = t.length; i < s; i++) {
                  const s = t[i],
                    o = r.get(s);
                  n.bindTexture(3553, o.__webglTexture),
                    R(3553, s, f),
                    D(c.__webglFramebuffer, e, s, 36064 + i, 3553),
                    v(s, f) && y(3553, s, e.width, e.height);
                }
                n.bindTexture(3553, null);
              } else {
                let t = 3553;
                m &&
                  (a
                    ? (t = l.isDataTexture3D ? 32879 : 35866)
                    : console.warn(
                      "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                    )),
                  n.bindTexture(t, h.__webglTexture),
                  R(t, l, f),
                  D(c.__webglFramebuffer, e, l, 36064, t),
                  v(l, f) && y(3553, l, e.width, e.height),
                  n.bindTexture(3553, null);
              }
              e.depthBuffer && B(e);
            }),
            (this.updateRenderTargetMipmap = function (t) {
              const e = x(t) || a,
                i =
                  !0 === t.isWebGLMultipleRenderTargets
                    ? t.texture
                    : [t.texture];
              for (let s = 0, o = i.length; s < o; s++) {
                const o = i[s];
                if (v(o, e)) {
                  const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                    i = r.get(o).__webglTexture;
                  n.bindTexture(e, i),
                    y(e, o, t.width, t.height),
                    n.bindTexture(e, null);
                }
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (e.isWebGLMultisampleRenderTarget)
                if (a) {
                  const i = e.width,
                    s = e.height;
                  let o = 16384;
                  e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
                  const a = r.get(e);
                  n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, a.__webglFramebuffer),
                    t.blitFramebuffer(0, 0, i, s, 0, 0, i, s, o, 9728),
                    n.bindFramebuffer(36008, null),
                    n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
            }),
            (this.safeSetTexture2D = function (t, e) {
              t &&
                t.isWebGLRenderTarget &&
                (!1 === N &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                  ),
                    (N = !0)),
                  (t = t.texture)),
                T(t, e);
            }),
            (this.safeSetTextureCube = function (t, e) {
              t &&
                t.isWebGLCubeRenderTarget &&
                (!1 === G &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                  ),
                    (G = !0)),
                  (t = t.texture)),
                E(t, e);
            });
        }
        function Hh(t, e, n) {
          const r = n.isWebGL2;
          return {
            convert: function (t) {
              let n;
              if (t === Mt) return 5121;
              if (t === Rt) return 32819;
              if (t === Ct) return 32820;
              if (t === Pt) return 33635;
              if (t === wt) return 5120;
              if (t === bt) return 5122;
              if (t === St) return 5123;
              if (t === Tt) return 5124;
              if (t === Et) return 5125;
              if (t === At) return 5126;
              if (t === Lt)
                return r
                  ? 5131
                  : null !== (n = e.get("OES_texture_half_float"))
                    ? n.HALF_FLOAT_OES
                    : null;
              if (t === It) return 6406;
              if (t === Bt) return 6407;
              if (t === Ft) return 6408;
              if (t === Nt) return 6409;
              if (t === Gt) return 6410;
              if (t === Ot) return 6402;
              if (t === Ht) return 34041;
              if (t === Ut) return 6403;
              if (t === kt) return 36244;
              if (t === Vt) return 33319;
              if (t === Wt) return 33320;
              if (t === jt) return 36248;
              if (t === qt) return 36249;
              if (t === Xt || t === Yt || t === Zt || t === Jt) {
                if (null === (n = e.get("WEBGL_compressed_texture_s3tc")))
                  return null;
                if (t === Xt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === Yt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
              if (t === Qt || t === Kt || t === $t || t === te) {
                if (null === (n = e.get("WEBGL_compressed_texture_pvrtc")))
                  return null;
                if (t === Qt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (t === Kt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (t === $t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (t === te) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (t === ee)
                return null !== (n = e.get("WEBGL_compressed_texture_etc1"))
                  ? n.COMPRESSED_RGB_ETC1_WEBGL
                  : null;
              if (
                (t === ne || t === re) &&
                null !== (n = e.get("WEBGL_compressed_texture_etc"))
              ) {
                if (t === ne) return n.COMPRESSED_RGB8_ETC2;
                if (t === re) return n.COMPRESSED_RGBA8_ETC2_EAC;
              }
              return t === ie ||
                t === se ||
                t === oe ||
                t === ae ||
                t === le ||
                t === ce ||
                t === he ||
                t === ue ||
                t === pe ||
                t === de ||
                t === me ||
                t === fe ||
                t === ge ||
                t === xe ||
                t === ye ||
                t === _e ||
                t === Me ||
                t === we ||
                t === be ||
                t === Se ||
                t === Te ||
                t === Ee ||
                t === Ae ||
                t === Le ||
                t === Re ||
                t === Ce ||
                t === Pe ||
                t === De
                ? null !== (n = e.get("WEBGL_compressed_texture_astc"))
                  ? t
                  : null
                : t === ve
                  ? null !== (n = e.get("EXT_texture_compression_bptc"))
                    ? t
                    : null
                  : t === Dt
                    ? r
                      ? 34042
                      : null !== (n = e.get("WEBGL_depth_texture"))
                        ? n.UNSIGNED_INT_24_8_WEBGL
                        : null
                    : void 0;
            },
          };
        }
        class Uh extends Vs {
          constructor(t = []) {
            super(), (this.cameras = t);
          }
        }
        (exports.ArrayCamera = Uh), (Uh.prototype.isArrayCamera = !0);
        class kh extends yi {
          constructor() {
            super(), (this.type = "Group");
          }
        }
        (exports.Group = kh), (kh.prototype.isGroup = !0);
        const Vh = { type: "move" };
        class Wh {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
              ((this._hand = new kh()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
              ((this._targetRay = new kh()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new xr()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new xr())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
              ((this._grip = new kh()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new xr()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new xr())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          disconnect(t) {
            return (
              this.dispatchEvent({ type: "disconnected", data: t }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let r = null,
              i = null,
              s = null;
            const o = this._targetRay,
              a = this._grip,
              l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
              if (
                (null !== o &&
                  null !== (r = e.getPose(t.targetRaySpace, n)) &&
                  (o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    r.linearVelocity
                      ? ((o.hasLinearVelocity = !0),
                        o.linearVelocity.copy(r.linearVelocity))
                      : (o.hasLinearVelocity = !1),
                    r.angularVelocity
                      ? ((o.hasAngularVelocity = !0),
                        o.angularVelocity.copy(r.angularVelocity))
                      : (o.hasAngularVelocity = !1),
                    this.dispatchEvent(Vh)),
                  l && t.hand)
              ) {
                s = !0;
                for (const s of t.hand.values()) {
                  const t = e.getJointPose(s, n);
                  if (void 0 === l.joints[s.jointName]) {
                    const t = new kh();
                    (t.matrixAutoUpdate = !1),
                      (t.visible = !1),
                      (l.joints[s.jointName] = t),
                      l.add(t);
                  }
                  const r = l.joints[s.jointName];
                  null !== t &&
                    (r.matrix.fromArray(t.transform.matrix),
                      r.matrix.decompose(r.position, r.rotation, r.scale),
                      (r.jointRadius = t.radius)),
                    (r.visible = null !== t);
                }
                const r = l.joints["index-finger-tip"],
                  i = l.joints["thumb-tip"],
                  o = r.position.distanceTo(i.position),
                  a = 0.02,
                  c = 0.005;
                l.inputState.pinching && o > a + c
                  ? ((l.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !l.inputState.pinching &&
                  o <= a - c &&
                  ((l.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== a &&
                  t.gripSpace &&
                  null !== (i = e.getPose(t.gripSpace, n)) &&
                  (a.matrix.fromArray(i.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    i.linearVelocity
                      ? ((a.hasLinearVelocity = !0),
                        a.linearVelocity.copy(i.linearVelocity))
                      : (a.hasLinearVelocity = !1),
                    i.angularVelocity
                      ? ((a.hasAngularVelocity = !0),
                        a.angularVelocity.copy(i.angularVelocity))
                      : (a.hasAngularVelocity = !1));
            return (
              null !== o && (o.visible = null !== r),
              null !== a && (a.visible = null !== i),
              null !== l && (l.visible = null !== s),
              this
            );
          }
        }
        class jh extends In {
          constructor(t, e) {
            super();
            const n = this,
              r = t.state;
            let i = null,
              s = 1,
              o = null,
              a = "local-floor",
              l = null;
            const c = [],
              h = new Map(),
              u = new Vs();
            u.layers.enable(1), (u.viewport = new pr());
            const p = new Vs();
            p.layers.enable(2), (p.viewport = new pr());
            const d = [u, p],
              m = new Uh();
            m.layers.enable(1), m.layers.enable(2);
            let f = null,
              g = null;
            function x(t) {
              const e = h.get(t.inputSource);
              e && e.dispatchEvent({ type: t.type, data: t.inputSource });
            }
            function v() {
              h.forEach(function (t, e) {
                t.disconnect(e);
              }),
                h.clear(),
                (f = null),
                (g = null),
                r.bindXRFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                S.stop(),
                (n.isPresenting = !1),
                n.dispatchEvent({ type: "sessionend" });
            }
            function y(t) {
              const e = i.inputSources;
              for (let n = 0; n < c.length; n++) h.set(e[n], c[n]);
              for (let n = 0; n < t.removed.length; n++) {
                const e = t.removed[n],
                  r = h.get(e);
                r &&
                  (r.dispatchEvent({ type: "disconnected", data: e }),
                    h.delete(e));
              }
              for (let n = 0; n < t.added.length; n++) {
                const e = t.added[n],
                  r = h.get(e);
                r && r.dispatchEvent({ type: "connected", data: e });
              }
            }
            (this.cameraAutoUpdate = !0),
              (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new Wh()), (c[t] = e)),
                  e.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new Wh()), (c[t] = e)), e.getGripSpace()
                );
              }),
              (this.getHand = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new Wh()), (c[t] = e)), e.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (s = t),
                  !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
              }),
              (this.setReferenceSpaceType = function (t) {
                (a = t),
                  !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
              }),
              (this.getReferenceSpace = function () {
                return o;
              }),
              (this.getSession = function () {
                return i;
              }),
              (this.setSession = async function (t) {
                if (null !== (i = t)) {
                  i.addEventListener("select", x),
                    i.addEventListener("selectstart", x),
                    i.addEventListener("selectend", x),
                    i.addEventListener("squeeze", x),
                    i.addEventListener("squeezestart", x),
                    i.addEventListener("squeezeend", x),
                    i.addEventListener("end", v),
                    i.addEventListener("inputsourceschange", y);
                  const t = e.getContextAttributes();
                  !0 !== t.xrCompatible && (await e.makeXRCompatible());
                  const r = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: s,
                  },
                    l = new XRWebGLLayer(i, e, r);
                  i.updateRenderState({ baseLayer: l }),
                    (o = await i.requestReferenceSpace(a)),
                    S.setContext(i),
                    S.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({ type: "sessionstart" });
                }
              });
            const _ = new xr(),
              M = new xr();
            function w(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            (this.updateCamera = function (t) {
              if (null === i) return;
              (m.near = p.near = u.near = t.near),
                (m.far = p.far = u.far = t.far),
                (f === m.near && g === m.far) ||
                (i.updateRenderState({ depthNear: m.near, depthFar: m.far }),
                  (f = m.near),
                  (g = m.far));
              const e = t.parent,
                n = m.cameras;
              w(m, e);
              for (let i = 0; i < n.length; i++) w(n[i], e);
              t.matrixWorld.copy(m.matrixWorld),
                t.matrix.copy(m.matrix),
                t.matrix.decompose(t.position, t.quaternion, t.scale);
              const r = t.children;
              for (let i = 0, s = r.length; i < s; i++)
                r[i].updateMatrixWorld(!0);
              2 === n.length
                ? (function (t, e, n) {
                  _.setFromMatrixPosition(e.matrixWorld),
                    M.setFromMatrixPosition(n.matrixWorld);
                  const r = _.distanceTo(M),
                    i = e.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    o = i[14] / (i[10] - 1),
                    a = i[14] / (i[10] + 1),
                    l = (i[9] + 1) / i[5],
                    c = (i[9] - 1) / i[5],
                    h = (i[8] - 1) / i[0],
                    u = (s[8] + 1) / s[0],
                    p = o * h,
                    d = o * u,
                    m = r / (-h + u),
                    f = m * -h;
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(f),
                    t.translateZ(m),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                  const g = o + m,
                    x = a + m,
                    v = p - f,
                    y = d + (r - f),
                    w = ((l * a) / x) * g,
                    b = ((c * a) / x) * g;
                  t.projectionMatrix.makePerspective(v, y, w, b, g, x);
                })(m, u, p)
                : m.projectionMatrix.copy(u.projectionMatrix);
            }),
              (this.getCamera = function () {
                return m;
              });
            let b = null;
            const S = new Ks();
            S.setAnimationLoop(function (t, e) {
              if (null !== (l = e.getViewerPose(o))) {
                const t = l.views,
                  e = i.renderState.baseLayer;
                r.bindXRFramebuffer(e.framebuffer);
                let n = !1;
                t.length !== m.cameras.length &&
                  ((m.cameras.length = 0), (n = !0));
                for (let r = 0; r < t.length; r++) {
                  const i = t[r],
                    s = e.getViewport(i),
                    o = d[r];
                  o.matrix.fromArray(i.transform.matrix),
                    o.projectionMatrix.fromArray(i.projectionMatrix),
                    o.viewport.set(s.x, s.y, s.width, s.height),
                    0 === r && m.matrix.copy(o.matrix),
                    !0 === n && m.cameras.push(o);
                }
              }
              const n = i.inputSources;
              for (let r = 0; r < c.length; r++) {
                const t = c[r],
                  i = n[r];
                t.update(i, e, o);
              }
              b && b(t, e);
            }),
              (this.setAnimationLoop = function (t) {
                b = t;
              }),
              (this.dispose = function () { });
          }
        }
        function qh(t) {
          function e(e, n) {
            (e.opacity.value = n.opacity),
              n.color && e.diffuse.value.copy(n.color),
              n.emissive &&
              e.emissive.value
                .copy(n.emissive)
                .multiplyScalar(n.emissiveIntensity),
              n.map && (e.map.value = n.map),
              n.alphaMap && (e.alphaMap.value = n.alphaMap),
              n.specularMap && (e.specularMap.value = n.specularMap);
            const r = t.get(n).envMap;
            if (r) {
              (e.envMap.value = r),
                (e.flipEnvMap.value =
                  r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1),
                (e.reflectivity.value = n.reflectivity),
                (e.refractionRatio.value = n.refractionRatio);
              const i = t.get(r).__maxMipLevel;
              void 0 !== i && (e.maxMipLevel.value = i);
            }
            let i, s;
            n.lightMap &&
              ((e.lightMap.value = n.lightMap),
                (e.lightMapIntensity.value = n.lightMapIntensity)),
              n.aoMap &&
              ((e.aoMap.value = n.aoMap),
                (e.aoMapIntensity.value = n.aoMapIntensity)),
              n.map
                ? (i = n.map)
                : n.specularMap
                  ? (i = n.specularMap)
                  : n.displacementMap
                    ? (i = n.displacementMap)
                    : n.normalMap
                      ? (i = n.normalMap)
                      : n.bumpMap
                        ? (i = n.bumpMap)
                        : n.roughnessMap
                          ? (i = n.roughnessMap)
                          : n.metalnessMap
                            ? (i = n.metalnessMap)
                            : n.alphaMap
                              ? (i = n.alphaMap)
                              : n.emissiveMap
                                ? (i = n.emissiveMap)
                                : n.clearcoatMap
                                  ? (i = n.clearcoatMap)
                                  : n.clearcoatNormalMap
                                    ? (i = n.clearcoatNormalMap)
                                    : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap),
              void 0 !== i &&
              (i.isWebGLRenderTarget && (i = i.texture),
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                e.uvTransform.value.copy(i.matrix)),
              n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
              void 0 !== s &&
              (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix));
          }
          function n(e, n) {
            (e.roughness.value = n.roughness),
              (e.metalness.value = n.metalness),
              n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
              n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
              n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
              n.bumpMap &&
              ((e.bumpMap.value = n.bumpMap),
                (e.bumpScale.value = n.bumpScale),
                n.side === p && (e.bumpScale.value *= -1)),
              n.normalMap &&
              ((e.normalMap.value = n.normalMap),
                e.normalScale.value.copy(n.normalScale),
                n.side === p && e.normalScale.value.negate()),
              n.displacementMap &&
              ((e.displacementMap.value = n.displacementMap),
                (e.displacementScale.value = n.displacementScale),
                (e.displacementBias.value = n.displacementBias)),
              t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
          }
          return {
            refreshFogUniforms: function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density);
            },
            refreshMaterialUniforms: function (t, r, i, s, o) {
              r.isMeshBasicMaterial
                ? e(t, r)
                : r.isMeshLambertMaterial
                  ? (e(t, r),
                    (function (t, e) {
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    })(t, r))
                  : r.isMeshToonMaterial
                    ? (e(t, r),
                      (function (t, e) {
                        e.gradientMap && (t.gradientMap.value = e.gradientMap),
                          e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                          e.bumpMap &&
                          ((t.bumpMap.value = e.bumpMap),
                            (t.bumpScale.value = e.bumpScale),
                            e.side === p && (t.bumpScale.value *= -1)),
                          e.normalMap &&
                          ((t.normalMap.value = e.normalMap),
                            t.normalScale.value.copy(e.normalScale),
                            e.side === p && t.normalScale.value.negate()),
                          e.displacementMap &&
                          ((t.displacementMap.value = e.displacementMap),
                            (t.displacementScale.value = e.displacementScale),
                            (t.displacementBias.value = e.displacementBias));
                      })(t, r))
                    : r.isMeshPhongMaterial
                      ? (e(t, r),
                        (function (t, e) {
                          t.specular.value.copy(e.specular),
                            (t.shininess.value = Math.max(e.shininess, 1e-4)),
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                            e.bumpMap &&
                            ((t.bumpMap.value = e.bumpMap),
                              (t.bumpScale.value = e.bumpScale),
                              e.side === p && (t.bumpScale.value *= -1)),
                            e.normalMap &&
                            ((t.normalMap.value = e.normalMap),
                              t.normalScale.value.copy(e.normalScale),
                              e.side === p && t.normalScale.value.negate()),
                            e.displacementMap &&
                            ((t.displacementMap.value = e.displacementMap),
                              (t.displacementScale.value = e.displacementScale),
                              (t.displacementBias.value = e.displacementBias));
                        })(t, r))
                      : r.isMeshStandardMaterial
                        ? (e(t, r),
                          r.isMeshPhysicalMaterial
                            ? (function (t, e, r) {
                              n(t, e),
                                (t.reflectivity.value = e.reflectivity),
                                (t.clearcoat.value = e.clearcoat),
                                (t.clearcoatRoughness.value = e.clearcoatRoughness),
                                e.sheen && t.sheen.value.copy(e.sheen),
                                e.clearcoatMap &&
                                (t.clearcoatMap.value = e.clearcoatMap),
                                e.clearcoatRoughnessMap &&
                                (t.clearcoatRoughnessMap.value =
                                  e.clearcoatRoughnessMap),
                                e.clearcoatNormalMap &&
                                (t.clearcoatNormalScale.value.copy(
                                  e.clearcoatNormalScale
                                ),
                                  (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                                  e.side === p &&
                                  t.clearcoatNormalScale.value.negate()),
                                (t.transmission.value = e.transmission),
                                e.transmissionMap &&
                                (t.transmissionMap.value = e.transmissionMap),
                                e.transmission > 0 &&
                                ((t.transmissionSamplerMap.value = r.texture),
                                  t.transmissionSamplerSize.value.set(
                                    r.width,
                                    r.height
                                  )),
                                (t.thickness.value = e.thickness),
                                e.thicknessMap &&
                                (t.thicknessMap.value = e.thicknessMap),
                                (t.attenuationDistance.value = e.attenuationDistance),
                                t.attenuationColor.value.copy(e.attenuationColor);
                            })(t, r, o)
                            : n(t, r))
                        : r.isMeshMatcapMaterial
                          ? (e(t, r),
                            (function (t, e) {
                              e.matcap && (t.matcap.value = e.matcap),
                                e.bumpMap &&
                                ((t.bumpMap.value = e.bumpMap),
                                  (t.bumpScale.value = e.bumpScale),
                                  e.side === p && (t.bumpScale.value *= -1)),
                                e.normalMap &&
                                ((t.normalMap.value = e.normalMap),
                                  t.normalScale.value.copy(e.normalScale),
                                  e.side === p && t.normalScale.value.negate()),
                                e.displacementMap &&
                                ((t.displacementMap.value = e.displacementMap),
                                  (t.displacementScale.value = e.displacementScale),
                                  (t.displacementBias.value = e.displacementBias));
                            })(t, r))
                          : r.isMeshDepthMaterial
                            ? (e(t, r),
                              (function (t, e) {
                                e.displacementMap &&
                                  ((t.displacementMap.value = e.displacementMap),
                                    (t.displacementScale.value = e.displacementScale),
                                    (t.displacementBias.value = e.displacementBias));
                              })(t, r))
                            : r.isMeshDistanceMaterial
                              ? (e(t, r),
                                (function (t, e) {
                                  e.displacementMap &&
                                    ((t.displacementMap.value = e.displacementMap),
                                      (t.displacementScale.value = e.displacementScale),
                                      (t.displacementBias.value = e.displacementBias)),
                                    t.referencePosition.value.copy(e.referencePosition),
                                    (t.nearDistance.value = e.nearDistance),
                                    (t.farDistance.value = e.farDistance);
                                })(t, r))
                              : r.isMeshNormalMaterial
                                ? (e(t, r),
                                  (function (t, e) {
                                    e.bumpMap &&
                                      ((t.bumpMap.value = e.bumpMap),
                                        (t.bumpScale.value = e.bumpScale),
                                        e.side === p && (t.bumpScale.value *= -1)),
                                      e.normalMap &&
                                      ((t.normalMap.value = e.normalMap),
                                        t.normalScale.value.copy(e.normalScale),
                                        e.side === p && t.normalScale.value.negate()),
                                      e.displacementMap &&
                                      ((t.displacementMap.value = e.displacementMap),
                                        (t.displacementScale.value = e.displacementScale),
                                        (t.displacementBias.value = e.displacementBias));
                                  })(t, r))
                                : r.isLineBasicMaterial
                                  ? ((function (t, e) {
                                    t.diffuse.value.copy(e.color),
                                      (t.opacity.value = e.opacity);
                                  })(t, r),
                                    r.isLineDashedMaterial &&
                                    (function (t, e) {
                                      (t.dashSize.value = e.dashSize),
                                        (t.totalSize.value = e.dashSize + e.gapSize),
                                        (t.scale.value = e.scale);
                                    })(t, r))
                                  : r.isPointsMaterial
                                    ? (function (t, e, n, r) {
                                      let i;
                                      t.diffuse.value.copy(e.color),
                                        (t.opacity.value = e.opacity),
                                        (t.size.value = e.size * n),
                                        (t.scale.value = 0.5 * r),
                                        e.map && (t.map.value = e.map),
                                        e.alphaMap && (t.alphaMap.value = e.alphaMap),
                                        e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap),
                                        void 0 !== i &&
                                        (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                                          t.uvTransform.value.copy(i.matrix));
                                    })(t, r, i, s)
                                    : r.isSpriteMaterial
                                      ? (function (t, e) {
                                        let n;
                                        t.diffuse.value.copy(e.color),
                                          (t.opacity.value = e.opacity),
                                          (t.rotation.value = e.rotation),
                                          e.map && (t.map.value = e.map),
                                          e.alphaMap && (t.alphaMap.value = e.alphaMap),
                                          e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap),
                                          void 0 !== n &&
                                          (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                                            t.uvTransform.value.copy(n.matrix));
                                      })(t, r)
                                      : r.isShadowMaterial
                                        ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
                                        : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
            },
          };
        }
        function Xh() {
          const t = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas"
          );
          return (t.style.display = "block"), t;
        }
        function Yh(t) {
          const e = void 0 !== (t = t || {}).canvas ? t.canvas : Xh(),
            n = void 0 !== t.context ? t.context : null,
            r = void 0 !== t.alpha && t.alpha,
            i = void 0 === t.depth || t.depth,
            s = void 0 === t.stencil || t.stencil,
            o = void 0 !== t.antialias && t.antialias,
            a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            c = void 0 !== t.powerPreference ? t.powerPreference : "default",
            h =
              void 0 !== t.failIfMajorPerformanceCaveat &&
              t.failIfMajorPerformanceCaveat;
          let u = null,
            p = null;
          const d = [],
            m = [];
          (this.domElement = e),
            (this.debug = { checkShaderErrors: !0 }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.gammaFactor = 2),
            (this.outputEncoding = Xe),
            (this.physicallyCorrectLights = !1),
            (this.toneMapping = Z),
            (this.toneMappingExposure = 1);
          const f = this;
          let g = !1,
            x = 0,
            v = 0,
            y = null,
            _ = -1,
            M = null;
          const w = new pr(),
            b = new pr();
          let S = null,
            T = e.width,
            E = e.height,
            A = 1,
            L = null,
            R = null;
          const C = new pr(0, 0, T, E),
            P = new pr(0, 0, T, E);
          let D = !1;
          const I = [],
            B = new Qs();
          let F = !1,
            N = !1,
            G = null;
          const z = new Yr(),
            O = new xr(),
            H = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function U() {
            return null === y ? A : 1;
          }
          let k,
            V,
            W,
            j,
            q,
            X,
            Y,
            J,
            Q,
            K,
            $,
            tt,
            et,
            nt,
            rt,
            it,
            st,
            ot,
            at,
            lt,
            ht,
            pt,
            dt = n;
          function mt(t, n) {
            for (let r = 0; r < t.length; r++) {
              const i = t[r],
                s = e.getContext(i, n);
              if (null !== s) return s;
            }
            return null;
          }
          try {
            const t = {
              alpha: r,
              depth: i,
              stencil: s,
              antialias: o,
              premultipliedAlpha: a,
              preserveDrawingBuffer: l,
              powerPreference: c,
              failIfMajorPerformanceCaveat: h,
            };
            if (
              (e.addEventListener("webglcontextlost", xt, !1),
                e.addEventListener("webglcontextrestored", vt, !1),
                null === dt)
            ) {
              const e = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === f.isWebGL1Renderer && e.shift(),
                  null === (dt = mt(e, t)))
              )
                throw mt(e)
                  ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                  : new Error("Error creating WebGL context.");
            }
            void 0 === dt.getShaderPrecisionFormat &&
              (dt.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
              });
          } catch (It) {
            throw (console.error("THREE.WebGLRenderer: " + It.message), It);
          }
          function ft() {
            (k = new Dl(dt)),
              (V = new Rl(dt, k, t)),
              k.init(V),
              (ht = new Hh(dt, k, V)),
              (W = new zh(dt, k, V)),
              (I[0] = 1029),
              (j = new Fl(dt)),
              (q = new Mh()),
              (X = new Oh(dt, k, W, q, V, ht, j)),
              (Y = new Pl(f)),
              (J = new $s(dt, V)),
              (pt = new Al(dt, k, J, V)),
              (Q = new Il(dt, J, j, pt)),
              (K = new Ol(dt, Q, J, j)),
              (ot = new zl(dt)),
              (rt = new Cl(q)),
              ($ = new _h(f, Y, k, V, pt, rt)),
              (tt = new qh(q)),
              (et = new Th(q)),
              (nt = new Dh(k, V)),
              (st = new El(f, Y, W, K, a)),
              (it = new Gh(f, K, V)),
              (at = new Ll(dt, k, j, V)),
              (lt = new Bl(dt, k, j, V)),
              (j.programs = $.programs),
              (f.capabilities = V),
              (f.extensions = k),
              (f.properties = q),
              (f.renderLists = et),
              (f.shadowMap = it),
              (f.state = W),
              (f.info = j);
          }
          ft();
          const gt = new jh(f, dt);
          function xt(t) {
            t.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (g = !0);
          }
          function vt() {
            console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
            const t = j.autoReset,
              e = it.enabled,
              n = it.autoUpdate,
              r = it.needsUpdate,
              i = it.type;
            ft(),
              (j.autoReset = t),
              (it.enabled = e),
              (it.autoUpdate = n),
              (it.needsUpdate = r),
              (it.type = i);
          }
          function _t(t) {
            const e = t.target;
            e.removeEventListener("dispose", _t),
              (function (t) {
                (function (t) {
                  const e = q.get(t).programs;
                  void 0 !== e &&
                    e.forEach(function (t) {
                      $.releaseProgram(t);
                    });
                })(t),
                  q.remove(t);
              })(e);
          }
          (this.xr = gt),
            (this.getContext = function () {
              return dt;
            }),
            (this.getContextAttributes = function () {
              return dt.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const t = k.get("WEBGL_lose_context");
              t && t.loseContext();
            }),
            (this.forceContextRestore = function () {
              const t = k.get("WEBGL_lose_context");
              t && t.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return A;
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((A = t), this.setSize(T, E, !1));
            }),
            (this.getSize = function (t) {
              return (
                void 0 === t &&
                (console.warn(
                  "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                ),
                  (t = new sr())),
                t.set(T, E)
              );
            }),
            (this.setSize = function (t, n, r) {
              gt.isPresenting
                ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
                : ((T = t),
                  (E = n),
                  (e.width = Math.floor(t * A)),
                  (e.height = Math.floor(n * A)),
                  !1 !== r &&
                  ((e.style.width = t + "px"), (e.style.height = n + "px")),
                  this.setViewport(0, 0, t, n));
            }),
            (this.getDrawingBufferSize = function (t) {
              return (
                void 0 === t &&
                (console.warn(
                  "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                ),
                  (t = new sr())),
                t.set(T * A, E * A).floor()
              );
            }),
            (this.setDrawingBufferSize = function (t, n, r) {
              (T = t),
                (E = n),
                (A = r),
                (e.width = Math.floor(t * r)),
                (e.height = Math.floor(n * r)),
                this.setViewport(0, 0, t, n);
            }),
            (this.getCurrentViewport = function (t) {
              return (
                void 0 === t &&
                (console.warn(
                  "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                ),
                  (t = new pr())),
                t.copy(w)
              );
            }),
            (this.getViewport = function (t) {
              return t.copy(C);
            }),
            (this.setViewport = function (t, e, n, r) {
              t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, r),
                W.viewport(w.copy(C).multiplyScalar(A).floor());
            }),
            (this.getScissor = function (t) {
              return t.copy(P);
            }),
            (this.setScissor = function (t, e, n, r) {
              t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, r),
                W.scissor(b.copy(P).multiplyScalar(A).floor());
            }),
            (this.getScissorTest = function () {
              return D;
            }),
            (this.setScissorTest = function (t) {
              W.setScissorTest((D = t));
            }),
            (this.setOpaqueSort = function (t) {
              L = t;
            }),
            (this.setTransparentSort = function (t) {
              R = t;
            }),
            (this.getClearColor = function (t) {
              return (
                void 0 === t &&
                (console.warn(
                  "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                ),
                  (t = new Vi())),
                t.copy(st.getClearColor())
              );
            }),
            (this.setClearColor = function () {
              st.setClearColor.apply(st, arguments);
            }),
            (this.getClearAlpha = function () {
              return st.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              st.setClearAlpha.apply(st, arguments);
            }),
            (this.clear = function (t, e, n) {
              let r = 0;
              (void 0 === t || t) && (r |= 16384),
                (void 0 === e || e) && (r |= 256),
                (void 0 === n || n) && (r |= 1024),
                dt.clear(r);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener("webglcontextlost", xt, !1),
                e.removeEventListener("webglcontextrestored", vt, !1),
                et.dispose(),
                nt.dispose(),
                q.dispose(),
                Y.dispose(),
                K.dispose(),
                pt.dispose(),
                gt.dispose(),
                gt.removeEventListener("sessionstart", bt),
                gt.removeEventListener("sessionend", St),
                G && (G.dispose(), (G = null)),
                Tt.stop();
            }),
            (this.renderBufferImmediate = function (t, e) {
              pt.initAttributes();
              const n = q.get(t);
              t.hasPositions && !n.position && (n.position = dt.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = dt.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = dt.createBuffer()),
                t.hasColors && !n.color && (n.color = dt.createBuffer());
              const r = e.getAttributes();
              t.hasPositions &&
                (dt.bindBuffer(34962, n.position),
                  dt.bufferData(34962, t.positionArray, 35048),
                  pt.enableAttribute(r.position),
                  dt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
                t.hasNormals &&
                (dt.bindBuffer(34962, n.normal),
                  dt.bufferData(34962, t.normalArray, 35048),
                  pt.enableAttribute(r.normal),
                  dt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs &&
                (dt.bindBuffer(34962, n.uv),
                  dt.bufferData(34962, t.uvArray, 35048),
                  pt.enableAttribute(r.uv),
                  dt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
                t.hasColors &&
                (dt.bindBuffer(34962, n.color),
                  dt.bufferData(34962, t.colorArray, 35048),
                  pt.enableAttribute(r.color),
                  dt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
                pt.disableUnusedAttributes(),
                dt.drawArrays(4, 0, t.count),
                (t.count = 0);
            }),
            (this.renderBufferDirect = function (t, e, n, r, i, s) {
              null === e && (e = H);
              const o = i.isMesh && i.matrixWorld.determinant() < 0,
                a = Dt(t, e, r, i);
              W.setMaterial(r, o);
              let l = n.index;
              const c = n.attributes.position;
              if (null === l) {
                if (void 0 === c || 0 === c.count) return;
              } else if (0 === l.count) return;
              let h,
                u = 1;
              !0 === r.wireframe && ((l = Q.getWireframeAttribute(n)), (u = 2)),
                (r.morphTargets || r.morphNormals) && ot.update(i, n, r, a),
                pt.setup(i, r, a, n, l);
              let p = at;
              null !== l && ((h = J.get(l)), (p = lt).setIndex(h));
              const d = null !== l ? l.count : c.count,
                m = n.drawRange.start * u,
                f = n.drawRange.count * u,
                g = null !== s ? s.start * u : 0,
                x = null !== s ? s.count * u : 1 / 0,
                v = Math.max(m, g),
                y = Math.min(d, m + f, g + x) - 1,
                _ = Math.max(0, y - v + 1);
              if (0 !== _) {
                if (i.isMesh)
                  !0 === r.wireframe
                    ? (W.setLineWidth(r.wireframeLinewidth * U()), p.setMode(1))
                    : p.setMode(4);
                else if (i.isLine) {
                  let t = r.linewidth;
                  void 0 === t && (t = 1),
                    W.setLineWidth(t * U()),
                    i.isLineSegments
                      ? p.setMode(1)
                      : i.isLineLoop
                        ? p.setMode(2)
                        : p.setMode(3);
                } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
                if (i.isInstancedMesh) p.renderInstances(v, _, i.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = Math.min(n.instanceCount, n._maxInstanceCount);
                  p.renderInstances(v, _, t);
                } else p.render(v, _);
              }
            }),
            (this.compile = function (t, e) {
              (p = nt.get(t)).init(),
                t.traverseVisible(function (t) {
                  t.isLight &&
                    t.layers.test(e.layers) &&
                    (p.pushLight(t), t.castShadow && p.pushShadow(t));
                }),
                p.setupLights(),
                t.traverse(function (e) {
                  const n = e.material;
                  if (n)
                    if (Array.isArray(n))
                      for (let r = 0; r < n.length; r++) {
                        Ct(n[r], t, e);
                      }
                    else Ct(n, t, e);
                });
            });
          let wt = null;
          function bt() {
            Tt.stop();
          }
          function St() {
            Tt.start();
          }
          const Tt = new Ks();
          function Et(t, e, n) {
            const r = !0 === e.isScene ? e.overrideMaterial : null;
            for (let i = 0, s = t.length; i < s; i++) {
              const s = t[i],
                o = s.object,
                a = s.geometry,
                l = null === r ? s.material : r,
                c = s.group;
              if (n.isArrayCamera) {
                const t = n.cameras;
                for (let n = 0, r = t.length; n < r; n++) {
                  const r = t[n];
                  o.layers.test(r.layers) &&
                    (W.viewport(w.copy(r.viewport)),
                      p.setupLightsView(r),
                      Rt(o, e, r, a, l, c));
                }
              } else Rt(o, e, n, a, l, c);
            }
          }
          function Rt(t, e, n, r, i, s) {
            if (
              (t.onBeforeRender(f, e, n, r, i, s),
                t.modelViewMatrix.multiplyMatrices(
                  n.matrixWorldInverse,
                  t.matrixWorld
                ),
                t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                t.isImmediateRenderObject)
            ) {
              const r = Dt(n, e, i, t);
              W.setMaterial(i),
                pt.reset(),
                (function (t, e) {
                  t.render(function (t) {
                    f.renderBufferImmediate(t, e);
                  });
                })(t, r);
            } else f.renderBufferDirect(n, e, r, i, t, s);
            t.onAfterRender(f, e, n, r, i, s);
          }
          function Ct(t, e, n) {
            !0 !== e.isScene && (e = H);
            const r = q.get(t),
              i = p.state.lights,
              s = p.state.shadowsArray,
              o = i.state.version,
              a = $.getParameters(t, i.state, s, e, n),
              l = $.getProgramCacheKey(a);
            let c = r.programs;
            (r.environment = t.isMeshStandardMaterial ? e.environment : null),
              (r.fog = e.fog),
              (r.envMap = Y.get(t.envMap || r.environment)),
              void 0 === c &&
              (t.addEventListener("dispose", _t),
                (c = new Map()),
                (r.programs = c));
            let h = c.get(l);
            if (void 0 !== h) {
              if (r.currentProgram === h && r.lightsStateVersion === o)
                return Pt(t, a), h;
            } else
              (a.uniforms = $.getUniforms(t)),
                t.onBuild(a, f),
                t.onBeforeCompile(a, f),
                (h = $.acquireProgram(a, l)),
                c.set(l, h),
                (r.uniforms = a.uniforms);
            const u = r.uniforms;
            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
              !0 !== t.clipping) ||
              (u.clippingPlanes = rt.uniform),
              Pt(t, a),
              (r.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                );
              })(t)),
              (r.lightsStateVersion = o),
              r.needsLights &&
              ((u.ambientLightColor.value = i.state.ambient),
                (u.lightProbe.value = i.state.probe),
                (u.directionalLights.value = i.state.directional),
                (u.directionalLightShadows.value = i.state.directionalShadow),
                (u.spotLights.value = i.state.spot),
                (u.spotLightShadows.value = i.state.spotShadow),
                (u.rectAreaLights.value = i.state.rectArea),
                (u.ltc_1.value = i.state.rectAreaLTC1),
                (u.ltc_2.value = i.state.rectAreaLTC2),
                (u.pointLights.value = i.state.point),
                (u.pointLightShadows.value = i.state.pointShadow),
                (u.hemisphereLights.value = i.state.hemi),
                (u.directionalShadowMap.value = i.state.directionalShadowMap),
                (u.directionalShadowMatrix.value =
                  i.state.directionalShadowMatrix),
                (u.spotShadowMap.value = i.state.spotShadowMap),
                (u.spotShadowMatrix.value = i.state.spotShadowMatrix),
                (u.pointShadowMap.value = i.state.pointShadowMap),
                (u.pointShadowMatrix.value = i.state.pointShadowMatrix));
            const d = h.getUniforms(),
              m = jc.seqWithValue(d.seq, u);
            return (r.currentProgram = h), (r.uniformsList = m), h;
          }
          function Pt(t, e) {
            const n = q.get(t);
            (n.outputEncoding = e.outputEncoding),
              (n.instancing = e.instancing),
              (n.skinning = e.skinning),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas);
          }
          function Dt(t, e, n, r) {
            !0 !== e.isScene && (e = H), X.resetTextureUnits();
            const i = e.fog,
              s = n.isMeshStandardMaterial ? e.environment : null,
              o = null === y ? f.outputEncoding : y.texture.encoding,
              a = Y.get(n.envMap || s),
              l =
                !0 === n.vertexColors &&
                r.geometry &&
                r.geometry.attributes.color &&
                4 === r.geometry.attributes.color.itemSize,
              c = q.get(n),
              h = p.state.lights;
            if (!0 === F && (!0 === N || t !== M)) {
              const e = t === M && n.id === _;
              rt.setState(n, t, e);
            }
            let u = !1;
            n.version === c.__version
              ? c.needsLights && c.lightsStateVersion !== h.state.version
                ? (u = !0)
                : c.outputEncoding !== o
                  ? (u = !0)
                  : r.isInstancedMesh && !1 === c.instancing
                    ? (u = !0)
                    : r.isInstancedMesh || !0 !== c.instancing
                      ? r.isSkinnedMesh && !1 === c.skinning
                        ? (u = !0)
                        : r.isSkinnedMesh || !0 !== c.skinning
                          ? c.envMap !== a
                            ? (u = !0)
                            : n.fog && c.fog !== i
                              ? (u = !0)
                              : void 0 === c.numClippingPlanes ||
                                (c.numClippingPlanes === rt.numPlanes &&
                                  c.numIntersection === rt.numIntersection)
                                ? c.vertexAlphas !== l && (u = !0)
                                : (u = !0)
                          : (u = !0)
                      : (u = !0)
              : ((u = !0), (c.__version = n.version));
            let d = c.currentProgram;
            !0 === u && (d = Ct(n, e, r));
            let m = !1,
              g = !1,
              x = !1;
            const v = d.getUniforms(),
              w = c.uniforms;
            if (
              (W.useProgram(d.program) && ((m = !0), (g = !0), (x = !0)),
                n.id !== _ && ((_ = n.id), (g = !0)),
                m || M !== t)
            ) {
              if (
                (v.setValue(dt, "projectionMatrix", t.projectionMatrix),
                  V.logarithmicDepthBuffer &&
                  v.setValue(
                    dt,
                    "logDepthBufFC",
                    2 / (Math.log(t.far + 1) / Math.LN2)
                  ),
                  M !== t && ((M = t), (g = !0), (x = !0)),
                  n.isShaderMaterial ||
                  n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshStandardMaterial ||
                  n.envMap)
              ) {
                const e = v.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(dt, O.setFromMatrixPosition(t.matrixWorld));
              }
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial) &&
                v.setValue(dt, "isOrthographic", !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial ||
                  n.isShadowMaterial ||
                  r.isSkinnedMesh) &&
                v.setValue(dt, "viewMatrix", t.matrixWorldInverse);
            }
            if (r.isSkinnedMesh) {
              v.setOptional(dt, r, "bindMatrix"),
                v.setOptional(dt, r, "bindMatrixInverse");
              const t = r.skeleton;
              t &&
                (V.floatVertexTextures
                  ? (null === t.boneTexture && t.computeBoneTexture(),
                    v.setValue(dt, "boneTexture", t.boneTexture, X),
                    v.setValue(dt, "boneTextureSize", t.boneTextureSize))
                  : v.setOptional(dt, t, "boneMatrices"));
            }
            var b, S;
            return (
              (g || c.receiveShadow !== r.receiveShadow) &&
              ((c.receiveShadow = r.receiveShadow),
                v.setValue(dt, "receiveShadow", r.receiveShadow)),
              g &&
              (v.setValue(dt, "toneMappingExposure", f.toneMappingExposure),
                c.needsLights &&
                ((S = x),
                  ((b = w).ambientLightColor.needsUpdate = S),
                  (b.lightProbe.needsUpdate = S),
                  (b.directionalLights.needsUpdate = S),
                  (b.directionalLightShadows.needsUpdate = S),
                  (b.pointLights.needsUpdate = S),
                  (b.pointLightShadows.needsUpdate = S),
                  (b.spotLights.needsUpdate = S),
                  (b.spotLightShadows.needsUpdate = S),
                  (b.rectAreaLights.needsUpdate = S),
                  (b.hemisphereLights.needsUpdate = S)),
                i && n.fog && tt.refreshFogUniforms(w, i),
                tt.refreshMaterialUniforms(w, n, A, E, G),
                jc.upload(dt, c.uniformsList, w, X)),
              n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (jc.upload(dt, c.uniformsList, w, X),
                (n.uniformsNeedUpdate = !1)),
              n.isSpriteMaterial && v.setValue(dt, "center", r.center),
              v.setValue(dt, "modelViewMatrix", r.modelViewMatrix),
              v.setValue(dt, "normalMatrix", r.normalMatrix),
              v.setValue(dt, "modelMatrix", r.matrixWorld),
              d
            );
          }
          Tt.setAnimationLoop(function (t) {
            wt && wt(t);
          }),
            "undefined" != typeof window && Tt.setContext(window),
            (this.setAnimationLoop = function (t) {
              (wt = t),
                gt.setAnimationLoop(t),
                null === t ? Tt.stop() : Tt.start();
            }),
            gt.addEventListener("sessionstart", bt),
            gt.addEventListener("sessionend", St),
            (this.render = function (t, e) {
              if (void 0 !== e && !0 !== e.isCamera)
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === g) return;
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === gt.enabled &&
                !0 === gt.isPresenting &&
                (!0 === gt.cameraAutoUpdate && gt.updateCamera(e),
                  (e = gt.getCamera())),
                !0 === t.isScene && t.onBeforeRender(f, t, e, y),
                (p = nt.get(t, m.length)).init(),
                m.push(p),
                z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                B.setFromProjectionMatrix(z),
                (N = this.localClippingEnabled),
                (F = rt.init(this.clippingPlanes, N, e)),
                (u = et.get(t, d.length)).init(),
                d.push(u),
                (function t(e, n, r, i) {
                  if (!1 === e.visible) return;
                  const s = e.layers.test(n.layers);
                  if (s)
                    if (e.isGroup) r = e.renderOrder;
                    else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                    else if (e.isLight)
                      p.pushLight(e), e.castShadow && p.pushShadow(e);
                    else if (e.isSprite) {
                      if (!e.frustumCulled || B.intersectsSprite(e)) {
                        i &&
                          O.setFromMatrixPosition(e.matrixWorld).applyMatrix4(
                            z
                          );
                        const t = K.update(e),
                          n = e.material;
                        n.visible && u.push(e, t, n, r, O.z, null);
                      }
                    } else if (e.isImmediateRenderObject)
                      i &&
                        O.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z),
                        u.push(e, null, e.material, r, O.z, null);
                    else if (
                      (e.isMesh || e.isLine || e.isPoints) &&
                      (e.isSkinnedMesh &&
                        e.skeleton.frame !== j.render.frame &&
                        (e.skeleton.update(),
                          (e.skeleton.frame = j.render.frame)),
                        !e.frustumCulled || B.intersectsObject(e))
                    ) {
                      i &&
                        O.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                      const t = K.update(e),
                        n = e.material;
                      if (Array.isArray(n)) {
                        const i = t.groups;
                        for (let s = 0, o = i.length; s < o; s++) {
                          const o = i[s],
                            a = n[o.materialIndex];
                          a && a.visible && u.push(e, t, a, r, O.z, o);
                        }
                      } else n.visible && u.push(e, t, n, r, O.z, null);
                    }
                  const o = e.children;
                  for (let a = 0, l = o.length; a < l; a++) t(o[a], n, r, i);
                })(t, e, 0, f.sortObjects),
                u.finish(),
                !0 === f.sortObjects && u.sort(L, R),
                !0 === F && rt.beginShadows();
              const n = p.state.shadowsArray;
              it.render(n, t, e),
                p.setupLights(),
                p.setupLightsView(e),
                !0 === F && rt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                st.render(u, t);
              const r = u.opaque,
                i = u.transmissive,
                s = u.transparent;
              r.length > 0 && Et(r, t, e),
                i.length > 0 &&
                (function (t, e, n, r) {
                  null === G &&
                    (G = new dr(1024, 1024, {
                      generateMipmaps: !0,
                      minFilter: yt,
                      magFilter: ut,
                      wrapS: ct,
                      wrapT: ct,
                    }));
                  const i = f.getRenderTarget();
                  f.setRenderTarget(G),
                    f.clear(),
                    Et(t, n, r),
                    X.updateRenderTargetMipmap(G),
                    f.setRenderTarget(i),
                    Et(e, n, r);
                })(r, i, t, e),
                s.length > 0 && Et(s, t, e),
                null !== y &&
                (X.updateRenderTargetMipmap(y),
                  X.updateMultisampleRenderTarget(y)),
                !0 === t.isScene && t.onAfterRender(f, t, e),
                W.buffers.depth.setTest(!0),
                W.buffers.depth.setMask(!0),
                W.buffers.color.setMask(!0),
                W.setPolygonOffset(!1),
                pt.resetDefaultState(),
                (_ = -1),
                (M = null),
                m.pop(),
                (p = m.length > 0 ? m[m.length - 1] : null),
                d.pop(),
                (u = d.length > 0 ? d[d.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return x;
            }),
            (this.getActiveMipmapLevel = function () {
              return v;
            }),
            (this.getRenderTarget = function () {
              return y;
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              (y = t),
                (x = e),
                (v = n),
                t &&
                void 0 === q.get(t).__webglFramebuffer &&
                X.setupRenderTarget(t);
              let r = null,
                i = !1,
                s = !1;
              if (t) {
                const n = t.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                const o = q.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget
                  ? ((r = o[e]), (i = !0))
                  : (r = t.isWebGLMultisampleRenderTarget
                    ? q.get(t).__webglMultisampledFramebuffer
                    : o),
                  w.copy(t.viewport),
                  b.copy(t.scissor),
                  (S = t.scissorTest);
              } else
                w.copy(C).multiplyScalar(A).floor(),
                  b.copy(P).multiplyScalar(A).floor(),
                  (S = D);
              if (W.bindFramebuffer(36160, r) && V.drawBuffers) {
                let e = !1;
                if (t)
                  if (t.isWebGLMultipleRenderTargets) {
                    const n = t.texture;
                    if (I.length !== n.length || 36064 !== I[0]) {
                      for (let t = 0, e = n.length; t < e; t++)
                        I[t] = 36064 + t;
                      (I.length = n.length), (e = !0);
                    }
                  } else
                    (1 === I.length && 36064 === I[0]) ||
                      ((I[0] = 36064), (I.length = 1), (e = !0));
                else
                  (1 === I.length && 1029 === I[0]) ||
                    ((I[0] = 1029), (I.length = 1), (e = !0));
                e &&
                  (V.isWebGL2
                    ? dt.drawBuffers(I)
                    : k.get("WEBGL_draw_buffers").drawBuffersWEBGL(I));
              }
              if ((W.viewport(w), W.scissor(b), W.setScissorTest(S), i)) {
                const r = q.get(t.texture);
                dt.framebufferTexture2D(
                  36160,
                  36064,
                  34069 + e,
                  r.__webglTexture,
                  n
                );
              } else if (s) {
                const r = q.get(t.texture),
                  i = e || 0;
                dt.framebufferTextureLayer(
                  36160,
                  36064,
                  r.__webglTexture,
                  n || 0,
                  i
                );
              }
            }),
            (this.readRenderTargetPixels = function (t, e, n, r, i, s, o) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let a = q.get(t).__webglFramebuffer;
              if (
                (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)
              ) {
                W.bindFramebuffer(36160, a);
                try {
                  const o = t.texture,
                    a = o.format,
                    l = o.type;
                  if (a !== Ft && ht.convert(a) !== dt.getParameter(35739))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  const c =
                    l === Lt &&
                    (k.has("EXT_color_buffer_half_float") ||
                      (V.isWebGL2 && k.has("EXT_color_buffer_float")));
                  if (
                    !(
                      l === Mt ||
                      ht.convert(l) === dt.getParameter(35738) ||
                      (l === At &&
                        (V.isWebGL2 ||
                          k.has("OES_texture_float") ||
                          k.has("WEBGL_color_buffer_float"))) ||
                      c
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  36053 === dt.checkFramebufferStatus(36160)
                    ? e >= 0 &&
                    e <= t.width - r &&
                    n >= 0 &&
                    n <= t.height - i &&
                    dt.readPixels(e, n, r, i, ht.convert(a), ht.convert(l), s)
                    : console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                    );
                } finally {
                  const t = null !== y ? q.get(y).__webglFramebuffer : null;
                  W.bindFramebuffer(36160, t);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const r = Math.pow(2, -n),
                i = Math.floor(e.image.width * r),
                s = Math.floor(e.image.height * r);
              let o = ht.convert(e.format);
              V.isWebGL2 &&
                (6407 === o && (o = 32849), 6408 === o && (o = 32856)),
                X.setTexture2D(e, 0),
                dt.copyTexImage2D(3553, n, o, t.x, t.y, i, s, 0),
                W.unbindTexture();
            }),
            (this.copyTextureToTexture = function (t, e, n, r = 0) {
              const i = e.image.width,
                s = e.image.height,
                o = ht.convert(n.format),
                a = ht.convert(n.type);
              X.setTexture2D(n, 0),
                dt.pixelStorei(37440, n.flipY),
                dt.pixelStorei(37441, n.premultiplyAlpha),
                dt.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture
                  ? dt.texSubImage2D(
                    3553,
                    r,
                    t.x,
                    t.y,
                    i,
                    s,
                    o,
                    a,
                    e.image.data
                  )
                  : e.isCompressedTexture
                    ? dt.compressedTexSubImage2D(
                      3553,
                      r,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      o,
                      e.mipmaps[0].data
                    )
                    : dt.texSubImage2D(3553, r, t.x, t.y, o, a, e.image),
                0 === r && n.generateMipmaps && dt.generateMipmap(3553),
                W.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (t, e, n, r, i = 0) {
              if (f.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
              const { width: s, height: o, data: a } = n.image,
                l = ht.convert(r.format),
                c = ht.convert(r.type);
              let h;
              if (r.isDataTexture3D) X.setTexture3D(r, 0), (h = 32879);
              else {
                if (!r.isDataTexture2DArray)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                X.setTexture2DArray(r, 0), (h = 35866);
              }
              dt.pixelStorei(37440, r.flipY),
                dt.pixelStorei(37441, r.premultiplyAlpha),
                dt.pixelStorei(3317, r.unpackAlignment);
              const u = dt.getParameter(3314),
                p = dt.getParameter(32878),
                d = dt.getParameter(3316),
                m = dt.getParameter(3315),
                g = dt.getParameter(32877);
              dt.pixelStorei(3314, s),
                dt.pixelStorei(32878, o),
                dt.pixelStorei(3316, t.min.x),
                dt.pixelStorei(3315, t.min.y),
                dt.pixelStorei(32877, t.min.z),
                dt.texSubImage3D(
                  h,
                  i,
                  e.x,
                  e.y,
                  e.z,
                  t.max.x - t.min.x + 1,
                  t.max.y - t.min.y + 1,
                  t.max.z - t.min.z + 1,
                  l,
                  c,
                  a
                ),
                dt.pixelStorei(3314, u),
                dt.pixelStorei(32878, p),
                dt.pixelStorei(3316, d),
                dt.pixelStorei(3315, m),
                dt.pixelStorei(32877, g),
                0 === i && r.generateMipmaps && dt.generateMipmap(h),
                W.unbindTexture();
            }),
            (this.initTexture = function (t) {
              X.setTexture2D(t, 0), W.unbindTexture();
            }),
            (this.resetState = function () {
              (x = 0), (v = 0), (y = null), W.reset(), pt.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", { detail: this })
            );
        }
        class Zh extends Yh { }
        (exports.WebGL1Renderer = Zh), (Zh.prototype.isWebGL1Renderer = !0);
        class Jh {
          constructor(t, e = 25e-5) {
            (this.name = ""), (this.color = new Vi(t)), (this.density = e);
          }
          clone() {
            return new Jh(this.color, this.density);
          }
          toJSON() {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density,
            };
          }
        }
        (exports.FogExp2 = Jh), (Jh.prototype.isFogExp2 = !0);
        class Qh {
          constructor(t, e = 1, n = 1e3) {
            (this.name = ""),
              (this.color = new Vi(t)),
              (this.near = e),
              (this.far = n);
          }
          clone() {
            return new Qh(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        }
        (exports.Fog = Qh), (Qh.prototype.isFog = !0);
        class Kh extends yi {
          constructor() {
            super(),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.overrideMaterial = null),
              (this.autoUpdate = !0),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment &&
              (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.background &&
              (e.object.background = this.background.toJSON(t)),
              null !== this.environment &&
              (e.object.environment = this.environment.toJSON(t)),
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              e
            );
          }
        }
        (exports.Scene = Kh), (Kh.prototype.isScene = !0);
        class $h {
          constructor(t, e) {
            (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = wn),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = zn());
          }
          onUploadCallback() { }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let r = 0, i = this.stride; r < i; r++)
              this.array[t + r] = e.array[n + r];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = zn()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
            const e = new this.array.constructor(
              t.arrayBuffers[this.array.buffer._uuid]
            ),
              n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = zn()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
              (t.arrayBuffers[this.array.buffer._uuid] =
                Array.prototype.slice.call(
                  new Uint32Array(this.array.buffer)
                )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        (exports.InterleavedBuffer = $h),
          ($h.prototype.isInterleavedBuffer = !0);
        const tu = new xr();
        class eu {
          constructor(t, e, n, r) {
            (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = !0 === r);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              (tu.x = this.getX(e)),
                (tu.y = this.getY(e)),
                (tu.z = this.getZ(e)),
                tu.applyMatrix4(t),
                this.setXYZ(e, tu.x, tu.y, tu.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (tu.x = this.getX(e)),
                (tu.y = this.getY(e)),
                (tu.z = this.getZ(e)),
                tu.applyNormalMatrix(t),
                this.setXYZ(e, tu.x, tu.y, tu.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (tu.x = this.getX(e)),
                (tu.y = this.getY(e)),
                (tu.z = this.getZ(e)),
                tu.transformDirection(t),
                this.setXYZ(e, tu.x, tu.y, tu.z);
            return this;
          }
          setX(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset] = e), this
            );
          }
          setY(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            return this.data.array[t * this.data.stride + this.offset];
          }
          getY(t) {
            return this.data.array[t * this.data.stride + this.offset + 1];
          }
          getZ(t) {
            return this.data.array[t * this.data.stride + this.offset + 2];
          }
          getW(t) {
            return this.data.array[t * this.data.stride + this.offset + 3];
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, r) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = r),
              this
            );
          }
          setXYZW(t, e, n, r, i) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = r),
              (this.data.array[t + 3] = i),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return new Xi(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new eu(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
              (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        (exports.InterleavedBufferAttribute = eu),
          (eu.prototype.isInterleavedBufferAttribute = !0);
        class nu extends Ni {
          constructor(t) {
            super(),
              (this.type = "SpriteMaterial"),
              (this.color = new Vi(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            );
          }
        }
        let ru;
        (exports.SpriteMaterial = nu), (nu.prototype.isSpriteMaterial = !0);
        const iu = new xr(),
          su = new xr(),
          ou = new xr(),
          au = new sr(),
          lu = new sr(),
          cu = new Yr(),
          hu = new xr(),
          uu = new xr(),
          pu = new xr(),
          du = new sr(),
          mu = new sr(),
          fu = new sr();
        class gu extends yi {
          constructor(t) {
            if ((super(), (this.type = "Sprite"), void 0 === ru)) {
              ru = new ms();
              const t = new Float32Array([
                -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                -0.5, 0.5, 0, 0, 1,
              ]),
                e = new $h(t, 5);
              ru.setIndex([0, 1, 2, 0, 2, 3]),
                ru.setAttribute("position", new eu(e, 3, 0, !1)),
                ru.setAttribute("uv", new eu(e, 2, 3, !1));
            }
            (this.geometry = ru),
              (this.material = void 0 !== t ? t : new nu()),
              (this.center = new sr(0.5, 0.5));
          }
          raycast(t, e) {
            null === t.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
              ),
              su.setFromMatrixScale(this.matrixWorld),
              cu.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(
                t.camera.matrixWorldInverse,
                this.matrixWorld
              ),
              ou.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera &&
              !1 === this.material.sizeAttenuation &&
              su.multiplyScalar(-ou.z);
            const n = this.material.rotation;
            let r, i;
            0 !== n && ((i = Math.cos(n)), (r = Math.sin(n)));
            const s = this.center;
            xu(hu.set(-0.5, -0.5, 0), ou, s, su, r, i),
              xu(uu.set(0.5, -0.5, 0), ou, s, su, r, i),
              xu(pu.set(0.5, 0.5, 0), ou, s, su, r, i),
              du.set(0, 0),
              mu.set(1, 0),
              fu.set(1, 1);
            let o = t.ray.intersectTriangle(hu, uu, pu, !1, iu);
            if (
              null === o &&
              (xu(uu.set(-0.5, 0.5, 0), ou, s, su, r, i),
                mu.set(0, 1),
                null === (o = t.ray.intersectTriangle(hu, pu, uu, !1, iu)))
            )
              return;
            const a = t.ray.origin.distanceTo(iu);
            a < t.near ||
              a > t.far ||
              e.push({
                distance: a,
                point: iu.clone(),
                uv: Bi.getUV(iu, hu, uu, pu, du, mu, fu, new sr()),
                face: null,
                object: this,
              });
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.center && this.center.copy(t.center),
              (this.material = t.material),
              this
            );
          }
        }
        function xu(t, e, n, r, i, s) {
          au.subVectors(t, n).addScalar(0.5).multiply(r),
            void 0 !== i
              ? ((lu.x = s * au.x - i * au.y), (lu.y = i * au.x + s * au.y))
              : lu.copy(au),
            t.copy(e),
            (t.x += lu.x),
            (t.y += lu.y),
            t.applyMatrix4(cu);
        }
        (exports.Sprite = gu), (gu.prototype.isSprite = !0);
        const vu = new xr(),
          yu = new xr();
        class _u extends yi {
          constructor() {
            super(),
              (this._currentLevel = 0),
              (this.type = "LOD"),
              Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
              }),
              (this.autoUpdate = !0);
          }
          copy(t) {
            super.copy(t, !1);
            const e = t.levels;
            for (let n = 0, r = e.length; n < r; n++) {
              const t = e[n];
              this.addLevel(t.object.clone(), t.distance);
            }
            return (this.autoUpdate = t.autoUpdate), this;
          }
          addLevel(t, e = 0) {
            e = Math.abs(e);
            const n = this.levels;
            let r;
            for (r = 0; r < n.length && !(e < n[r].distance); r++);
            return (
              n.splice(r, 0, { distance: e, object: t }), this.add(t), this
            );
          }
          getCurrentLevel() {
            return this._currentLevel;
          }
          getObjectForDistance(t) {
            const e = this.levels;
            if (e.length > 0) {
              let n, r;
              for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
              return e[n - 1].object;
            }
            return null;
          }
          raycast(t, e) {
            if (this.levels.length > 0) {
              vu.setFromMatrixPosition(this.matrixWorld);
              const n = t.ray.origin.distanceTo(vu);
              this.getObjectForDistance(n).raycast(t, e);
            }
          }
          update(t) {
            const e = this.levels;
            if (e.length > 1) {
              vu.setFromMatrixPosition(t.matrixWorld),
                yu.setFromMatrixPosition(this.matrixWorld);
              const n = vu.distanceTo(yu) / t.zoom;
              let r, i;
              for (
                e[0].object.visible = !0, r = 1, i = e.length;
                r < i && n >= e[r].distance;
                r++
              )
                (e[r - 1].object.visible = !1), (e[r].object.visible = !0);
              for (this._currentLevel = r - 1; r < i; r++)
                e[r].object.visible = !1;
            }
          }
          toJSON(t) {
            const e = super.toJSON(t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1),
              (e.object.levels = []);
            const n = this.levels;
            for (let r = 0, i = n.length; r < i; r++) {
              const t = n[r];
              e.object.levels.push({
                object: t.object.uuid,
                distance: t.distance,
              });
            }
            return e;
          }
        }
        exports.LOD = _u;
        const Mu = new xr(),
          wu = new pr(),
          bu = new pr(),
          Su = new xr(),
          Tu = new Yr();
        class Eu extends Ds {
          constructor(t, e) {
            super(t, e),
              (this.type = "SkinnedMesh"),
              (this.bindMode = "attached"),
              (this.bindMatrix = new Yr()),
              (this.bindMatrixInverse = new Yr());
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              this
            );
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
              (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new pr(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, r = e.count; n < r; n++) {
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                (t.w = e.getW(n));
              const r = 1 / t.manhattanLength();
              r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode
                  ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                  : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          }
          boneTransform(t, e) {
            const n = this.skeleton,
              r = this.geometry;
            wu.fromBufferAttribute(r.attributes.skinIndex, t),
              bu.fromBufferAttribute(r.attributes.skinWeight, t),
              Mu.fromBufferAttribute(r.attributes.position, t).applyMatrix4(
                this.bindMatrix
              ),
              e.set(0, 0, 0);
            for (let i = 0; i < 4; i++) {
              const t = bu.getComponent(i);
              if (0 !== t) {
                const r = wu.getComponent(i);
                Tu.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(Su.copy(Mu).applyMatrix4(Tu), t);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
        }
        (exports.SkinnedMesh = Eu), (Eu.prototype.isSkinnedMesh = !0);
        class Au extends yi {
          constructor() {
            super(), (this.type = "Bone");
          }
        }
        (exports.Bone = Au), (Au.prototype.isBone = !0);
        class Lu extends hr {
          constructor(t, e, n, r, i, s, o, a, l, c, h, u) {
            super(null, s, o, a, l, c, r, i, h, u),
              (this.image = { data: t || null, width: e || 1, height: n || 1 }),
              (this.magFilter = void 0 !== l ? l : ut),
              (this.minFilter = void 0 !== c ? c : ut),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        (exports.DataTexture = Lu), (Lu.prototype.isDataTexture = !0);
        const Ru = new Yr(),
          Cu = new Yr();
        class Pu {
          constructor(t = [], e = []) {
            (this.uuid = zn()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * t.length)),
                0 === e.length)
            )
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++)
                this.boneInverses.push(new Yr());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new Yr();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                  e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              r = this.boneTexture;
            for (let i = 0, s = t.length; i < s; i++) {
              const r = t[i] ? t[i].matrixWorld : Cu;
              Ru.multiplyMatrices(r, e[i]), Ru.toArray(n, 16 * i);
            }
            null !== r && (r.needsUpdate = !0);
          }
          clone() {
            return new Pu(this.bones, this.boneInverses);
          }
          computeBoneTexture() {
            let t = Math.sqrt(4 * this.bones.length);
            (t = er(t)), (t = Math.max(t, 4));
            const e = new Float32Array(t * t * 4);
            e.set(this.boneMatrices);
            const n = new Lu(e, t, t, Ft, At);
            return (
              (this.boneMatrices = e),
              (this.boneTexture = n),
              (this.boneTextureSize = t),
              this
            );
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, r = t.bones.length; n < r; n++) {
              const r = t.bones[n];
              let i = e[r];
              void 0 === i &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", r),
                  (i = new Au())),
                this.bones.push(i),
                this.boneInverses.push(new Yr().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON",
              },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let r = 0, i = e.length; r < i; r++) {
              const i = e[r];
              t.bones.push(i.uuid);
              const s = n[r];
              t.boneInverses.push(s.toArray());
            }
            return t;
          }
        }
        exports.Skeleton = Pu;
        const Du = new Yr(),
          Iu = new Yr(),
          Bu = [],
          Fu = new Ds();
        class Nu extends Ds {
          constructor(t, e, n) {
            super(t, e),
              (this.instanceMatrix = new Xi(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.frustumCulled = !1);
          }
          copy(t) {
            return (
              super.copy(t),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor &&
              (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              r = this.count;
            if (
              ((Fu.geometry = this.geometry),
                (Fu.material = this.material),
                void 0 !== Fu.material)
            )
              for (let i = 0; i < r; i++) {
                this.getMatrixAt(i, Du),
                  Iu.multiplyMatrices(n, Du),
                  (Fu.matrixWorld = Iu),
                  Fu.raycast(t, Bu);
                for (let t = 0, n = Bu.length; t < n; t++) {
                  const n = Bu[t];
                  (n.instanceId = i), (n.object = this), e.push(n);
                }
                Bu.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new Xi(
                new Float32Array(3 * this.count),
                3
              )),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() { }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        (exports.InstancedMesh = Nu), (Nu.prototype.isInstancedMesh = !0);
        class Gu extends Ni {
          constructor(t) {
            super(),
              (this.type = "LineBasicMaterial"),
              (this.color = new Vi(16777215)),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        (exports.LineBasicMaterial = Gu),
          (Gu.prototype.isLineBasicMaterial = !0);
        const zu = new xr(),
          Ou = new xr(),
          Hu = new Yr(),
          Uu = new Xr(),
          ku = new Or();
        class Vu extends yi {
          constructor(t = new ms(), e = new Gu()) {
            super(),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [0];
                for (let t = 1, r = e.count; t < r; t++)
                  zu.fromBufferAttribute(e, t - 1),
                    Ou.fromBufferAttribute(e, t),
                    (n[t] = n[t - 1]),
                    (n[t] += zu.distanceTo(Ou));
                t.setAttribute("lineDistance", new ns(n, 1));
              } else
                console.warn(
                  "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              r = this.matrixWorld,
              i = t.params.Line.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
                ku.copy(n.boundingSphere),
                ku.applyMatrix4(r),
                (ku.radius += i),
                !1 === t.ray.intersectsSphere(ku))
            )
              return;
            Hu.copy(r).invert(), Uu.copy(t.ray).applyMatrix4(Hu);
            const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o,
              l = new xr(),
              c = new xr(),
              h = new xr(),
              u = new xr(),
              p = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              const r = n.index,
                i = n.attributes.position;
              if (null !== r) {
                for (
                  let n = Math.max(0, s.start),
                  o = Math.min(r.count, s.start + s.count) - 1;
                  n < o;
                  n += p
                ) {
                  const s = r.getX(n),
                    o = r.getX(n + 1);
                  if (
                    (l.fromBufferAttribute(i, s),
                      c.fromBufferAttribute(i, o),
                      Uu.distanceSqToSegment(l, c, u, h) > a)
                  )
                    continue;
                  u.applyMatrix4(this.matrixWorld);
                  const p = t.ray.origin.distanceTo(u);
                  p < t.near ||
                    p > t.far ||
                    e.push({
                      distance: p,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              } else {
                for (
                  let n = Math.max(0, s.start),
                  r = Math.min(i.count, s.start + s.count) - 1;
                  n < r;
                  n += p
                ) {
                  if (
                    (l.fromBufferAttribute(i, n),
                      c.fromBufferAttribute(i, n + 1),
                      Uu.distanceSqToSegment(l, c, u, h) > a)
                  )
                    continue;
                  u.applyMatrix4(this.matrixWorld);
                  const r = t.ray.origin.distanceTo(u);
                  r < t.near ||
                    r > t.far ||
                    e.push({
                      distance: r,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              }
            } else
              n.isGeometry &&
                console.error(
                  "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        (exports.Line = Vu), (Vu.prototype.isLine = !0);
        const Wu = new xr(),
          ju = new xr();
        class qu extends Vu {
          constructor(t, e) {
            super(t, e), (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [];
                for (let t = 0, r = e.count; t < r; t += 2)
                  Wu.fromBufferAttribute(e, t),
                    ju.fromBufferAttribute(e, t + 1),
                    (n[t] = 0 === t ? 0 : n[t - 1]),
                    (n[t + 1] = n[t] + Wu.distanceTo(ju));
                t.setAttribute("lineDistance", new ns(n, 1));
              } else
                console.warn(
                  "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
        }
        (exports.LineSegments = qu), (qu.prototype.isLineSegments = !0);
        class Xu extends Vu {
          constructor(t, e) {
            super(t, e), (this.type = "LineLoop");
          }
        }
        (exports.LineLoop = Xu), (Xu.prototype.isLineLoop = !0);
        class Yu extends Ni {
          constructor(t) {
            super(),
              (this.type = "PointsMaterial"),
              (this.color = new Vi(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        (exports.PointsMaterial = Yu), (Yu.prototype.isPointsMaterial = !0);
        const Zu = new Yr(),
          Ju = new Xr(),
          Qu = new Or(),
          Ku = new xr();
        class $u extends yi {
          constructor(t = new ms(), e = new Yu()) {
            super(),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              r = this.matrixWorld,
              i = t.params.Points.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
                Qu.copy(n.boundingSphere),
                Qu.applyMatrix4(r),
                (Qu.radius += i),
                !1 === t.ray.intersectsSphere(Qu))
            )
              return;
            Zu.copy(r).invert(), Ju.copy(t.ray).applyMatrix4(Zu);
            const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              a = o * o;
            if (n.isBufferGeometry) {
              const i = n.index,
                o = n.attributes.position;
              if (null !== i) {
                for (
                  let n = Math.max(0, s.start),
                  l = Math.min(i.count, s.start + s.count);
                  n < l;
                  n++
                ) {
                  const s = i.getX(n);
                  Ku.fromBufferAttribute(o, s), tp(Ku, s, a, r, t, e, this);
                }
              } else {
                for (
                  let n = Math.max(0, s.start),
                  i = Math.min(o.count, s.start + s.count);
                  n < i;
                  n++
                )
                  Ku.fromBufferAttribute(o, n), tp(Ku, n, a, r, t, e, this);
              }
            } else
              console.error(
                "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        function tp(t, e, n, r, i, s, o) {
          const a = Ju.distanceSqToPoint(t);
          if (a < n) {
            const n = new xr();
            Ju.closestPointToPoint(t, n), n.applyMatrix4(r);
            const l = i.ray.origin.distanceTo(n);
            if (l < i.near || l > i.far) return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(a),
              point: n,
              index: e,
              face: null,
              object: o,
            });
          }
        }
        (exports.Points = $u), ($u.prototype.isPoints = !0);
        class ep extends hr {
          constructor(t, e, n, r, i, s, o, a, l) {
            super(t, e, n, r, i, s, o, a, l),
              (this.format = void 0 !== o ? o : Bt),
              (this.minFilter = void 0 !== s ? s : gt),
              (this.magFilter = void 0 !== i ? i : gt),
              (this.generateMipmaps = !1);
            const c = this;
            "requestVideoFrameCallback" in t &&
              t.requestVideoFrameCallback(function e() {
                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            const t = this.image;
            !1 === "requestVideoFrameCallback" in t &&
              t.readyState >= t.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        }
        (exports.VideoTexture = ep), (ep.prototype.isVideoTexture = !0);
        class np extends hr {
          constructor(t, e, n, r, i, s, o, a, l, c, h, u) {
            super(null, s, o, a, l, c, r, i, h, u),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        (exports.CompressedTexture = np),
          (np.prototype.isCompressedTexture = !0);
        class rp extends hr {
          constructor(t, e, n, r, i, s, o, a, l) {
            super(t, e, n, r, i, s, o, a, l), (this.needsUpdate = !0);
          }
        }
        (exports.CanvasTexture = rp), (rp.prototype.isCanvasTexture = !0);
        class ip extends hr {
          constructor(t, e, n, r, i, s, o, a, l, c) {
            if ((c = void 0 !== c ? c : Ot) !== Ot && c !== Ht)
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === n && c === Ot && (n = St),
              void 0 === n && c === Ht && (n = Dt),
              super(null, r, i, s, o, a, c, n, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== o ? o : ut),
              (this.minFilter = void 0 !== a ? a : ut),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        (exports.DepthTexture = ip), (ip.prototype.isDepthTexture = !0);
        class sp extends ms {
          constructor(t = 1, e = 8, n = 0, r = 2 * Math.PI) {
            super(),
              (this.type = "CircleGeometry"),
              (this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: r,
              }),
              (e = Math.max(3, e));
            const i = [],
              s = [],
              o = [],
              a = [],
              l = new xr(),
              c = new sr();
            s.push(0, 0, 0), o.push(0, 0, 1), a.push(0.5, 0.5);
            for (let h = 0, u = 3; h <= e; h++, u += 3) {
              const i = n + (h / e) * r;
              (l.x = t * Math.cos(i)),
                (l.y = t * Math.sin(i)),
                s.push(l.x, l.y, l.z),
                o.push(0, 0, 1),
                (c.x = (s[u] / t + 1) / 2),
                (c.y = (s[u + 1] / t + 1) / 2),
                a.push(c.x, c.y);
            }
            for (let h = 1; h <= e; h++) i.push(h, h + 1, 0);
            this.setIndex(i),
              this.setAttribute("position", new ns(s, 3)),
              this.setAttribute("normal", new ns(o, 3)),
              this.setAttribute("uv", new ns(a, 2));
          }
        }
        exports.CircleGeometry = exports.CircleBufferGeometry = sp;
        class op extends ms {
          constructor(
            t = 1,
            e = 1,
            n = 1,
            r = 8,
            i = 1,
            s = !1,
            o = 0,
            a = 2 * Math.PI
          ) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: r,
                heightSegments: i,
                openEnded: s,
                thetaStart: o,
                thetaLength: a,
              });
            const l = this;
            (r = Math.floor(r)), (i = Math.floor(i));
            const c = [],
              h = [],
              u = [],
              p = [];
            let d = 0;
            const m = [],
              f = n / 2;
            let g = 0;
            function x(n) {
              const i = d,
                s = new sr(),
                m = new xr();
              let x = 0;
              const v = !0 === n ? t : e,
                y = !0 === n ? 1 : -1;
              for (let t = 1; t <= r; t++)
                h.push(0, f * y, 0), u.push(0, y, 0), p.push(0.5, 0.5), d++;
              const _ = d;
              for (let t = 0; t <= r; t++) {
                const e = (t / r) * a + o,
                  n = Math.cos(e),
                  i = Math.sin(e);
                (m.x = v * i),
                  (m.y = f * y),
                  (m.z = v * n),
                  h.push(m.x, m.y, m.z),
                  u.push(0, y, 0),
                  (s.x = 0.5 * n + 0.5),
                  (s.y = 0.5 * i * y + 0.5),
                  p.push(s.x, s.y),
                  d++;
              }
              for (let t = 0; t < r; t++) {
                const e = i + t,
                  r = _ + t;
                !0 === n ? c.push(r, r + 1, e) : c.push(r + 1, r, e), (x += 3);
              }
              l.addGroup(g, x, !0 === n ? 1 : 2), (g += x);
            }
            !(function () {
              const s = new xr(),
                x = new xr();
              let v = 0;
              const y = (e - t) / n;
              for (let l = 0; l <= i; l++) {
                const c = [],
                  g = l / i,
                  v = g * (e - t) + t;
                for (let t = 0; t <= r; t++) {
                  const e = t / r,
                    i = e * a + o,
                    l = Math.sin(i),
                    m = Math.cos(i);
                  (x.x = v * l),
                    (x.y = -g * n + f),
                    (x.z = v * m),
                    h.push(x.x, x.y, x.z),
                    s.set(l, y, m).normalize(),
                    u.push(s.x, s.y, s.z),
                    p.push(e, 1 - g),
                    c.push(d++);
                }
                m.push(c);
              }
              for (let t = 0; t < r; t++)
                for (let e = 0; e < i; e++) {
                  const n = m[e][t],
                    r = m[e + 1][t],
                    i = m[e + 1][t + 1],
                    s = m[e][t + 1];
                  c.push(n, r, s), c.push(r, i, s), (v += 6);
                }
              l.addGroup(g, v, 0), (g += v);
            })(),
              !1 === s && (t > 0 && x(!0), e > 0 && x(!1)),
              this.setIndex(c),
              this.setAttribute("position", new ns(h, 3)),
              this.setAttribute("normal", new ns(u, 3)),
              this.setAttribute("uv", new ns(p, 2));
          }
        }
        exports.CylinderGeometry = exports.CylinderBufferGeometry = op;
        class ap extends op {
          constructor(
            t = 1,
            e = 1,
            n = 8,
            r = 1,
            i = !1,
            s = 0,
            o = 2 * Math.PI
          ) {
            super(0, t, e, n, r, i, s, o),
              (this.type = "ConeGeometry"),
              (this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: r,
                openEnded: i,
                thetaStart: s,
                thetaLength: o,
              });
          }
        }
        exports.ConeGeometry = exports.ConeBufferGeometry = ap;
        class lp extends ms {
          constructor(t, e, n = 1, r = 0) {
            super(),
              (this.type = "PolyhedronGeometry"),
              (this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: r,
              });
            const i = [],
              s = [];
            function o(t, e, n, r) {
              const i = r + 1,
                s = [];
              for (let o = 0; o <= i; o++) {
                s[o] = [];
                const r = t.clone().lerp(n, o / i),
                  a = e.clone().lerp(n, o / i),
                  l = i - o;
                for (let t = 0; t <= l; t++)
                  s[o][t] = 0 === t && o === i ? r : r.clone().lerp(a, t / l);
              }
              for (let o = 0; o < i; o++)
                for (let t = 0; t < 2 * (i - o) - 1; t++) {
                  const e = Math.floor(t / 2);
                  t % 2 == 0
                    ? (a(s[o][e + 1]), a(s[o + 1][e]), a(s[o][e]))
                    : (a(s[o][e + 1]), a(s[o + 1][e + 1]), a(s[o + 1][e]));
                }
            }
            function a(t) {
              i.push(t.x, t.y, t.z);
            }
            function l(e, n) {
              const r = 3 * e;
              (n.x = t[r + 0]), (n.y = t[r + 1]), (n.z = t[r + 2]);
            }
            function c(t, e, n, r) {
              r < 0 && 1 === t.x && (s[e] = t.x - 1),
                0 === n.x && 0 === n.z && (s[e] = r / 2 / Math.PI + 0.5);
            }
            function h(t) {
              return Math.atan2(t.z, -t.x);
            }
            !(function (t) {
              const n = new xr(),
                r = new xr(),
                i = new xr();
              for (let s = 0; s < e.length; s += 3)
                l(e[s + 0], n), l(e[s + 1], r), l(e[s + 2], i), o(n, r, i, t);
            })(r),
              (function (t) {
                const e = new xr();
                for (let n = 0; n < i.length; n += 3)
                  (e.x = i[n + 0]),
                    (e.y = i[n + 1]),
                    (e.z = i[n + 2]),
                    e.normalize().multiplyScalar(t),
                    (i[n + 0] = e.x),
                    (i[n + 1] = e.y),
                    (i[n + 2] = e.z);
              })(n),
              (function () {
                const t = new xr();
                for (let n = 0; n < i.length; n += 3) {
                  (t.x = i[n + 0]), (t.y = i[n + 1]), (t.z = i[n + 2]);
                  const r = h(t) / 2 / Math.PI + 0.5,
                    o =
                      ((e = t),
                        Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
                        Math.PI +
                        0.5);
                  s.push(r, 1 - o);
                }
                var e;
                (function () {
                  const t = new xr(),
                    e = new xr(),
                    n = new xr(),
                    r = new xr(),
                    o = new sr(),
                    a = new sr(),
                    l = new sr();
                  for (let u = 0, p = 0; u < i.length; u += 9, p += 6) {
                    t.set(i[u + 0], i[u + 1], i[u + 2]),
                      e.set(i[u + 3], i[u + 4], i[u + 5]),
                      n.set(i[u + 6], i[u + 7], i[u + 8]),
                      o.set(s[p + 0], s[p + 1]),
                      a.set(s[p + 2], s[p + 3]),
                      l.set(s[p + 4], s[p + 5]),
                      r.copy(t).add(e).add(n).divideScalar(3);
                    const d = h(r);
                    c(o, p + 0, t, d), c(a, p + 2, e, d), c(l, p + 4, n, d);
                  }
                })(),
                  (function () {
                    for (let t = 0; t < s.length; t += 6) {
                      const e = s[t + 0],
                        n = s[t + 2],
                        r = s[t + 4],
                        i = Math.max(e, n, r),
                        o = Math.min(e, n, r);
                      i > 0.9 &&
                        o < 0.1 &&
                        (e < 0.2 && (s[t + 0] += 1),
                          n < 0.2 && (s[t + 2] += 1),
                          r < 0.2 && (s[t + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute("position", new ns(i, 3)),
              this.setAttribute("normal", new ns(i.slice(), 3)),
              this.setAttribute("uv", new ns(s, 2)),
              0 === r ? this.computeVertexNormals() : this.normalizeNormals();
          }
        }
        exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = lp;
        class cp extends lp {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
              r = 1 / n;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -r,
                -n,
                0,
                -r,
                n,
                0,
                r,
                -n,
                0,
                r,
                n,
                -r,
                -n,
                0,
                -r,
                n,
                0,
                r,
                -n,
                0,
                r,
                n,
                0,
                -n,
                0,
                -r,
                n,
                0,
                -r,
                -n,
                0,
                r,
                n,
                0,
                r,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              t,
              e
            ),
              (this.type = "DodecahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = cp;
        const hp = new xr(),
          up = new xr(),
          pp = new xr(),
          dp = new Bi();
        class mp extends ms {
          constructor(t, e) {
            if (
              (super(),
                (this.type = "EdgesGeometry"),
                (this.parameters = { thresholdAngle: e }),
                (e = void 0 !== e ? e : 1),
                !0 === t.isGeometry)
            )
              return void console.error(
                "THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
            const n = Math.pow(10, 4),
              r = Math.cos(Nn * e),
              i = t.getIndex(),
              s = t.getAttribute("position"),
              o = i ? i.count : s.count,
              a = [0, 0, 0],
              l = ["a", "b", "c"],
              c = new Array(3),
              h = {},
              u = [];
            for (let p = 0; p < o; p += 3) {
              i
                ? ((a[0] = i.getX(p)),
                  (a[1] = i.getX(p + 1)),
                  (a[2] = i.getX(p + 2)))
                : ((a[0] = p), (a[1] = p + 1), (a[2] = p + 2));
              const { a: t, b: e, c: o } = dp;
              if (
                (t.fromBufferAttribute(s, a[0]),
                  e.fromBufferAttribute(s, a[1]),
                  o.fromBufferAttribute(s, a[2]),
                  dp.getNormal(pp),
                  (c[0] = `${Math.round(t.x * n)},${Math.round(
                    t.y * n
                  )},${Math.round(t.z * n)}`),
                  (c[1] = `${Math.round(e.x * n)},${Math.round(
                    e.y * n
                  )},${Math.round(e.z * n)}`),
                  (c[2] = `${Math.round(o.x * n)},${Math.round(
                    o.y * n
                  )},${Math.round(o.z * n)}`),
                  c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
              )
                for (let n = 0; n < 3; n++) {
                  const t = (n + 1) % 3,
                    e = c[n],
                    i = c[t],
                    s = dp[l[n]],
                    o = dp[l[t]],
                    p = `${e}_${i}`,
                    d = `${i}_${e}`;
                  d in h && h[d]
                    ? (pp.dot(h[d].normal) <= r &&
                      (u.push(s.x, s.y, s.z), u.push(o.x, o.y, o.z)),
                      (h[d] = null))
                    : p in h ||
                    (h[p] = {
                      index0: a[n],
                      index1: a[t],
                      normal: pp.clone(),
                    });
                }
            }
            for (const p in h)
              if (h[p]) {
                const { index0: t, index1: e } = h[p];
                hp.fromBufferAttribute(s, t),
                  up.fromBufferAttribute(s, e),
                  u.push(hp.x, hp.y, hp.z),
                  u.push(up.x, up.y, up.z);
              }
            this.setAttribute("position", new ns(u, 3));
          }
        }
        exports.EdgesGeometry = mp;
        const fp = {
          triangulate: function (t, e, n) {
            n = n || 2;
            const r = e && e.length,
              i = r ? e[0] * n : t.length;
            let s = gp(t, 0, i, n, !0);
            const o = [];
            if (!s || s.next === s.prev) return o;
            let a, l, c, h, u, p, d;
            if ((r && (s = bp(t, e, s, n)), t.length > 80 * n)) {
              (a = c = t[0]), (l = h = t[1]);
              for (let e = n; e < i; e += n)
                (u = t[e]) < a && (a = u),
                  (p = t[e + 1]) < l && (l = p),
                  u > c && (c = u),
                  p > h && (h = p);
              d = 0 !== (d = Math.max(c - a, h - l)) ? 1 / d : 0;
            }
            return vp(s, o, n, a, l, d), o;
          },
        };
        function gp(t, e, n, r, i) {
          let s, o;
          if (i === qp(t, e, n, r) > 0)
            for (s = e; s < n; s += r) o = Vp(s, t[s], t[s + 1], o);
          else for (s = n - r; s >= e; s -= r) o = Vp(s, t[s], t[s + 1], o);
          return o && Fp(o, o.next) && (Wp(o), (o = o.next)), o;
        }
        function xp(t, e) {
          if (!t) return t;
          e || (e = t);
          let n,
            r = t;
          do {
            if (
              ((n = !1),
                r.steiner || (!Fp(r, r.next) && 0 !== Bp(r.prev, r, r.next)))
            )
              r = r.next;
            else {
              if ((Wp(r), (r = e = r.prev) === r.next)) break;
              n = !0;
            }
          } while (n || r !== e);
          return e;
        }
        function vp(t, e, n, r, i, s, o) {
          if (!t) return;
          !o && s && Lp(t, r, i, s);
          let a,
            l,
            c = t;
          for (; t.prev !== t.next;)
            if (((a = t.prev), (l = t.next), s ? _p(t, r, i, s) : yp(t)))
              e.push(a.i / n),
                e.push(t.i / n),
                e.push(l.i / n),
                Wp(t),
                (t = l.next),
                (c = l.next);
            else if ((t = l) === c) {
              o
                ? 1 === o
                  ? vp((t = Mp(xp(t), e, n)), e, n, r, i, s, 2)
                  : 2 === o && wp(t, e, n, r, i, s)
                : vp(xp(t), e, n, r, i, s, 1);
              break;
            }
        }
        function yp(t) {
          const e = t.prev,
            n = t,
            r = t.next;
          if (Bp(e, n, r) >= 0) return !1;
          let i = t.next.next;
          for (; i !== t.prev;) {
            if (
              Dp(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
              Bp(i.prev, i, i.next) >= 0
            )
              return !1;
            i = i.next;
          }
          return !0;
        }
        function _p(t, e, n, r) {
          const i = t.prev,
            s = t,
            o = t.next;
          if (Bp(i, s, o) >= 0) return !1;
          const a = i.x < s.x ? (i.x < o.x ? i.x : o.x) : s.x < o.x ? s.x : o.x,
            l = i.y < s.y ? (i.y < o.y ? i.y : o.y) : s.y < o.y ? s.y : o.y,
            c = i.x > s.x ? (i.x > o.x ? i.x : o.x) : s.x > o.x ? s.x : o.x,
            h = i.y > s.y ? (i.y > o.y ? i.y : o.y) : s.y > o.y ? s.y : o.y,
            u = Cp(a, l, e, n, r),
            p = Cp(c, h, e, n, r);
          let d = t.prevZ,
            m = t.nextZ;
          for (; d && d.z >= u && m && m.z <= p;) {
            if (
              d !== t.prev &&
              d !== t.next &&
              Dp(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) &&
              Bp(d.prev, d, d.next) >= 0
            )
              return !1;
            if (
              ((d = d.prevZ),
                m !== t.prev &&
                m !== t.next &&
                Dp(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) &&
                Bp(m.prev, m, m.next) >= 0)
            )
              return !1;
            m = m.nextZ;
          }
          for (; d && d.z >= u;) {
            if (
              d !== t.prev &&
              d !== t.next &&
              Dp(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) &&
              Bp(d.prev, d, d.next) >= 0
            )
              return !1;
            d = d.prevZ;
          }
          for (; m && m.z <= p;) {
            if (
              m !== t.prev &&
              m !== t.next &&
              Dp(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) &&
              Bp(m.prev, m, m.next) >= 0
            )
              return !1;
            m = m.nextZ;
          }
          return !0;
        }
        function Mp(t, e, n) {
          let r = t;
          do {
            const i = r.prev,
              s = r.next.next;
            !Fp(i, s) &&
              Np(i, r, r.next, s) &&
              Hp(i, s) &&
              Hp(s, i) &&
              (e.push(i.i / n),
                e.push(r.i / n),
                e.push(s.i / n),
                Wp(r),
                Wp(r.next),
                (r = t = s)),
              (r = r.next);
          } while (r !== t);
          return xp(r);
        }
        function wp(t, e, n, r, i, s) {
          let o = t;
          do {
            let t = o.next.next;
            for (; t !== o.prev;) {
              if (o.i !== t.i && Ip(o, t)) {
                let a = kp(o, t);
                return (
                  (o = xp(o, o.next)),
                  (a = xp(a, a.next)),
                  vp(o, e, n, r, i, s),
                  void vp(a, e, n, r, i, s)
                );
              }
              t = t.next;
            }
            o = o.next;
          } while (o !== t);
        }
        function bp(t, e, n, r) {
          const i = [];
          let s, o, a, l, c;
          for (s = 0, o = e.length; s < o; s++)
            (c = gp(
              t,
              (a = e[s] * r),
              (l = s < o - 1 ? e[s + 1] * r : t.length),
              r,
              !1
            )) === c.next && (c.steiner = !0),
              i.push(Pp(c));
          for (i.sort(Sp), s = 0; s < i.length; s++)
            Tp(i[s], n), (n = xp(n, n.next));
          return n;
        }
        function Sp(t, e) {
          return t.x - e.x;
        }
        function Tp(t, e) {
          if ((e = Ep(t, e))) {
            const n = kp(e, t);
            xp(e, e.next), xp(n, n.next);
          }
        }
        function Ep(t, e) {
          let n = e;
          const r = t.x,
            i = t.y;
          let s,
            o = -1 / 0;
          do {
            if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
              const t = n.x + ((i - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
              if (t <= r && t > o) {
                if (((o = t), t === r)) {
                  if (i === n.y) return n;
                  if (i === n.next.y) return n.next;
                }
                s = n.x < n.next.x ? n : n.next;
              }
            }
            n = n.next;
          } while (n !== e);
          if (!s) return null;
          if (r === o) return s;
          const a = s,
            l = s.x,
            c = s.y;
          let h,
            u = 1 / 0;
          n = s;
          do {
            r >= n.x &&
              n.x >= l &&
              r !== n.x &&
              Dp(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) &&
              ((h = Math.abs(i - n.y) / (r - n.x)),
                Hp(n, t) &&
                (h < u ||
                  (h === u && (n.x > s.x || (n.x === s.x && Ap(s, n))))) &&
                ((s = n), (u = h))),
              (n = n.next);
          } while (n !== a);
          return s;
        }
        function Ap(t, e) {
          return Bp(t.prev, t, e.prev) < 0 && Bp(e.next, t, t.next) < 0;
        }
        function Lp(t, e, n, r) {
          let i = t;
          do {
            null === i.z && (i.z = Cp(i.x, i.y, e, n, r)),
              (i.prevZ = i.prev),
              (i.nextZ = i.next),
              (i = i.next);
          } while (i !== t);
          (i.prevZ.nextZ = null), (i.prevZ = null), Rp(i);
        }
        function Rp(t) {
          let e,
            n,
            r,
            i,
            s,
            o,
            a,
            l,
            c = 1;
          do {
            for (n = t, t = null, s = null, o = 0; n;) {
              for (
                o++, r = n, a = 0, e = 0;
                e < c && (a++, (r = r.nextZ));
                e++
              );
              for (l = c; a > 0 || (l > 0 && r);)
                0 !== a && (0 === l || !r || n.z <= r.z)
                  ? ((i = n), (n = n.nextZ), a--)
                  : ((i = r), (r = r.nextZ), l--),
                  s ? (s.nextZ = i) : (t = i),
                  (i.prevZ = s),
                  (s = i);
              n = r;
            }
            (s.nextZ = null), (c *= 2);
          } while (o > 1);
          return t;
        }
        function Cp(t, e, n, r, i) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
                    (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function Pp(t) {
          let e = t,
            n = t;
          do {
            (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
          } while (e !== t);
          return n;
        }
        function Dp(t, e, n, r, i, s, o, a) {
          return (
            (i - o) * (e - a) - (t - o) * (s - a) >= 0 &&
            (t - o) * (r - a) - (n - o) * (e - a) >= 0 &&
            (n - o) * (s - a) - (i - o) * (r - a) >= 0
          );
        }
        function Ip(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !Op(t, e) &&
            ((Hp(t, e) &&
              Hp(e, t) &&
              Up(t, e) &&
              (Bp(t.prev, t, e.prev) || Bp(t, e.prev, e))) ||
              (Fp(t, e) &&
                Bp(t.prev, t, t.next) > 0 &&
                Bp(e.prev, e, e.next) > 0))
          );
        }
        function Bp(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
        }
        function Fp(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function Np(t, e, n, r) {
          const i = zp(Bp(t, e, n)),
            s = zp(Bp(t, e, r)),
            o = zp(Bp(n, r, t)),
            a = zp(Bp(n, r, e));
          return (
            (i !== s && o !== a) ||
            !(0 !== i || !Gp(t, n, e)) ||
            !(0 !== s || !Gp(t, r, e)) ||
            !(0 !== o || !Gp(n, t, r)) ||
            !(0 !== a || !Gp(n, e, r))
          );
        }
        function Gp(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          );
        }
        function zp(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function Op(t, e) {
          let n = t;
          do {
            if (
              n.i !== t.i &&
              n.next.i !== t.i &&
              n.i !== e.i &&
              n.next.i !== e.i &&
              Np(n, n.next, t, e)
            )
              return !0;
            n = n.next;
          } while (n !== t);
          return !1;
        }
        function Hp(t, e) {
          return Bp(t.prev, t, t.next) < 0
            ? Bp(t, e, t.next) >= 0 && Bp(t, t.prev, e) >= 0
            : Bp(t, e, t.prev) < 0 || Bp(t, t.next, e) < 0;
        }
        function Up(t, e) {
          let n = t,
            r = !1;
          const i = (t.x + e.x) / 2,
            s = (t.y + e.y) / 2;
          do {
            n.y > s != n.next.y > s &&
              n.next.y !== n.y &&
              i < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
              (r = !r),
              (n = n.next);
          } while (n !== t);
          return r;
        }
        function kp(t, e) {
          const n = new jp(t.i, t.x, t.y),
            r = new jp(e.i, e.x, e.y),
            i = t.next,
            s = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = i),
            (i.prev = n),
            (r.next = n),
            (n.prev = r),
            (s.next = r),
            (r.prev = s),
            r
          );
        }
        function Vp(t, e, n, r) {
          const i = new jp(t, e, n);
          return (
            r
              ? ((i.next = r.next),
                (i.prev = r),
                (r.next.prev = i),
                (r.next = i))
              : ((i.prev = i), (i.next = i)),
            i
          );
        }
        function Wp(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function jp(t, e, n) {
          (this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        function qp(t, e, n, r) {
          let i = 0;
          for (let s = e, o = n - r; s < n; s += r)
            (i += (t[o] - t[s]) * (t[s + 1] + t[o + 1])), (o = s);
          return i;
        }
        class Xp {
          static area(t) {
            const e = t.length;
            let n = 0;
            for (let r = e - 1, i = 0; i < e; r = i++)
              n += t[r].x * t[i].y - t[i].x * t[r].y;
            return 0.5 * n;
          }
          static isClockWise(t) {
            return Xp.area(t) < 0;
          }
          static triangulateShape(t, e) {
            const n = [],
              r = [],
              i = [];
            Yp(t), Zp(n, t);
            let s = t.length;
            e.forEach(Yp);
            for (let a = 0; a < e.length; a++)
              r.push(s), (s += e[a].length), Zp(n, e[a]);
            const o = fp.triangulate(n, r);
            for (let a = 0; a < o.length; a += 3) i.push(o.slice(a, a + 3));
            return i;
          }
        }
        function Yp(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function Zp(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
        }
        exports.ShapeUtils = Xp;
        class Jp extends ms {
          constructor(t, e) {
            super(),
              (this.type = "ExtrudeGeometry"),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t]);
            const n = this,
              r = [],
              i = [];
            for (let o = 0, a = t.length; o < a; o++) {
              s(t[o]);
            }
            function s(t) {
              const s = [],
                o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                a = void 0 !== e.steps ? e.steps : 1;
              let l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
              const m = e.extrudePath,
                f = void 0 !== e.UVGenerator ? e.UVGenerator : Qp;
              void 0 !== e.amount &&
                (console.warn(
                  "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                ),
                  (l = e.amount));
              let g,
                x,
                v,
                y,
                _,
                M = !1;
              m &&
                ((g = m.getSpacedPoints(a)),
                  (M = !0),
                  (c = !1),
                  (x = m.computeFrenetFrames(a, !1)),
                  (v = new xr()),
                  (y = new xr()),
                  (_ = new xr())),
                c || ((d = 0), (h = 0), (u = 0), (p = 0));
              const w = t.extractPoints(o);
              let b = w.shape;
              const S = w.holes;
              if (!Xp.isClockWise(b)) {
                b = b.reverse();
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  Xp.isClockWise(e) && (S[t] = e.reverse());
                }
              }
              const T = Xp.triangulateShape(b, S),
                E = b;
              for (let e = 0, n = S.length; e < n; e++) {
                const t = S[e];
                b = b.concat(t);
              }
              function A(t, e, n) {
                return (
                  e ||
                  console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  e.clone().multiplyScalar(n).add(t)
                );
              }
              const L = b.length,
                R = T.length;
              function C(t, e, n) {
                let r, i, s;
                const o = t.x - e.x,
                  a = t.y - e.y,
                  l = n.x - t.x,
                  c = n.y - t.y,
                  h = o * o + a * a,
                  u = o * c - a * l;
                if (Math.abs(u) > Number.EPSILON) {
                  const u = Math.sqrt(h),
                    p = Math.sqrt(l * l + c * c),
                    d = e.x - a / u,
                    m = e.y + o / u,
                    f =
                      ((n.x - c / p - d) * c - (n.y + l / p - m) * l) /
                      (o * c - a * l),
                    g = (r = d + o * f - t.x) * r + (i = m + a * f - t.y) * i;
                  if (g <= 2) return new sr(r, i);
                  s = Math.sqrt(g / 2);
                } else {
                  let t = !1;
                  o > Number.EPSILON
                    ? l > Number.EPSILON && (t = !0)
                    : o < -Number.EPSILON
                      ? l < -Number.EPSILON && (t = !0)
                      : Math.sign(a) === Math.sign(c) && (t = !0),
                    t
                      ? ((r = -a), (i = o), (s = Math.sqrt(h)))
                      : ((r = o), (i = a), (s = Math.sqrt(h / 2)));
                }
                return new sr(r / s, i / s);
              }
              const P = [];
              for (
                let e = 0, n = E.length, r = n - 1, i = e + 1;
                e < n;
                e++, r++, i++
              )
                r === n && (r = 0),
                  i === n && (i = 0),
                  (P[e] = C(E[e], E[r], E[i]));
              const D = [];
              let I,
                B = P.concat();
              for (let e = 0, n = S.length; e < n; e++) {
                const t = S[e];
                I = [];
                for (
                  let e = 0, n = t.length, r = n - 1, i = e + 1;
                  e < n;
                  e++, r++, i++
                )
                  r === n && (r = 0),
                    i === n && (i = 0),
                    (I[e] = C(t[e], t[r], t[i]));
                D.push(I), (B = B.concat(I));
              }
              for (let e = 0; e < d; e++) {
                const t = e / d,
                  n = h * Math.cos((t * Math.PI) / 2),
                  r = u * Math.sin((t * Math.PI) / 2) + p;
                for (let e = 0, i = E.length; e < i; e++) {
                  const t = A(E[e], P[e], r);
                  G(t.x, t.y, -n);
                }
                for (let e = 0, i = S.length; e < i; e++) {
                  const t = S[e];
                  I = D[e];
                  for (let e = 0, i = t.length; e < i; e++) {
                    const i = A(t[e], I[e], r);
                    G(i.x, i.y, -n);
                  }
                }
              }
              const F = u + p;
              for (let e = 0; e < L; e++) {
                const t = c ? A(b[e], B[e], F) : b[e];
                M
                  ? (y.copy(x.normals[0]).multiplyScalar(t.x),
                    v.copy(x.binormals[0]).multiplyScalar(t.y),
                    _.copy(g[0]).add(y).add(v),
                    G(_.x, _.y, _.z))
                  : G(t.x, t.y, 0);
              }
              for (let e = 1; e <= a; e++)
                for (let t = 0; t < L; t++) {
                  const n = c ? A(b[t], B[t], F) : b[t];
                  M
                    ? (y.copy(x.normals[e]).multiplyScalar(n.x),
                      v.copy(x.binormals[e]).multiplyScalar(n.y),
                      _.copy(g[e]).add(y).add(v),
                      G(_.x, _.y, _.z))
                    : G(n.x, n.y, (l / a) * e);
                }
              for (let e = d - 1; e >= 0; e--) {
                const t = e / d,
                  n = h * Math.cos((t * Math.PI) / 2),
                  r = u * Math.sin((t * Math.PI) / 2) + p;
                for (let e = 0, i = E.length; e < i; e++) {
                  const t = A(E[e], P[e], r);
                  G(t.x, t.y, l + n);
                }
                for (let e = 0, i = S.length; e < i; e++) {
                  const t = S[e];
                  I = D[e];
                  for (let e = 0, i = t.length; e < i; e++) {
                    const i = A(t[e], I[e], r);
                    M
                      ? G(i.x, i.y + g[a - 1].y, g[a - 1].x + n)
                      : G(i.x, i.y, l + n);
                  }
                }
              }
              function N(t, e) {
                let n = t.length;
                for (; --n >= 0;) {
                  const r = n;
                  let i = n - 1;
                  i < 0 && (i = t.length - 1);
                  for (let t = 0, n = a + 2 * d; t < n; t++) {
                    const n = L * t,
                      s = L * (t + 1);
                    O(e + r + n, e + i + n, e + i + s, e + r + s);
                  }
                }
              }
              function G(t, e, n) {
                s.push(t), s.push(e), s.push(n);
              }
              function z(t, e, i) {
                H(t), H(e), H(i);
                const s = r.length / 3,
                  o = f.generateTopUV(n, r, s - 3, s - 2, s - 1);
                U(o[0]), U(o[1]), U(o[2]);
              }
              function O(t, e, i, s) {
                H(t), H(e), H(s), H(e), H(i), H(s);
                const o = r.length / 3,
                  a = f.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
                U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3]);
              }
              function H(t) {
                r.push(s[3 * t + 0]),
                  r.push(s[3 * t + 1]),
                  r.push(s[3 * t + 2]);
              }
              function U(t) {
                i.push(t.x), i.push(t.y);
              }
              !(function () {
                const t = r.length / 3;
                if (c) {
                  let t = 0,
                    e = L * t;
                  for (let n = 0; n < R; n++) {
                    const t = T[n];
                    z(t[2] + e, t[1] + e, t[0] + e);
                  }
                  e = L * (t = a + 2 * d);
                  for (let n = 0; n < R; n++) {
                    const t = T[n];
                    z(t[0] + e, t[1] + e, t[2] + e);
                  }
                } else {
                  for (let t = 0; t < R; t++) {
                    const e = T[t];
                    z(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < R; t++) {
                    const e = T[t];
                    z(e[0] + L * a, e[1] + L * a, e[2] + L * a);
                  }
                }
                n.addGroup(t, r.length / 3 - t, 0);
              })(),
                (function () {
                  const t = r.length / 3;
                  let e = 0;
                  N(E, e), (e += E.length);
                  for (let n = 0, r = S.length; n < r; n++) {
                    const t = S[n];
                    N(t, e), (e += t.length);
                  }
                  n.addGroup(t, r.length / 3 - t, 1);
                })();
            }
            this.setAttribute("position", new ns(r, 3)),
              this.setAttribute("uv", new ns(i, 2)),
              this.computeVertexNormals();
          }
          toJSON() {
            const t = super.toJSON();
            return Kp(this.parameters.shapes, this.parameters.options, t);
          }
        }
        exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = Jp;
        const Qp = {
          generateTopUV: function (t, e, n, r, i) {
            const s = e[3 * n],
              o = e[3 * n + 1],
              a = e[3 * r],
              l = e[3 * r + 1],
              c = e[3 * i],
              h = e[3 * i + 1];
            return [new sr(s, o), new sr(a, l), new sr(c, h)];
          },
          generateSideWallUV: function (t, e, n, r, i, s) {
            const o = e[3 * n],
              a = e[3 * n + 1],
              l = e[3 * n + 2],
              c = e[3 * r],
              h = e[3 * r + 1],
              u = e[3 * r + 2],
              p = e[3 * i],
              d = e[3 * i + 1],
              m = e[3 * i + 2],
              f = e[3 * s],
              g = e[3 * s + 1],
              x = e[3 * s + 2];
            return Math.abs(a - h) < Math.abs(o - c)
              ? [
                new sr(o, 1 - l),
                new sr(c, 1 - u),
                new sr(p, 1 - m),
                new sr(f, 1 - x),
              ]
              : [
                new sr(a, 1 - l),
                new sr(h, 1 - u),
                new sr(d, 1 - m),
                new sr(g, 1 - x),
              ];
          },
        };
        function Kp(t, e, n) {
          if (((n.shapes = []), Array.isArray(t)))
            for (let r = 0, i = t.length; r < i; r++) {
              const e = t[r];
              n.shapes.push(e.uuid);
            }
          else n.shapes.push(t.uuid);
          return (
            void 0 !== e.extrudePath &&
            (n.options.extrudePath = e.extrudePath.toJSON()),
            n
          );
        }
        class $p extends lp {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              t,
              e
            ),
              (this.type = "IcosahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = $p;
        class td extends ms {
          constructor(t, e = 12, n = 0, r = 2 * Math.PI) {
            super(),
              (this.type = "LatheGeometry"),
              (this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: r,
              }),
              (e = Math.floor(e)),
              (r = On(r, 0, 2 * Math.PI));
            const i = [],
              s = [],
              o = [],
              a = 1 / e,
              l = new xr(),
              c = new sr();
            for (let h = 0; h <= e; h++) {
              const i = n + h * a * r,
                u = Math.sin(i),
                p = Math.cos(i);
              for (let n = 0; n <= t.length - 1; n++)
                (l.x = t[n].x * u),
                  (l.y = t[n].y),
                  (l.z = t[n].x * p),
                  s.push(l.x, l.y, l.z),
                  (c.x = h / e),
                  (c.y = n / (t.length - 1)),
                  o.push(c.x, c.y);
            }
            for (let h = 0; h < e; h++)
              for (let e = 0; e < t.length - 1; e++) {
                const n = e + h * t.length,
                  r = n,
                  s = n + t.length,
                  o = n + t.length + 1,
                  a = n + 1;
                i.push(r, s, a), i.push(s, o, a);
              }
            if (
              (this.setIndex(i),
                this.setAttribute("position", new ns(s, 3)),
                this.setAttribute("uv", new ns(o, 2)),
                this.computeVertexNormals(),
                r === 2 * Math.PI)
            ) {
              const n = this.attributes.normal.array,
                r = new xr(),
                i = new xr(),
                s = new xr(),
                o = e * t.length * 3;
              for (let e = 0, a = 0; e < t.length; e++, a += 3)
                (r.x = n[a + 0]),
                  (r.y = n[a + 1]),
                  (r.z = n[a + 2]),
                  (i.x = n[o + a + 0]),
                  (i.y = n[o + a + 1]),
                  (i.z = n[o + a + 2]),
                  s.addVectors(r, i).normalize(),
                  (n[a + 0] = n[o + a + 0] = s.x),
                  (n[a + 1] = n[o + a + 1] = s.y),
                  (n[a + 2] = n[o + a + 2] = s.z);
            }
          }
        }
        exports.LatheGeometry = exports.LatheBufferGeometry = td;
        class ed extends lp {
          constructor(t = 1, e = 0) {
            super(
              [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
              [
                0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
                1, 4, 2,
              ],
              t,
              e
            ),
              (this.type = "OctahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        exports.OctahedronGeometry = exports.OctahedronBufferGeometry = ed;
        class nd extends ms {
          constructor(t, e, n) {
            super(),
              (this.type = "ParametricGeometry"),
              (this.parameters = { func: t, slices: e, stacks: n });
            const r = [],
              i = [],
              s = [],
              o = [],
              a = new xr(),
              l = new xr(),
              c = new xr(),
              h = new xr(),
              u = new xr();
            t.length < 3 &&
              console.error(
                "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
              );
            const p = e + 1;
            for (let d = 0; d <= n; d++) {
              const r = d / n;
              for (let n = 0; n <= e; n++) {
                const p = n / e;
                t(p, r, l),
                  i.push(l.x, l.y, l.z),
                  p - 1e-5 >= 0
                    ? (t(p - 1e-5, r, c), h.subVectors(l, c))
                    : (t(p + 1e-5, r, c), h.subVectors(c, l)),
                  r - 1e-5 >= 0
                    ? (t(p, r - 1e-5, c), u.subVectors(l, c))
                    : (t(p, r + 1e-5, c), u.subVectors(c, l)),
                  a.crossVectors(h, u).normalize(),
                  s.push(a.x, a.y, a.z),
                  o.push(p, r);
              }
            }
            for (let d = 0; d < n; d++)
              for (let t = 0; t < e; t++) {
                const e = d * p + t,
                  n = d * p + t + 1,
                  i = (d + 1) * p + t + 1,
                  s = (d + 1) * p + t;
                r.push(e, n, s), r.push(n, i, s);
              }
            this.setIndex(r),
              this.setAttribute("position", new ns(i, 3)),
              this.setAttribute("normal", new ns(s, 3)),
              this.setAttribute("uv", new ns(o, 2));
          }
        }
        exports.ParametricGeometry = exports.ParametricBufferGeometry = nd;
        class rd extends ms {
          constructor(t = 0.5, e = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) {
            super(),
              (this.type = "RingGeometry"),
              (this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: r,
                thetaStart: i,
                thetaLength: s,
              }),
              (n = Math.max(3, n));
            const o = [],
              a = [],
              l = [],
              c = [];
            let h = t;
            const u = (e - t) / (r = Math.max(1, r)),
              p = new xr(),
              d = new sr();
            for (let m = 0; m <= r; m++) {
              for (let t = 0; t <= n; t++) {
                const r = i + (t / n) * s;
                (p.x = h * Math.cos(r)),
                  (p.y = h * Math.sin(r)),
                  a.push(p.x, p.y, p.z),
                  l.push(0, 0, 1),
                  (d.x = (p.x / e + 1) / 2),
                  (d.y = (p.y / e + 1) / 2),
                  c.push(d.x, d.y);
              }
              h += u;
            }
            for (let m = 0; m < r; m++) {
              const t = m * (n + 1);
              for (let e = 0; e < n; e++) {
                const r = e + t,
                  i = r,
                  s = r + n + 1,
                  a = r + n + 2,
                  l = r + 1;
                o.push(i, s, l), o.push(s, a, l);
              }
            }
            this.setIndex(o),
              this.setAttribute("position", new ns(a, 3)),
              this.setAttribute("normal", new ns(l, 3)),
              this.setAttribute("uv", new ns(c, 2));
          }
        }
        exports.RingGeometry = exports.RingBufferGeometry = rd;
        class id extends ms {
          constructor(t, e = 12) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.parameters = { shapes: t, curveSegments: e });
            const n = [],
              r = [],
              i = [],
              s = [];
            let o = 0,
              a = 0;
            if (!1 === Array.isArray(t)) l(t);
            else
              for (let c = 0; c < t.length; c++)
                l(t[c]), this.addGroup(o, a, c), (o += a), (a = 0);
            function l(t) {
              const o = r.length / 3,
                l = t.extractPoints(e);
              let c = l.shape;
              const h = l.holes;
              !1 === Xp.isClockWise(c) && (c = c.reverse());
              for (let e = 0, n = h.length; e < n; e++) {
                const t = h[e];
                !0 === Xp.isClockWise(t) && (h[e] = t.reverse());
              }
              const u = Xp.triangulateShape(c, h);
              for (let e = 0, n = h.length; e < n; e++) {
                const t = h[e];
                c = c.concat(t);
              }
              for (let e = 0, n = c.length; e < n; e++) {
                const t = c[e];
                r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y);
              }
              for (let e = 0, r = u.length; e < r; e++) {
                const t = u[e],
                  r = t[0] + o,
                  i = t[1] + o,
                  s = t[2] + o;
                n.push(r, i, s), (a += 3);
              }
            }
            this.setIndex(n),
              this.setAttribute("position", new ns(r, 3)),
              this.setAttribute("normal", new ns(i, 3)),
              this.setAttribute("uv", new ns(s, 2));
          }
          toJSON() {
            const t = super.toJSON();
            return sd(this.parameters.shapes, t);
          }
        }
        function sd(t, e) {
          if (((e.shapes = []), Array.isArray(t)))
            for (let n = 0, r = t.length; n < r; n++) {
              const r = t[n];
              e.shapes.push(r.uuid);
            }
          else e.shapes.push(t.uuid);
          return e;
        }
        exports.ShapeGeometry = exports.ShapeBufferGeometry = id;
        class od extends ms {
          constructor(
            t = 1,
            e = 8,
            n = 6,
            r = 0,
            i = 2 * Math.PI,
            s = 0,
            o = Math.PI
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: r,
                phiLength: i,
                thetaStart: s,
                thetaLength: o,
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)));
            const a = Math.min(s + o, Math.PI);
            let l = 0;
            const c = [],
              h = new xr(),
              u = new xr(),
              p = [],
              d = [],
              m = [],
              f = [];
            for (let g = 0; g <= n; g++) {
              const p = [],
                x = g / n;
              let v = 0;
              0 == g && 0 == s
                ? (v = 0.5 / e)
                : g == n && a == Math.PI && (v = -0.5 / e);
              for (let n = 0; n <= e; n++) {
                const a = n / e;
                (h.x = -t * Math.cos(r + a * i) * Math.sin(s + x * o)),
                  (h.y = t * Math.cos(s + x * o)),
                  (h.z = t * Math.sin(r + a * i) * Math.sin(s + x * o)),
                  d.push(h.x, h.y, h.z),
                  u.copy(h).normalize(),
                  m.push(u.x, u.y, u.z),
                  f.push(a + v, 1 - x),
                  p.push(l++);
              }
              c.push(p);
            }
            for (let g = 0; g < n; g++)
              for (let t = 0; t < e; t++) {
                const e = c[g][t + 1],
                  r = c[g][t],
                  i = c[g + 1][t],
                  o = c[g + 1][t + 1];
                (0 !== g || s > 0) && p.push(e, r, o),
                  (g !== n - 1 || a < Math.PI) && p.push(r, i, o);
              }
            this.setIndex(p),
              this.setAttribute("position", new ns(d, 3)),
              this.setAttribute("normal", new ns(m, 3)),
              this.setAttribute("uv", new ns(f, 2));
          }
        }
        exports.SphereGeometry = exports.SphereBufferGeometry = od;
        class ad extends lp {
          constructor(t = 1, e = 0) {
            super(
              [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
              [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
              t,
              e
            ),
              (this.type = "TetrahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = ad;
        class ld extends Jp {
          constructor(t, e = {}) {
            const n = e.font;
            if (!n || !n.isFont)
              return (
                console.error(
                  "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
                ),
                new ms()
              );
            const r = n.generateShapes(t, e.size);
            (e.depth = void 0 !== e.height ? e.height : 50),
              void 0 === e.bevelThickness && (e.bevelThickness = 10),
              void 0 === e.bevelSize && (e.bevelSize = 8),
              void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
              super(r, e),
              (this.type = "TextGeometry");
          }
        }
        exports.TextGeometry = exports.TextBufferGeometry = ld;
        class cd extends ms {
          constructor(t = 1, e = 0.4, n = 8, r = 6, i = 2 * Math.PI) {
            super(),
              (this.type = "TorusGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: r,
                arc: i,
              }),
              (n = Math.floor(n)),
              (r = Math.floor(r));
            const s = [],
              o = [],
              a = [],
              l = [],
              c = new xr(),
              h = new xr(),
              u = new xr();
            for (let p = 0; p <= n; p++)
              for (let s = 0; s <= r; s++) {
                const d = (s / r) * i,
                  m = (p / n) * Math.PI * 2;
                (h.x = (t + e * Math.cos(m)) * Math.cos(d)),
                  (h.y = (t + e * Math.cos(m)) * Math.sin(d)),
                  (h.z = e * Math.sin(m)),
                  o.push(h.x, h.y, h.z),
                  (c.x = t * Math.cos(d)),
                  (c.y = t * Math.sin(d)),
                  u.subVectors(h, c).normalize(),
                  a.push(u.x, u.y, u.z),
                  l.push(s / r),
                  l.push(p / n);
              }
            for (let p = 1; p <= n; p++)
              for (let t = 1; t <= r; t++) {
                const e = (r + 1) * p + t - 1,
                  n = (r + 1) * (p - 1) + t - 1,
                  i = (r + 1) * (p - 1) + t,
                  o = (r + 1) * p + t;
                s.push(e, n, o), s.push(n, i, o);
              }
            this.setIndex(s),
              this.setAttribute("position", new ns(o, 3)),
              this.setAttribute("normal", new ns(a, 3)),
              this.setAttribute("uv", new ns(l, 2));
          }
        }
        exports.TorusGeometry = exports.TorusBufferGeometry = cd;
        class hd extends ms {
          constructor(t = 1, e = 0.4, n = 64, r = 8, i = 2, s = 3) {
            super(),
              (this.type = "TorusKnotGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: n,
                radialSegments: r,
                p: i,
                q: s,
              }),
              (n = Math.floor(n)),
              (r = Math.floor(r));
            const o = [],
              a = [],
              l = [],
              c = [],
              h = new xr(),
              u = new xr(),
              p = new xr(),
              d = new xr(),
              m = new xr(),
              f = new xr(),
              g = new xr();
            for (let v = 0; v <= n; ++v) {
              const o = (v / n) * i * Math.PI * 2;
              x(o, i, s, t, p),
                x(o + 0.01, i, s, t, d),
                f.subVectors(d, p),
                g.addVectors(d, p),
                m.crossVectors(f, g),
                g.crossVectors(m, f),
                m.normalize(),
                g.normalize();
              for (let t = 0; t <= r; ++t) {
                const i = (t / r) * Math.PI * 2,
                  s = -e * Math.cos(i),
                  o = e * Math.sin(i);
                (h.x = p.x + (s * g.x + o * m.x)),
                  (h.y = p.y + (s * g.y + o * m.y)),
                  (h.z = p.z + (s * g.z + o * m.z)),
                  a.push(h.x, h.y, h.z),
                  u.subVectors(h, p).normalize(),
                  l.push(u.x, u.y, u.z),
                  c.push(v / n),
                  c.push(t / r);
              }
            }
            for (let v = 1; v <= n; v++)
              for (let t = 1; t <= r; t++) {
                const e = (r + 1) * (v - 1) + (t - 1),
                  n = (r + 1) * v + (t - 1),
                  i = (r + 1) * v + t,
                  s = (r + 1) * (v - 1) + t;
                o.push(e, n, s), o.push(n, i, s);
              }
            function x(t, e, n, r, i) {
              const s = Math.cos(t),
                o = Math.sin(t),
                a = (n / e) * t,
                l = Math.cos(a);
              (i.x = r * (2 + l) * 0.5 * s),
                (i.y = r * (2 + l) * o * 0.5),
                (i.z = r * Math.sin(a) * 0.5);
            }
            this.setIndex(o),
              this.setAttribute("position", new ns(a, 3)),
              this.setAttribute("normal", new ns(l, 3)),
              this.setAttribute("uv", new ns(c, 2));
          }
        }
        exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = hd;
        class ud extends ms {
          constructor(t, e = 64, n = 1, r = 8, i = !1) {
            super(),
              (this.type = "TubeGeometry"),
              (this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: r,
                closed: i,
              });
            const s = t.computeFrenetFrames(e, i);
            (this.tangents = s.tangents),
              (this.normals = s.normals),
              (this.binormals = s.binormals);
            const o = new xr(),
              a = new xr(),
              l = new sr();
            let c = new xr();
            const h = [],
              u = [],
              p = [],
              d = [];
            function m(i) {
              c = t.getPointAt(i / e, c);
              const l = s.normals[i],
                p = s.binormals[i];
              for (let t = 0; t <= r; t++) {
                const e = (t / r) * Math.PI * 2,
                  i = Math.sin(e),
                  s = -Math.cos(e);
                (a.x = s * l.x + i * p.x),
                  (a.y = s * l.y + i * p.y),
                  (a.z = s * l.z + i * p.z),
                  a.normalize(),
                  u.push(a.x, a.y, a.z),
                  (o.x = c.x + n * a.x),
                  (o.y = c.y + n * a.y),
                  (o.z = c.z + n * a.z),
                  h.push(o.x, o.y, o.z);
              }
            }
            !(function () {
              for (let t = 0; t < e; t++) m(t);
              m(!1 === i ? e : 0),
                (function () {
                  for (let t = 0; t <= e; t++)
                    for (let n = 0; n <= r; n++)
                      (l.x = t / e), (l.y = n / r), p.push(l.x, l.y);
                })(),
                (function () {
                  for (let t = 1; t <= e; t++)
                    for (let e = 1; e <= r; e++) {
                      const n = (r + 1) * (t - 1) + (e - 1),
                        i = (r + 1) * t + (e - 1),
                        s = (r + 1) * t + e,
                        o = (r + 1) * (t - 1) + e;
                      d.push(n, i, o), d.push(i, s, o);
                    }
                })();
            })(),
              this.setIndex(d),
              this.setAttribute("position", new ns(h, 3)),
              this.setAttribute("normal", new ns(u, 3)),
              this.setAttribute("uv", new ns(p, 2));
          }
          toJSON() {
            const t = super.toJSON();
            return (t.path = this.parameters.path.toJSON()), t;
          }
        }
        exports.TubeGeometry = exports.TubeBufferGeometry = ud;
        class pd extends ms {
          constructor(t) {
            if (
              (super(), (this.type = "WireframeGeometry"), !0 === t.isGeometry)
            )
              return void console.error(
                "THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
            const e = [],
              n = [0, 0],
              r = {},
              i = new xr();
            if (null !== t.index) {
              const s = t.attributes.position,
                o = t.index;
              let a = t.groups;
              0 === a.length &&
                (a = [{ start: 0, count: o.count, materialIndex: 0 }]);
              for (let t = 0, e = a.length; t < e; ++t) {
                const e = a[t],
                  i = e.start;
                for (let t = i, s = i + e.count; t < s; t += 3)
                  for (let e = 0; e < 3; e++) {
                    const i = o.getX(t + e),
                      s = o.getX(t + ((e + 1) % 3));
                    (n[0] = Math.min(i, s)), (n[1] = Math.max(i, s));
                    const a = n[0] + "," + n[1];
                    void 0 === r[a] && (r[a] = { index1: n[0], index2: n[1] });
                  }
              }
              for (const t in r) {
                const n = r[t];
                i.fromBufferAttribute(s, n.index1),
                  e.push(i.x, i.y, i.z),
                  i.fromBufferAttribute(s, n.index2),
                  e.push(i.x, i.y, i.z);
              }
            } else {
              const n = t.attributes.position;
              for (let t = 0, r = n.count / 3; t < r; t++)
                for (let s = 0; s < 3; s++) {
                  const r = 3 * t + s;
                  i.fromBufferAttribute(n, r), e.push(i.x, i.y, i.z);
                  const o = 3 * t + ((s + 1) % 3);
                  i.fromBufferAttribute(n, o), e.push(i.x, i.y, i.z);
                }
            }
            this.setAttribute("position", new ns(e, 3));
          }
        }
        exports.WireframeGeometry = pd;
        var dd = Object.freeze({
          __proto__: null,
          BoxGeometry: Fs,
          BoxBufferGeometry: Fs,
          CircleGeometry: sp,
          CircleBufferGeometry: sp,
          ConeGeometry: ap,
          ConeBufferGeometry: ap,
          CylinderGeometry: op,
          CylinderBufferGeometry: op,
          DodecahedronGeometry: cp,
          DodecahedronBufferGeometry: cp,
          EdgesGeometry: mp,
          ExtrudeGeometry: Jp,
          ExtrudeBufferGeometry: Jp,
          IcosahedronGeometry: $p,
          IcosahedronBufferGeometry: $p,
          LatheGeometry: td,
          LatheBufferGeometry: td,
          OctahedronGeometry: ed,
          OctahedronBufferGeometry: ed,
          ParametricGeometry: nd,
          ParametricBufferGeometry: nd,
          PlaneGeometry: to,
          PlaneBufferGeometry: to,
          PolyhedronGeometry: lp,
          PolyhedronBufferGeometry: lp,
          RingGeometry: rd,
          RingBufferGeometry: rd,
          ShapeGeometry: id,
          ShapeBufferGeometry: id,
          SphereGeometry: od,
          SphereBufferGeometry: od,
          TetrahedronGeometry: ad,
          TetrahedronBufferGeometry: ad,
          TextGeometry: ld,
          TextBufferGeometry: ld,
          TorusGeometry: cd,
          TorusBufferGeometry: cd,
          TorusKnotGeometry: hd,
          TorusKnotBufferGeometry: hd,
          TubeGeometry: ud,
          TubeBufferGeometry: ud,
          WireframeGeometry: pd,
        });
        class md extends Ni {
          constructor(t) {
            super(),
              (this.type = "ShadowMaterial"),
              (this.color = new Vi(0)),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), this;
          }
        }
        (exports.ShadowMaterial = md), (md.prototype.isShadowMaterial = !0);
        class fd extends Us {
          constructor(t) {
            super(t), (this.type = "RawShaderMaterial");
          }
        }
        (exports.RawShaderMaterial = fd),
          (fd.prototype.isRawShaderMaterial = !0);
        class gd extends Ni {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "" }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new Vi(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Vi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = rn),
              (this.normalScale = new sr(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              (this.vertexTangents = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "" }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              (this.vertexTangents = t.vertexTangents),
              this
            );
          }
        }
        (exports.MeshStandardMaterial = gd),
          (gd.prototype.isMeshStandardMaterial = !0);
        class xd extends gd {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.type = "MeshPhysicalMaterial"),
              (this.clearcoat = 0),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new sr(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.reflectivity = 0.5),
              Object.defineProperty(this, "ior", {
                get: function () {
                  return (
                    (1 + 0.4 * this.reflectivity) /
                    (1 - 0.4 * this.reflectivity)
                  );
                },
                set: function (t) {
                  this.reflectivity = On((2.5 * (t - 1)) / (t + 1), 0, 1);
                },
              }),
              (this.sheen = null),
              (this.transmission = 0),
              (this.transmissionMap = null),
              (this.thickness = 0.01),
              (this.thicknessMap = null),
              (this.attenuationDistance = 0),
              (this.attenuationColor = new Vi(1, 1, 1)),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.reflectivity = t.reflectivity),
              t.sheen
                ? (this.sheen = (this.sheen || new Vi()).copy(t.sheen))
                : (this.sheen = null),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              (this.thickness = t.thickness),
              (this.thicknessMap = t.thicknessMap),
              (this.attenuationDistance = t.attenuationDistance),
              this.attenuationColor.copy(t.attenuationColor),
              this
            );
          }
        }
        (exports.MeshPhysicalMaterial = xd),
          (xd.prototype.isMeshPhysicalMaterial = !0);
        class vd extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshPhongMaterial"),
              (this.color = new Vi(16777215)),
              (this.specular = new Vi(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Vi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = rn),
              (this.normalScale = new sr(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = q),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        (exports.MeshPhongMaterial = vd),
          (vd.prototype.isMeshPhongMaterial = !0);
        class yd extends Ni {
          constructor(t) {
            super(),
              (this.defines = { TOON: "" }),
              (this.type = "MeshToonMaterial"),
              (this.color = new Vi(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Vi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = rn),
              (this.normalScale = new sr(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        (exports.MeshToonMaterial = yd), (yd.prototype.isMeshToonMaterial = !0);
        class _d extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshNormalMaterial"),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = rn),
              (this.normalScale = new sr(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        (exports.MeshNormalMaterial = _d),
          (_d.prototype.isMeshNormalMaterial = !0);
        class Md extends Ni {
          constructor(t) {
            super(),
              (this.type = "MeshLambertMaterial"),
              (this.color = new Vi(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new Vi(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = q),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        (exports.MeshLambertMaterial = Md),
          (Md.prototype.isMeshLambertMaterial = !0);
        class wd extends Ni {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: "" }),
              (this.type = "MeshMatcapMaterial"),
              (this.color = new Vi(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = rn),
              (this.normalScale = new sr(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: "" }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        (exports.MeshMatcapMaterial = wd),
          (wd.prototype.isMeshMatcapMaterial = !0);
        class bd extends Gu {
          constructor(t) {
            super(),
              (this.type = "LineDashedMaterial"),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.scale = t.scale),
              (this.dashSize = t.dashSize),
              (this.gapSize = t.gapSize),
              this
            );
          }
        }
        (exports.LineDashedMaterial = bd),
          (bd.prototype.isLineDashedMaterial = !0);
        var Sd = Object.freeze({
          __proto__: null,
          ShadowMaterial: md,
          SpriteMaterial: nu,
          RawShaderMaterial: fd,
          ShaderMaterial: Us,
          PointsMaterial: Yu,
          MeshPhysicalMaterial: xd,
          MeshStandardMaterial: gd,
          MeshPhongMaterial: vd,
          MeshToonMaterial: yd,
          MeshNormalMaterial: _d,
          MeshLambertMaterial: Md,
          MeshDepthMaterial: Ih,
          MeshDistanceMaterial: Bh,
          MeshBasicMaterial: Wi,
          MeshMatcapMaterial: wd,
          LineDashedMaterial: bd,
          LineBasicMaterial: Gu,
          Material: Ni,
        });
        const Td = {
          arraySlice: function (t, e, n) {
            return Td.isTypedArray(t)
              ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
              : t.slice(e, n);
          },
          convertArray: function (t, e, n) {
            return !t || (!n && t.constructor === e)
              ? t
              : "number" == typeof e.BYTES_PER_ELEMENT
                ? new e(t)
                : Array.prototype.slice.call(t);
          },
          isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView);
          },
          getKeyframeOrder: function (t) {
            const e = t.length,
              n = new Array(e);
            for (let r = 0; r !== e; ++r) n[r] = r;
            return (
              n.sort(function (e, n) {
                return t[e] - t[n];
              }),
              n
            );
          },
          sortedArray: function (t, e, n) {
            const r = t.length,
              i = new t.constructor(r);
            for (let s = 0, o = 0; o !== r; ++s) {
              const r = n[s] * e;
              for (let n = 0; n !== e; ++n) i[o++] = t[r + n];
            }
            return i;
          },
          flattenJSON: function (t, e, n, r) {
            let i = 1,
              s = t[0];
            for (; void 0 !== s && void 0 === s[r];) s = t[i++];
            if (void 0 === s) return;
            let o = s[r];
            if (void 0 !== o)
              if (Array.isArray(o))
                do {
                  void 0 !== (o = s[r]) && (e.push(s.time), n.push.apply(n, o)),
                    (s = t[i++]);
                } while (void 0 !== s);
              else if (void 0 !== o.toArray)
                do {
                  void 0 !== (o = s[r]) &&
                    (e.push(s.time), o.toArray(n, n.length)),
                    (s = t[i++]);
                } while (void 0 !== s);
              else
                do {
                  void 0 !== (o = s[r]) && (e.push(s.time), n.push(o)),
                    (s = t[i++]);
                } while (void 0 !== s);
          },
          subclip: function (t, e, n, r, i = 30) {
            const s = t.clone();
            s.name = e;
            const o = [];
            for (let l = 0; l < s.tracks.length; ++l) {
              const t = s.tracks[l],
                e = t.getValueSize(),
                a = [],
                c = [];
              for (let s = 0; s < t.times.length; ++s) {
                const o = t.times[s] * i;
                if (!(o < n || o >= r)) {
                  a.push(t.times[s]);
                  for (let n = 0; n < e; ++n) c.push(t.values[s * e + n]);
                }
              }
              0 !== a.length &&
                ((t.times = Td.convertArray(a, t.times.constructor)),
                  (t.values = Td.convertArray(c, t.values.constructor)),
                  o.push(t));
            }
            s.tracks = o;
            let a = 1 / 0;
            for (let l = 0; l < s.tracks.length; ++l)
              a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
            for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
            return s.resetDuration(), s;
          },
          makeClipAdditive: function (t, e = 0, n = t, r = 30) {
            r <= 0 && (r = 30);
            const i = n.tracks.length,
              s = e / r;
            for (let o = 0; o < i; ++o) {
              const e = n.tracks[o],
                r = e.ValueTypeName;
              if ("bool" === r || "string" === r) continue;
              const i = t.tracks.find(function (t) {
                return t.name === e.name && t.ValueTypeName === r;
              });
              if (void 0 === i) continue;
              let a = 0;
              const l = e.getValueSize();
              e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (a = l / 3);
              let c = 0;
              const h = i.getValueSize();
              i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (c = h / 3);
              const u = e.times.length - 1;
              let p;
              if (s <= e.times[0]) {
                const t = a,
                  n = l - a;
                p = Td.arraySlice(e.values, t, n);
              } else if (s >= e.times[u]) {
                const t = u * l + a,
                  n = t + l - a;
                p = Td.arraySlice(e.values, t, n);
              } else {
                const t = e.createInterpolant(),
                  n = a,
                  r = l - a;
                t.evaluate(s), (p = Td.arraySlice(t.resultBuffer, n, r));
              }
              if ("quaternion" === r) {
                new gr().fromArray(p).normalize().conjugate().toArray(p);
              }
              const d = i.times.length;
              for (let t = 0; t < d; ++t) {
                const e = t * h + c;
                if ("quaternion" === r)
                  gr.multiplyQuaternionsFlat(i.values, e, p, 0, i.values, e);
                else {
                  const t = h - 2 * c;
                  for (let n = 0; n < t; ++n) i.values[e + n] -= p[n];
                }
              }
            }
            return (t.blendMode = Ve), t;
          },
        };
        exports.AnimationUtils = Td;
        class Ed {
          constructor(t, e, n, r) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== r ? r : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              r = e[n],
              i = e[n - 1];
            t: {
              e: {
                let s;
                n: {
                  r: if (!(t < r)) {
                    for (let s = n + 2; ;) {
                      if (void 0 === r) {
                        if (t < i) break r;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.afterEnd_(n - 1, t, i)
                        );
                      }
                      if (n === s) break;
                      if (((i = r), t < (r = e[++n]))) break e;
                    }
                    s = e.length;
                    break n;
                  }
                  if (t >= i) break t;
                  {
                    const o = e[1];
                    t < o && ((n = 2), (i = o));
                    for (let s = n - 2; ;) {
                      if (void 0 === i)
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, t, r)
                        );
                      if (n === s) break;
                      if (((r = i), t >= (i = e[--n - 1]))) break e;
                    }
                    (s = n), (n = 0);
                  }
                }
                for (; n < s;) {
                  const r = (n + s) >>> 1;
                  t < e[r] ? (s = r) : (n = r + 1);
                }
                if (((r = e[n]), void 0 === (i = e[n - 1])))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, r);
                if (void 0 === r)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, i, t)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, i, r);
            }
            return this.interpolate_(n, i, t, r);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              r = this.valueSize,
              i = t * r;
            for (let s = 0; s !== r; ++s) e[s] = n[i + s];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() { }
        }
        (exports.Interpolant = Ed),
          (Ed.prototype.beforeStart_ = Ed.prototype.copySampleValue_),
          (Ed.prototype.afterEnd_ = Ed.prototype.copySampleValue_);
        class Ad extends Ed {
          constructor(t, e, n, r) {
            super(t, e, n, r),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: Oe, endingEnd: Oe });
          }
          intervalChanged_(t, e, n) {
            const r = this.parameterPositions;
            let i = t - 2,
              s = t + 1,
              o = r[i],
              a = r[s];
            if (void 0 === o)
              switch (this.getSettings_().endingStart) {
                case He:
                  (i = t), (o = 2 * e - n);
                  break;
                case Ue:
                  o = e + r[(i = r.length - 2)] - r[i + 1];
                  break;
                default:
                  (i = t), (o = n);
              }
            if (void 0 === a)
              switch (this.getSettings_().endingEnd) {
                case He:
                  (s = t), (a = 2 * n - e);
                  break;
                case Ue:
                  (s = 1), (a = n + r[1] - r[0]);
                  break;
                default:
                  (s = t - 1), (a = e);
              }
            const l = 0.5 * (n - e),
              c = this.valueSize;
            (this._weightPrev = l / (e - o)),
              (this._weightNext = l / (a - n)),
              (this._offsetPrev = i * c),
              (this._offsetNext = s * c);
          }
          interpolate_(t, e, n, r) {
            const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              l = a - o,
              c = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              p = this._weightNext,
              d = (n - e) / (r - e),
              m = d * d,
              f = m * d,
              g = -u * f + 2 * u * m - u * d,
              x = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * d + 1,
              v = (-1 - p) * f + (1.5 + p) * m + 0.5 * d,
              y = p * f - p * m;
            for (let _ = 0; _ !== o; ++_)
              i[_] = g * s[c + _] + x * s[l + _] + v * s[a + _] + y * s[h + _];
            return i;
          }
        }
        exports.CubicInterpolant = Ad;
        class Ld extends Ed {
          constructor(t, e, n, r) {
            super(t, e, n, r);
          }
          interpolate_(t, e, n, r) {
            const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = t * o,
              l = a - o,
              c = (n - e) / (r - e),
              h = 1 - c;
            for (let u = 0; u !== o; ++u) i[u] = s[l + u] * h + s[a + u] * c;
            return i;
          }
        }
        exports.LinearInterpolant = Ld;
        class Rd extends Ed {
          constructor(t, e, n, r) {
            super(t, e, n, r);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        exports.DiscreteInterpolant = Rd;
        class Cd {
          constructor(t, e, n, r) {
            if (void 0 === t)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error(
                "THREE.KeyframeTrack: no keyframes in track named " + t
              );
            (this.name = t),
              (this.times = Td.convertArray(e, this.TimeBufferType)),
              (this.values = Td.convertArray(n, this.ValueBufferType)),
              this.setInterpolation(r || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = {
                name: t.name,
                times: Td.convertArray(t.times, Array),
                values: Td.convertArray(t.values, Array),
              };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new Rd(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new Ld(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new Ad(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case Ne:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case Ge:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case ze:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return Ne;
              case this.InterpolantFactoryMethodLinear:
                return Ge;
              case this.InterpolantFactoryMethodSmooth:
                return ze;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, r = e.length; n !== r; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              r = n.length;
            let i = 0,
              s = r - 1;
            for (; i !== r && n[i] < t;) ++i;
            for (; -1 !== s && n[s] > e;) --s;
            if ((++s, 0 !== i || s !== r)) {
              i >= s && (i = (s = Math.max(s, 1)) - 1);
              const t = this.getValueSize();
              (this.times = Td.arraySlice(n, i, s)),
                (this.values = Td.arraySlice(this.values, i * t, s * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
                (t = !1));
            const n = this.times,
              r = this.values,
              i = n.length;
            0 === i &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
                (t = !1));
            let s = null;
            for (let o = 0; o !== i; o++) {
              const e = n[o];
              if ("number" == typeof e && isNaN(e)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  o,
                  e
                ),
                  (t = !1);
                break;
              }
              if (null !== s && s > e) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  o,
                  e,
                  s
                ),
                  (t = !1);
                break;
              }
              s = e;
            }
            if (void 0 !== r && Td.isTypedArray(r))
              for (let o = 0, a = r.length; o !== a; ++o) {
                const e = r[o];
                if (isNaN(e)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    o,
                    e
                  ),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = Td.arraySlice(this.times),
              e = Td.arraySlice(this.values),
              n = this.getValueSize(),
              r = this.getInterpolation() === ze,
              i = t.length - 1;
            let s = 1;
            for (let o = 1; o < i; ++o) {
              let i = !1;
              const a = t[o];
              if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                if (r) i = !0;
                else {
                  const t = o * n,
                    r = t - n,
                    s = t + n;
                  for (let o = 0; o !== n; ++o) {
                    const n = e[t + o];
                    if (n !== e[r + o] || n !== e[s + o]) {
                      i = !0;
                      break;
                    }
                  }
                }
              if (i) {
                if (o !== s) {
                  t[s] = t[o];
                  const r = o * n,
                    i = s * n;
                  for (let t = 0; t !== n; ++t) e[i + t] = e[r + t];
                }
                ++s;
              }
            }
            if (i > 0) {
              t[s] = t[i];
              for (let t = i * n, r = s * n, o = 0; o !== n; ++o)
                e[r + o] = e[t + o];
              ++s;
            }
            return (
              s !== t.length
                ? ((this.times = Td.arraySlice(t, 0, s)),
                  (this.values = Td.arraySlice(e, 0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = Td.arraySlice(this.times, 0),
              e = Td.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (exports.KeyframeTrack = Cd),
          (Cd.prototype.TimeBufferType = Float32Array),
          (Cd.prototype.ValueBufferType = Float32Array),
          (Cd.prototype.DefaultInterpolation = Ge);
        class Pd extends Cd { }
        (exports.BooleanKeyframeTrack = Pd),
          (Pd.prototype.ValueTypeName = "bool"),
          (Pd.prototype.ValueBufferType = Array),
          (Pd.prototype.DefaultInterpolation = Ne),
          (Pd.prototype.InterpolantFactoryMethodLinear = void 0),
          (Pd.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Dd extends Cd { }
        (exports.ColorKeyframeTrack = Dd),
          (Dd.prototype.ValueTypeName = "color");
        class Id extends Cd { }
        (exports.NumberKeyframeTrack = Id),
          (Id.prototype.ValueTypeName = "number");
        class Bd extends Ed {
          constructor(t, e, n, r) {
            super(t, e, n, r);
          }
          interpolate_(t, e, n, r) {
            const i = this.resultBuffer,
              s = this.sampleValues,
              o = this.valueSize,
              a = (n - e) / (r - e);
            let l = t * o;
            for (let c = l + o; l !== c; l += 4)
              gr.slerpFlat(i, 0, s, l - o, s, l, a);
            return i;
          }
        }
        exports.QuaternionLinearInterpolant = Bd;
        class Fd extends Cd {
          InterpolantFactoryMethodLinear(t) {
            return new Bd(this.times, this.values, this.getValueSize(), t);
          }
        }
        (exports.QuaternionKeyframeTrack = Fd),
          (Fd.prototype.ValueTypeName = "quaternion"),
          (Fd.prototype.DefaultInterpolation = Ge),
          (Fd.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Nd extends Cd { }
        (exports.StringKeyframeTrack = Nd),
          (Nd.prototype.ValueTypeName = "string"),
          (Nd.prototype.ValueBufferType = Array),
          (Nd.prototype.DefaultInterpolation = Ne),
          (Nd.prototype.InterpolantFactoryMethodLinear = void 0),
          (Nd.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Gd extends Cd { }
        (exports.VectorKeyframeTrack = Gd),
          (Gd.prototype.ValueTypeName = "vector");
        class zd {
          constructor(t, e = -1, n, r = ke) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = r),
              (this.uuid = zn()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              r = 1 / (t.fps || 1);
            for (let s = 0, o = n.length; s !== o; ++s)
              e.push(Hd(n[s]).scale(r));
            const i = new this(t.name, t.duration, e, t.blendMode);
            return (i.uuid = t.uuid), i;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              r = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let i = 0, s = n.length; i !== s; ++i) e.push(Cd.toJSON(n[i]));
            return r;
          }
          static CreateFromMorphTargetSequence(t, e, n, r) {
            const i = e.length,
              s = [];
            for (let o = 0; o < i; o++) {
              let t = [],
                a = [];
              t.push((o + i - 1) % i, o, (o + 1) % i), a.push(0, 1, 0);
              const l = Td.getKeyframeOrder(t);
              (t = Td.sortedArray(t, 1, l)),
                (a = Td.sortedArray(a, 1, l)),
                r || 0 !== t[0] || (t.push(i), a.push(a[0])),
                s.push(
                  new Id(
                    ".morphTargetInfluences[" + e[o].name + "]",
                    t,
                    a
                  ).scale(1 / n)
                );
            }
            return new this(t, -1, s);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const r = {},
              i = /^([\w-]*?)([\d]+)$/;
            for (let o = 0, a = t.length; o < a; o++) {
              const e = t[o],
                n = e.name.match(i);
              if (n && n.length > 1) {
                const t = n[1];
                let i = r[t];
                i || (r[t] = i = []), i.push(e);
              }
            }
            const s = [];
            for (const o in r)
              s.push(this.CreateFromMorphTargetSequence(o, r[o], e, n));
            return s;
          }
          static parseAnimation(t, e) {
            if (!t)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            const n = function (t, e, n, r, i) {
              if (0 !== n.length) {
                const s = [],
                  o = [];
                Td.flattenJSON(n, s, o, r),
                  0 !== s.length && i.push(new t(e, s, o));
              }
            },
              r = [],
              i = t.name || "default",
              s = t.fps || 30,
              o = t.blendMode;
            let a = t.length || -1;
            const l = t.hierarchy || [];
            for (let c = 0; c < l.length; c++) {
              const t = l[c].keys;
              if (t && 0 !== t.length)
                if (t[0].morphTargets) {
                  const e = {};
                  let n;
                  for (n = 0; n < t.length; n++)
                    if (t[n].morphTargets)
                      for (let r = 0; r < t[n].morphTargets.length; r++)
                        e[t[n].morphTargets[r]] = -1;
                  for (const i in e) {
                    const e = [],
                      s = [];
                    for (let r = 0; r !== t[n].morphTargets.length; ++r) {
                      const r = t[n];
                      e.push(r.time), s.push(r.morphTarget === i ? 1 : 0);
                    }
                    r.push(new Id(".morphTargetInfluence[" + i + "]", e, s));
                  }
                  a = e.length * (s || 1);
                } else {
                  const i = ".bones[" + e[c].name + "]";
                  n(Gd, i + ".position", t, "pos", r),
                    n(Fd, i + ".quaternion", t, "rot", r),
                    n(Gd, i + ".scale", t, "scl", r);
                }
            }
            return 0 === r.length ? null : new this(i, a, r, o);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
              t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
              t.push(this.tracks[e].clone());
            return new this.constructor(
              this.name,
              this.duration,
              t,
              this.blendMode
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function Od(t) {
          switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return Id;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Gd;
            case "color":
              return Dd;
            case "quaternion":
              return Fd;
            case "bool":
            case "boolean":
              return Pd;
            case "string":
              return Nd;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
        }
        function Hd(t) {
          if (void 0 === t.type)
            throw new Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          const e = Od(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            Td.flattenJSON(t.keys, e, n, "value"),
              (t.times = e),
              (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        exports.AnimationClip = zd;
        const Ud = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        exports.Cache = Ud;
        class kd {
          constructor(t, e, n) {
            const r = this;
            let i = !1,
              s = 0,
              o = 0,
              a = void 0;
            const l = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                o++,
                  !1 === i && void 0 !== r.onStart && r.onStart(t, s, o),
                  (i = !0);
              }),
              (this.itemEnd = function (t) {
                s++,
                  void 0 !== r.onProgress && r.onProgress(t, s, o),
                  s === o && ((i = !1), void 0 !== r.onLoad && r.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== r.onError && r.onError(t);
              }),
              (this.resolveURL = function (t) {
                return a ? a(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (a = t), this;
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                  const n = l[e],
                    r = l[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return r;
                }
                return null;
              });
          }
        }
        exports.LoadingManager = kd;
        const Vd = new kd();
        exports.DefaultLoadingManager = Vd;
        class Wd {
          constructor(t) {
            (this.manager = void 0 !== t ? t : Vd),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() { }
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (r, i) {
              n.load(t, r, e, i);
            });
          }
          parse() { }
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        exports.Loader = Wd;
        const jd = {};
        class qd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = this,
              s = Ud.get(t);
            if (void 0 !== s)
              return (
                i.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), i.manager.itemEnd(t);
                }, 0),
                s
              );
            if (void 0 !== jd[t])
              return void jd[t].push({ onLoad: e, onProgress: n, onError: r });
            const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let a;
            if (o) {
              const n = o[1],
                s = !!o[2];
              let a = o[3];
              (a = decodeURIComponent(a)), s && (a = atob(a));
              try {
                let s;
                const o = (this.responseType || "").toLowerCase();
                switch (o) {
                  case "arraybuffer":
                  case "blob":
                    const t = new Uint8Array(a.length);
                    for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
                    s =
                      "blob" === o
                        ? new Blob([t.buffer], { type: n })
                        : t.buffer;
                    break;
                  case "document":
                    const e = new DOMParser();
                    s = e.parseFromString(a, n);
                    break;
                  case "json":
                    s = JSON.parse(a);
                    break;
                  default:
                    s = a;
                }
                setTimeout(function () {
                  e && e(s), i.manager.itemEnd(t);
                }, 0);
              } catch (l) {
                setTimeout(function () {
                  r && r(l), i.manager.itemError(t), i.manager.itemEnd(t);
                }, 0);
              }
            } else {
              (jd[t] = []),
                jd[t].push({ onLoad: e, onProgress: n, onError: r }),
                (a = new XMLHttpRequest()).open("GET", t, !0),
                a.addEventListener(
                  "load",
                  function (e) {
                    const n = this.response,
                      r = jd[t];
                    if (
                      (delete jd[t], 200 === this.status || 0 === this.status)
                    ) {
                      0 === this.status &&
                        console.warn(
                          "THREE.FileLoader: HTTP Status 0 received."
                        ),
                        Ud.add(t, n);
                      for (let t = 0, e = r.length; t < e; t++) {
                        const e = r[t];
                        e.onLoad && e.onLoad(n);
                      }
                      i.manager.itemEnd(t);
                    } else {
                      for (let t = 0, n = r.length; t < n; t++) {
                        const n = r[t];
                        n.onError && n.onError(e);
                      }
                      i.manager.itemError(t), i.manager.itemEnd(t);
                    }
                  },
                  !1
                ),
                a.addEventListener(
                  "progress",
                  function (e) {
                    const n = jd[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                      const r = n[t];
                      r.onProgress && r.onProgress(e);
                    }
                  },
                  !1
                ),
                a.addEventListener(
                  "error",
                  function (e) {
                    const n = jd[t];
                    delete jd[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                      const r = n[t];
                      r.onError && r.onError(e);
                    }
                    i.manager.itemError(t), i.manager.itemEnd(t);
                  },
                  !1
                ),
                a.addEventListener(
                  "abort",
                  function (e) {
                    const n = jd[t];
                    delete jd[t];
                    for (let t = 0, r = n.length; t < r; t++) {
                      const r = n[t];
                      r.onError && r.onError(e);
                    }
                    i.manager.itemError(t), i.manager.itemEnd(t);
                  },
                  !1
                ),
                void 0 !== this.responseType &&
                (a.responseType = this.responseType),
                void 0 !== this.withCredentials &&
                (a.withCredentials = this.withCredentials),
                a.overrideMimeType &&
                a.overrideMimeType(
                  void 0 !== this.mimeType ? this.mimeType : "text/plain"
                );
              for (const t in this.requestHeader)
                a.setRequestHeader(t, this.requestHeader[t]);
              a.send(null);
            }
            return i.manager.itemStart(t), a;
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        exports.FileLoader = qd;
        class Xd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = new qd(this.manager);
            s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(i.parse(JSON.parse(n)));
                  } catch (s) {
                    r ? r(s) : console.error(s), i.manager.itemError(t);
                  }
                },
                n,
                r
              );
          }
          parse(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) {
              const r = zd.parse(t[n]);
              e.push(r);
            }
            return e;
          }
        }
        exports.AnimationLoader = Xd;
        class Yd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = [],
              o = new np(),
              a = new qd(this.manager);
            a.setPath(this.path),
              a.setResponseType("arraybuffer"),
              a.setRequestHeader(this.requestHeader),
              a.setWithCredentials(i.withCredentials);
            let l = 0;
            function c(c) {
              a.load(
                t[c],
                function (t) {
                  const n = i.parse(t, !0);
                  (s[c] = {
                    width: n.width,
                    height: n.height,
                    format: n.format,
                    mipmaps: n.mipmaps,
                  }),
                    6 === (l += 1) &&
                    (1 === n.mipmapCount && (o.minFilter = gt),
                      (o.image = s),
                      (o.format = n.format),
                      (o.needsUpdate = !0),
                      e && e(o));
                },
                n,
                r
              );
            }
            if (Array.isArray(t))
              for (let h = 0, u = t.length; h < u; ++h) c(h);
            else
              a.load(
                t,
                function (t) {
                  const n = i.parse(t, !0);
                  if (n.isCubemap) {
                    const t = n.mipmaps.length / n.mipmapCount;
                    for (let e = 0; e < t; e++) {
                      s[e] = { mipmaps: [] };
                      for (let t = 0; t < n.mipmapCount; t++)
                        s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                          (s[e].format = n.format),
                          (s[e].width = n.width),
                          (s[e].height = n.height);
                    }
                    o.image = s;
                  } else
                    (o.image.width = n.width),
                      (o.image.height = n.height),
                      (o.mipmaps = n.mipmaps);
                  1 === n.mipmapCount && (o.minFilter = gt),
                    (o.format = n.format),
                    (o.needsUpdate = !0),
                    e && e(o);
                },
                n,
                r
              );
            return o;
          }
        }
        exports.CompressedTextureLoader = Yd;
        class Zd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = this,
              s = Ud.get(t);
            if (void 0 !== s)
              return (
                i.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), i.manager.itemEnd(t);
                }, 0),
                s
              );
            const o = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            function a() {
              o.removeEventListener("load", a, !1),
                o.removeEventListener("error", l, !1),
                Ud.add(t, this),
                e && e(this),
                i.manager.itemEnd(t);
            }
            function l(e) {
              o.removeEventListener("load", a, !1),
                o.removeEventListener("error", l, !1),
                r && r(e),
                i.manager.itemError(t),
                i.manager.itemEnd(t);
            }
            return (
              o.addEventListener("load", a, !1),
              o.addEventListener("error", l, !1),
              "data:" !== t.substr(0, 5) &&
              void 0 !== this.crossOrigin &&
              (o.crossOrigin = this.crossOrigin),
              i.manager.itemStart(t),
              (o.src = t),
              o
            );
          }
        }
        exports.ImageLoader = Zd;
        class Jd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = new Xs(),
              s = new Zd(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            let o = 0;
            function a(n) {
              s.load(
                t[n],
                function (t) {
                  (i.images[n] = t),
                    6 === ++o && ((i.needsUpdate = !0), e && e(i));
                },
                void 0,
                r
              );
            }
            for (let l = 0; l < t.length; ++l) a(l);
            return i;
          }
        }
        exports.CubeTextureLoader = Jd;
        class Qd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = new Lu(),
              o = new qd(this.manager);
            return (
              o.setResponseType("arraybuffer"),
              o.setRequestHeader(this.requestHeader),
              o.setPath(this.path),
              o.setWithCredentials(i.withCredentials),
              o.load(
                t,
                function (t) {
                  const n = i.parse(t);
                  n &&
                    (void 0 !== n.image
                      ? (s.image = n.image)
                      : void 0 !== n.data &&
                      ((s.image.width = n.width),
                        (s.image.height = n.height),
                        (s.image.data = n.data)),
                      (s.wrapS = void 0 !== n.wrapS ? n.wrapS : ct),
                      (s.wrapT = void 0 !== n.wrapT ? n.wrapT : ct),
                      (s.magFilter = void 0 !== n.magFilter ? n.magFilter : gt),
                      (s.minFilter = void 0 !== n.minFilter ? n.minFilter : gt),
                      (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                      void 0 !== n.encoding && (s.encoding = n.encoding),
                      void 0 !== n.flipY && (s.flipY = n.flipY),
                      void 0 !== n.format && (s.format = n.format),
                      void 0 !== n.type && (s.type = n.type),
                      void 0 !== n.mipmaps &&
                      ((s.mipmaps = n.mipmaps), (s.minFilter = yt)),
                      1 === n.mipmapCount && (s.minFilter = gt),
                      void 0 !== n.generateMipmaps &&
                      (s.generateMipmaps = n.generateMipmaps),
                      (s.needsUpdate = !0),
                      e && e(s, n));
                },
                n,
                r
              ),
              s
            );
          }
        }
        exports.DataTextureLoader = Qd;
        class Kd extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = new hr(),
              s = new Zd(this.manager);
            return (
              s.setCrossOrigin(this.crossOrigin),
              s.setPath(this.path),
              s.load(
                t,
                function (n) {
                  i.image = n;
                  const r =
                    t.search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === t.search(/^data\:image\/jpeg/);
                  (i.format = r ? Bt : Ft),
                    (i.needsUpdate = !0),
                    void 0 !== e && e(i);
                },
                n,
                r
              ),
              i
            );
          }
        }
        exports.TextureLoader = Kd;
        class $d {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          }
          getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e);
          }
          getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e;
          }
          getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e;
          }
          getLength() {
            const t = this.getLengths();
            return t[t.length - 1];
          }
          getLengths(t = this.arcLengthDivisions) {
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n,
              r = this.getPoint(0),
              i = 0;
            e.push(0);
            for (let s = 1; s <= t; s++)
              (i += (n = this.getPoint(s / t)).distanceTo(r)),
                e.push(i),
                (r = n);
            return (this.cacheArcLengths = e), e;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(t, e) {
            const n = this.getLengths();
            let r = 0;
            const i = n.length;
            let s;
            s = e || t * n[i - 1];
            let o,
              a = 0,
              l = i - 1;
            for (; a <= l;)
              if ((o = n[(r = Math.floor(a + (l - a) / 2))] - s) < 0) a = r + 1;
              else {
                if (!(o > 0)) {
                  l = r;
                  break;
                }
                l = r - 1;
              }
            if (n[(r = l)] === s) return r / (i - 1);
            const c = n[r];
            return (r + (s - c) / (n[r + 1] - c)) / (i - 1);
          }
          getTangent(t, e) {
            let n = t - 1e-4,
              r = t + 1e-4;
            n < 0 && (n = 0), r > 1 && (r = 1);
            const i = this.getPoint(n),
              s = this.getPoint(r),
              o = e || (i.isVector2 ? new sr() : new xr());
            return o.copy(s).sub(i).normalize(), o;
          }
          getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e);
          }
          computeFrenetFrames(t, e) {
            const n = new xr(),
              r = [],
              i = [],
              s = [],
              o = new xr(),
              a = new Yr();
            for (let p = 0; p <= t; p++) {
              const e = p / t;
              (r[p] = this.getTangentAt(e, new xr())), r[p].normalize();
            }
            (i[0] = new xr()), (s[0] = new xr());
            let l = Number.MAX_VALUE;
            const c = Math.abs(r[0].x),
              h = Math.abs(r[0].y),
              u = Math.abs(r[0].z);
            c <= l && ((l = c), n.set(1, 0, 0)),
              h <= l && ((l = h), n.set(0, 1, 0)),
              u <= l && n.set(0, 0, 1),
              o.crossVectors(r[0], n).normalize(),
              i[0].crossVectors(r[0], o),
              s[0].crossVectors(r[0], i[0]);
            for (let p = 1; p <= t; p++) {
              if (
                ((i[p] = i[p - 1].clone()),
                  (s[p] = s[p - 1].clone()),
                  o.crossVectors(r[p - 1], r[p]),
                  o.length() > Number.EPSILON)
              ) {
                o.normalize();
                const t = Math.acos(On(r[p - 1].dot(r[p]), -1, 1));
                i[p].applyMatrix4(a.makeRotationAxis(o, t));
              }
              s[p].crossVectors(r[p], i[p]);
            }
            if (!0 === e) {
              let e = Math.acos(On(i[0].dot(i[t]), -1, 1));
              (e /= t), r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
              for (let n = 1; n <= t; n++)
                i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)),
                  s[n].crossVectors(r[n], i[n]);
            }
            return { tangents: r, normals: i, binormals: s };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (t.arcLengthDivisions = this.arcLengthDivisions),
              (t.type = this.type),
              t
            );
          }
          fromJSON(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
        }
        exports.Curve = $d;
        class tm extends $d {
          constructor(
            t = 0,
            e = 0,
            n = 1,
            r = 1,
            i = 0,
            s = 2 * Math.PI,
            o = !1,
            a = 0
          ) {
            super(),
              (this.type = "EllipseCurve"),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = r),
              (this.aStartAngle = i),
              (this.aEndAngle = s),
              (this.aClockwise = o),
              (this.aRotation = a);
          }
          getPoint(t, e) {
            const n = e || new sr(),
              r = 2 * Math.PI;
            let i = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(i) < Number.EPSILON;
            for (; i < 0;) i += r;
            for (; i > r;) i -= r;
            i < Number.EPSILON && (i = s ? 0 : r),
              !0 !== this.aClockwise || s || (i === r ? (i = -r) : (i -= r));
            const o = this.aStartAngle + t * i;
            let a = this.aX + this.xRadius * Math.cos(o),
              l = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = a - this.aX,
                r = l - this.aY;
              (a = n * t - r * e + this.aX), (l = n * e + r * t + this.aY);
            }
            return n.set(a, l);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
        }
        (exports.EllipseCurve = tm), (tm.prototype.isEllipseCurve = !0);
        class em extends tm {
          constructor(t, e, n, r, i, s) {
            super(t, e, n, n, r, i, s), (this.type = "ArcCurve");
          }
        }
        function nm() {
          let t = 0,
            e = 0,
            n = 0,
            r = 0;
          function i(i, s, o, a) {
            (t = i),
              (e = o),
              (n = -3 * i + 3 * s - 2 * o - a),
              (r = 2 * i - 2 * s + o + a);
          }
          return {
            initCatmullRom: function (t, e, n, r, s) {
              i(e, n, s * (n - t), s * (r - e));
            },
            initNonuniformCatmullRom: function (t, e, n, r, s, o, a) {
              let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                c = (n - e) / o - (r - e) / (o + a) + (r - n) / a;
              i(e, n, (l *= o), (c *= o));
            },
            calc: function (i) {
              const s = i * i;
              return t + e * i + n * s + r * (s * i);
            },
          };
        }
        (exports.ArcCurve = em), (em.prototype.isArcCurve = !0);
        const rm = new xr(),
          im = new nm(),
          sm = new nm(),
          om = new nm();
        class am extends $d {
          constructor(t = [], e = !1, n = "centripetal", r = 0.5) {
            super(),
              (this.type = "CatmullRomCurve3"),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = r);
          }
          getPoint(t, e = new xr()) {
            const n = e,
              r = this.points,
              i = r.length,
              s = (i - (this.closed ? 0 : 1)) * t;
            let o,
              a,
              l = Math.floor(s),
              c = s - l;
            this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i)
              : 0 === c && l === i - 1 && ((l = i - 2), (c = 1)),
              this.closed || l > 0
                ? (o = r[(l - 1) % i])
                : (rm.subVectors(r[0], r[1]).add(r[0]), (o = rm));
            const h = r[l % i],
              u = r[(l + 1) % i];
            if (
              (this.closed || l + 2 < i
                ? (a = r[(l + 2) % i])
                : (rm.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), (a = rm)),
                "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              const t = "chordal" === this.curveType ? 0.5 : 0.25;
              let e = Math.pow(o.distanceToSquared(h), t),
                n = Math.pow(h.distanceToSquared(u), t),
                r = Math.pow(u.distanceToSquared(a), t);
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                r < 1e-4 && (r = n),
                im.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, r),
                sm.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, r),
                om.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, r);
            } else
              "catmullrom" === this.curveType &&
                (im.initCatmullRom(o.x, h.x, u.x, a.x, this.tension),
                  sm.initCatmullRom(o.y, h.y, u.y, a.y, this.tension),
                  om.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
            return n.set(im.calc(c), sm.calc(c), om.calc(c)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return (
              (t.closed = this.closed),
              (t.curveType = this.curveType),
              (t.tension = this.tension),
              t
            );
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new xr().fromArray(n));
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
        }
        function lm(t, e, n, r, i) {
          const s = 0.5 * (r - e),
            o = 0.5 * (i - n),
            a = t * t;
          return (
            (2 * n - 2 * r + s + o) * (t * a) +
            (-3 * n + 3 * r - 2 * s - o) * a +
            s * t +
            n
          );
        }
        function cm(t, e) {
          const n = 1 - t;
          return n * n * e;
        }
        function hm(t, e) {
          return 2 * (1 - t) * t * e;
        }
        function um(t, e) {
          return t * t * e;
        }
        function pm(t, e, n, r) {
          return cm(t, e) + hm(t, n) + um(t, r);
        }
        function dm(t, e) {
          const n = 1 - t;
          return n * n * n * e;
        }
        function mm(t, e) {
          const n = 1 - t;
          return 3 * n * n * t * e;
        }
        function fm(t, e) {
          return 3 * (1 - t) * t * t * e;
        }
        function gm(t, e) {
          return t * t * t * e;
        }
        function xm(t, e, n, r, i) {
          return dm(t, e) + mm(t, n) + fm(t, r) + gm(t, i);
        }
        (exports.CatmullRomCurve3 = am), (am.prototype.isCatmullRomCurve3 = !0);
        class vm extends $d {
          constructor(t = new sr(), e = new sr(), n = new sr(), r = new sr()) {
            super(),
              (this.type = "CubicBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = r);
          }
          getPoint(t, e = new sr()) {
            const n = e,
              r = this.v0,
              i = this.v1,
              s = this.v2,
              o = this.v3;
            return (
              n.set(xm(t, r.x, i.x, s.x, o.x), xm(t, r.y, i.y, s.y, o.y)), n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        (exports.CubicBezierCurve = vm), (vm.prototype.isCubicBezierCurve = !0);
        class ym extends $d {
          constructor(t = new xr(), e = new xr(), n = new xr(), r = new xr()) {
            super(),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = r);
          }
          getPoint(t, e = new xr()) {
            const n = e,
              r = this.v0,
              i = this.v1,
              s = this.v2,
              o = this.v3;
            return (
              n.set(
                xm(t, r.x, i.x, s.x, o.x),
                xm(t, r.y, i.y, s.y, o.y),
                xm(t, r.z, i.z, s.z, o.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        (exports.CubicBezierCurve3 = ym),
          (ym.prototype.isCubicBezierCurve3 = !0);
        class _m extends $d {
          constructor(t = new sr(), e = new sr()) {
            super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
          }
          getPoint(t, e = new sr()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e) {
            const n = e || new sr();
            return n.copy(this.v2).sub(this.v1).normalize(), n;
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        (exports.LineCurve = _m), (_m.prototype.isLineCurve = !0);
        class Mm extends $d {
          constructor(t = new xr(), e = new xr()) {
            super(),
              (this.type = "LineCurve3"),
              (this.isLineCurve3 = !0),
              (this.v1 = t),
              (this.v2 = e);
          }
          getPoint(t, e = new xr()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        exports.LineCurve3 = Mm;
        class wm extends $d {
          constructor(t = new sr(), e = new sr(), n = new sr()) {
            super(),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new sr()) {
            const n = e,
              r = this.v0,
              i = this.v1,
              s = this.v2;
            return n.set(pm(t, r.x, i.x, s.x), pm(t, r.y, i.y, s.y)), n;
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        (exports.QuadraticBezierCurve = wm),
          (wm.prototype.isQuadraticBezierCurve = !0);
        class bm extends $d {
          constructor(t = new xr(), e = new xr(), n = new xr()) {
            super(),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new xr()) {
            const n = e,
              r = this.v0,
              i = this.v1,
              s = this.v2;
            return (
              n.set(
                pm(t, r.x, i.x, s.x),
                pm(t, r.y, i.y, s.y),
                pm(t, r.z, i.z, s.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        (exports.QuadraticBezierCurve3 = bm),
          (bm.prototype.isQuadraticBezierCurve3 = !0);
        class Sm extends $d {
          constructor(t = []) {
            super(), (this.type = "SplineCurve"), (this.points = t);
          }
          getPoint(t, e = new sr()) {
            const n = e,
              r = this.points,
              i = (r.length - 1) * t,
              s = Math.floor(i),
              o = i - s,
              a = r[0 === s ? s : s - 1],
              l = r[s],
              c = r[s > r.length - 2 ? r.length - 1 : s + 1],
              h = r[s > r.length - 3 ? r.length - 1 : s + 2];
            return (
              n.set(lm(o, a.x, l.x, c.x, h.x), lm(o, a.y, l.y, c.y, h.y)), n
            );
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new sr().fromArray(n));
            }
            return this;
          }
        }
        (exports.SplineCurve = Sm), (Sm.prototype.isSplineCurve = !0);
        var Tm = Object.freeze({
          __proto__: null,
          ArcCurve: em,
          CatmullRomCurve3: am,
          CubicBezierCurve: vm,
          CubicBezierCurve3: ym,
          EllipseCurve: tm,
          LineCurve: _m,
          LineCurve3: Mm,
          QuadraticBezierCurve: wm,
          QuadraticBezierCurve3: bm,
          SplineCurve: Sm,
        });
        class Em extends $d {
          constructor() {
            super(),
              (this.type = "CurvePath"),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(t) {
            this.curves.push(t);
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new _m(e, t));
          }
          getPoint(t) {
            const e = t * this.getLength(),
              n = this.getCurveLengths();
            let r = 0;
            for (; r < n.length;) {
              if (n[r] >= e) {
                const t = n[r] - e,
                  i = this.curves[r],
                  s = i.getLength(),
                  o = 0 === s ? 0 : 1 - t / s;
                return i.getPointAt(o);
              }
              r++;
            }
            return null;
          }
          getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, r = this.curves.length; n < r; n++)
              (e += this.curves[n].getLength()), t.push(e);
            return (this.cacheLengths = t), t;
          }
          getSpacedPoints(t = 40) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e;
          }
          getPoints(t = 12) {
            const e = [];
            let n;
            for (let r = 0, i = this.curves; r < i.length; r++) {
              const s = i[r],
                o =
                  s && s.isEllipseCurve
                    ? 2 * t
                    : s && (s.isLineCurve || s.isLineCurve3)
                      ? 1
                      : s && s.isSplineCurve
                        ? t * s.points.length
                        : t,
                a = s.getPoints(o);
              for (let t = 0; t < a.length; t++) {
                const r = a[t];
                (n && n.equals(r)) || (e.push(r), (n = r));
              }
            }
            return (
              this.autoClose &&
              e.length > 1 &&
              !e[e.length - 1].equals(e[0]) &&
              e.push(e[0]),
              e
            );
          }
          copy(t) {
            super.copy(t), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(n.clone());
            }
            return (this.autoClose = t.autoClose), this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.autoClose = this.autoClose), (t.curves = []);
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e];
              t.curves.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t),
              (this.autoClose = t.autoClose),
              (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(new Tm[n.type]().fromJSON(n));
            }
            return this;
          }
        }
        exports.CurvePath = Em;
        class Am extends Em {
          constructor(t) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new sr()),
              t && this.setFromPoints(t);
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
              this.lineTo(t[e].x, t[e].y);
            return this;
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this;
          }
          lineTo(t, e) {
            const n = new _m(this.currentPoint.clone(), new sr(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this;
          }
          quadraticCurveTo(t, e, n, r) {
            const i = new wm(
              this.currentPoint.clone(),
              new sr(t, e),
              new sr(n, r)
            );
            return this.curves.push(i), this.currentPoint.set(n, r), this;
          }
          bezierCurveTo(t, e, n, r, i, s) {
            const o = new vm(
              this.currentPoint.clone(),
              new sr(t, e),
              new sr(n, r),
              new sr(i, s)
            );
            return this.curves.push(o), this.currentPoint.set(i, s), this;
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new Sm(e);
            return (
              this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            );
          }
          arc(t, e, n, r, i, s) {
            const o = this.currentPoint.x,
              a = this.currentPoint.y;
            return this.absarc(t + o, e + a, n, r, i, s), this;
          }
          absarc(t, e, n, r, i, s) {
            return this.absellipse(t, e, n, n, r, i, s), this;
          }
          ellipse(t, e, n, r, i, s, o, a) {
            const l = this.currentPoint.x,
              c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, r, i, s, o, a), this;
          }
          absellipse(t, e, n, r, i, s, o, a) {
            const l = new tm(t, e, n, r, i, s, o, a);
            if (this.curves.length > 0) {
              const t = l.getPoint(0);
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c), this;
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.currentPoint = this.currentPoint.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.currentPoint.fromArray(t.currentPoint),
              this
            );
          }
        }
        exports.Path = Am;
        class Lm extends Am {
          constructor(t) {
            super(t),
              (this.uuid = zn()),
              (this.type = "Shape"),
              (this.holes = []);
          }
          getPointsHoles(t) {
            const e = [];
            for (let n = 0, r = this.holes.length; n < r; n++)
              e[n] = this.holes[n].getPoints(t);
            return e;
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          }
          copy(t) {
            super.copy(t), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.uuid = this.uuid), (t.holes = []);
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e];
              t.holes.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(new Am().fromJSON(n));
            }
            return this;
          }
        }
        exports.Shape = Lm;
        class Rm extends yi {
          constructor(t, e = 1) {
            super(),
              (this.type = "Light"),
              (this.color = new Vi(t)),
              (this.intensity = e);
          }
          dispose() { }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
              (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
              (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        (exports.Light = Rm), (Rm.prototype.isLight = !0);
        class Cm extends Rm {
          constructor(t, e, n) {
            super(t, n),
              (this.type = "HemisphereLight"),
              this.position.copy(yi.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new Vi(e));
          }
          copy(t) {
            return (
              Rm.prototype.copy.call(this, t),
              this.groundColor.copy(t.groundColor),
              this
            );
          }
        }
        (exports.HemisphereLight = Cm), (Cm.prototype.isHemisphereLight = !0);
        const Pm = new Yr(),
          Dm = new xr(),
          Im = new xr();
        class Bm {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.mapSize = new sr(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new Yr()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new Qs()),
              (this._frameExtents = new sr(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new pr(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            Dm.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(Dm),
              Im.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(Im),
              e.updateMatrixWorld(),
              Pm.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Pm),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(e.projectionMatrix),
              n.multiply(e.matrixWorldInverse);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class Fm extends Bm {
          constructor() {
            super(new Vs(50, 1, 0.5, 500)), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * Gn * t.angle * this.focus,
              r = this.mapSize.width / this.mapSize.height,
              i = t.distance || e.far;
            (n === e.fov && r === e.aspect && i === e.far) ||
              ((e.fov = n),
                (e.aspect = r),
                (e.far = i),
                e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        Fm.prototype.isSpotLightShadow = !0;
        class Nm extends Rm {
          constructor(t, e, n = 0, r = Math.PI / 3, i = 0, s = 1) {
            super(t, e),
              (this.type = "SpotLight"),
              this.position.copy(yi.DefaultUp),
              this.updateMatrix(),
              (this.target = new yi()),
              (this.distance = n),
              (this.angle = r),
              (this.penumbra = i),
              (this.decay = s),
              (this.shadow = new Fm());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        (exports.SpotLight = Nm), (Nm.prototype.isSpotLight = !0);
        const Gm = new Yr(),
          zm = new xr(),
          Om = new xr();
        class Hm extends Bm {
          constructor() {
            super(new Vs(90, 1, 0.5, 500)),
              (this._frameExtents = new sr(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new pr(2, 1, 1, 1),
                new pr(0, 1, 1, 1),
                new pr(3, 1, 1, 1),
                new pr(1, 1, 1, 1),
                new pr(3, 0, 1, 1),
                new pr(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new xr(1, 0, 0),
                new xr(-1, 0, 0),
                new xr(0, 0, 1),
                new xr(0, 0, -1),
                new xr(0, 1, 0),
                new xr(0, -1, 0),
              ]),
              (this._cubeUps = [
                new xr(0, 1, 0),
                new xr(0, 1, 0),
                new xr(0, 1, 0),
                new xr(0, 1, 0),
                new xr(0, 0, 1),
                new xr(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              r = this.matrix,
              i = t.distance || n.far;
            i !== n.far && ((n.far = i), n.updateProjectionMatrix()),
              zm.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(zm),
              Om.copy(n.position),
              Om.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(Om),
              n.updateMatrixWorld(),
              r.makeTranslation(-zm.x, -zm.y, -zm.z),
              Gm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Gm);
          }
        }
        Hm.prototype.isPointLightShadow = !0;
        class Um extends Rm {
          constructor(t, e, n = 0, r = 1) {
            super(t, e),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = r),
              (this.shadow = new Hm());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        (exports.PointLight = Um), (Um.prototype.isPointLight = !0);
        class km extends ks {
          constructor(t = -1, e = 1, n = 1, r = -1, i = 0.1, s = 2e3) {
            super(),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = r),
              (this.near = i),
              (this.far = s),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, r, i, s) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = r),
              (this.view.width = i),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              r = (this.top + this.bottom) / 2;
            let i = n - t,
              s = n + t,
              o = r + e,
              a = r - e;
            if (null !== this.view && this.view.enabled) {
              const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (s = (i += t * this.view.offsetX) + t * this.view.width),
                (a = (o -= e * this.view.offsetY) - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              i,
              s,
              o,
              a,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        (exports.OrthographicCamera = km),
          (km.prototype.isOrthographicCamera = !0);
        class Vm extends Bm {
          constructor() {
            super(new km(-5, 5, 5, -5, 0.5, 500));
          }
        }
        Vm.prototype.isDirectionalLightShadow = !0;
        class Wm extends Rm {
          constructor(t, e) {
            super(t, e),
              (this.type = "DirectionalLight"),
              this.position.copy(yi.DefaultUp),
              this.updateMatrix(),
              (this.target = new yi()),
              (this.shadow = new Vm());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        (exports.DirectionalLight = Wm), (Wm.prototype.isDirectionalLight = !0);
        class jm extends Rm {
          constructor(t, e) {
            super(t, e), (this.type = "AmbientLight");
          }
        }
        (exports.AmbientLight = jm), (jm.prototype.isAmbientLight = !0);
        class qm extends Rm {
          constructor(t, e, n = 10, r = 10) {
            super(t, e),
              (this.type = "RectAreaLight"),
              (this.width = n),
              (this.height = r);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.width = this.width), (e.object.height = this.height), e
            );
          }
        }
        (exports.RectAreaLight = qm), (qm.prototype.isRectAreaLight = !0);
        class Xm {
          constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++) this.coefficients.push(new xr());
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this;
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this;
          }
          getAt(t, e) {
            const n = t.x,
              r = t.y,
              i = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.282095),
              e.addScaledVector(s[1], 0.488603 * r),
              e.addScaledVector(s[2], 0.488603 * i),
              e.addScaledVector(s[3], 0.488603 * n),
              e.addScaledVector(s[4], n * r * 1.092548),
              e.addScaledVector(s[5], r * i * 1.092548),
              e.addScaledVector(s[6], 0.315392 * (3 * i * i - 1)),
              e.addScaledVector(s[7], n * i * 1.092548),
              e.addScaledVector(s[8], 0.546274 * (n * n - r * r)),
              e
            );
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              r = t.y,
              i = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.886227),
              e.addScaledVector(s[1], 1.023328 * r),
              e.addScaledVector(s[2], 1.023328 * i),
              e.addScaledVector(s[3], 1.023328 * n),
              e.addScaledVector(s[4], 0.858086 * n * r),
              e.addScaledVector(s[5], 0.858086 * r * i),
              e.addScaledVector(s[6], 0.743125 * i * i - 0.247708),
              e.addScaledVector(s[7], 0.858086 * n * i),
              e.addScaledVector(s[8], 0.429043 * (n * n - r * r)),
              e
            );
          }
          add(t) {
            for (let e = 0; e < 9; e++)
              this.coefficients[e].add(t.coefficients[e]);
            return this;
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this;
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this;
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].lerp(t.coefficients[n], e);
            return this;
          }
          equals(t) {
            for (let e = 0; e < 9; e++)
              if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0;
          }
          copy(t) {
            return this.set(t.coefficients);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            const n = this.coefficients;
            for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients;
            for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
            return t;
          }
          static getBasisAt(t, e) {
            const n = t.x,
              r = t.y,
              i = t.z;
            (e[0] = 0.282095),
              (e[1] = 0.488603 * r),
              (e[2] = 0.488603 * i),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * r),
              (e[5] = 1.092548 * r * i),
              (e[6] = 0.315392 * (3 * i * i - 1)),
              (e[7] = 1.092548 * n * i),
              (e[8] = 0.546274 * (n * n - r * r));
          }
        }
        (exports.SphericalHarmonics3 = Xm),
          (Xm.prototype.isSphericalHarmonics3 = !0);
        class Ym extends Rm {
          constructor(t = new Xm(), e = 1) {
            super(void 0, e), (this.sh = t);
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this;
          }
          fromJSON(t) {
            return (
              (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.sh = this.sh.toArray()), e;
          }
        }
        (exports.LightProbe = Ym), (Ym.prototype.isLightProbe = !0);
        class Zm extends Wd {
          constructor(t) {
            super(t), (this.textures = {});
          }
          load(t, e, n, r) {
            const i = this,
              s = new qd(i.manager);
            s.setPath(i.path),
              s.setRequestHeader(i.requestHeader),
              s.setWithCredentials(i.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(i.parse(JSON.parse(n)));
                  } catch (s) {
                    r ? r(s) : console.error(s), i.manager.itemError(t);
                  }
                },
                n,
                r
              );
          }
          parse(t) {
            const e = this.textures;
            function n(t) {
              return (
                void 0 === e[t] &&
                console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
              );
            }
            const r = new Sd[t.type]();
            if (
              (void 0 !== t.uuid && (r.uuid = t.uuid),
                void 0 !== t.name && (r.name = t.name),
                void 0 !== t.color &&
                void 0 !== r.color &&
                r.color.setHex(t.color),
                void 0 !== t.roughness && (r.roughness = t.roughness),
                void 0 !== t.metalness && (r.metalness = t.metalness),
                void 0 !== t.sheen && (r.sheen = new Vi().setHex(t.sheen)),
                void 0 !== t.emissive &&
                void 0 !== r.emissive &&
                r.emissive.setHex(t.emissive),
                void 0 !== t.specular &&
                void 0 !== r.specular &&
                r.specular.setHex(t.specular),
                void 0 !== t.shininess && (r.shininess = t.shininess),
                void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat),
                void 0 !== t.clearcoatRoughness &&
                (r.clearcoatRoughness = t.clearcoatRoughness),
                void 0 !== t.transmission && (r.transmission = t.transmission),
                void 0 !== t.thickness && (r.thickness = t.thickness),
                void 0 !== t.attenuationDistance &&
                (r.attenuationDistance = t.attenuationDistance),
                void 0 !== t.attenuationColor &&
                void 0 !== r.attenuationColor &&
                r.attenuationColor.setHex(t.attenuationColor),
                void 0 !== t.fog && (r.fog = t.fog),
                void 0 !== t.flatShading && (r.flatShading = t.flatShading),
                void 0 !== t.blending && (r.blending = t.blending),
                void 0 !== t.combine && (r.combine = t.combine),
                void 0 !== t.side && (r.side = t.side),
                void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide),
                void 0 !== t.opacity && (r.opacity = t.opacity),
                void 0 !== t.transparent && (r.transparent = t.transparent),
                void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest),
                void 0 !== t.depthTest && (r.depthTest = t.depthTest),
                void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite),
                void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite),
                void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite),
                void 0 !== t.stencilWriteMask &&
                (r.stencilWriteMask = t.stencilWriteMask),
                void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc),
                void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef),
                void 0 !== t.stencilFuncMask &&
                (r.stencilFuncMask = t.stencilFuncMask),
                void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail),
                void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail),
                void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass),
                void 0 !== t.wireframe && (r.wireframe = t.wireframe),
                void 0 !== t.wireframeLinewidth &&
                (r.wireframeLinewidth = t.wireframeLinewidth),
                void 0 !== t.wireframeLinecap &&
                (r.wireframeLinecap = t.wireframeLinecap),
                void 0 !== t.wireframeLinejoin &&
                (r.wireframeLinejoin = t.wireframeLinejoin),
                void 0 !== t.rotation && (r.rotation = t.rotation),
                1 !== t.linewidth && (r.linewidth = t.linewidth),
                void 0 !== t.dashSize && (r.dashSize = t.dashSize),
                void 0 !== t.gapSize && (r.gapSize = t.gapSize),
                void 0 !== t.scale && (r.scale = t.scale),
                void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset),
                void 0 !== t.polygonOffsetFactor &&
                (r.polygonOffsetFactor = t.polygonOffsetFactor),
                void 0 !== t.polygonOffsetUnits &&
                (r.polygonOffsetUnits = t.polygonOffsetUnits),
                void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets),
                void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals),
                void 0 !== t.dithering && (r.dithering = t.dithering),
                void 0 !== t.alphaToCoverage &&
                (r.alphaToCoverage = t.alphaToCoverage),
                void 0 !== t.premultipliedAlpha &&
                (r.premultipliedAlpha = t.premultipliedAlpha),
                void 0 !== t.vertexTangents &&
                (r.vertexTangents = t.vertexTangents),
                void 0 !== t.visible && (r.visible = t.visible),
                void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped),
                void 0 !== t.userData && (r.userData = t.userData),
                void 0 !== t.vertexColors &&
                ("number" == typeof t.vertexColors
                  ? (r.vertexColors = t.vertexColors > 0)
                  : (r.vertexColors = t.vertexColors)),
                void 0 !== t.uniforms)
            )
              for (const i in t.uniforms) {
                const e = t.uniforms[i];
                switch (((r.uniforms[i] = {}), e.type)) {
                  case "t":
                    r.uniforms[i].value = n(e.value);
                    break;
                  case "c":
                    r.uniforms[i].value = new Vi().setHex(e.value);
                    break;
                  case "v2":
                    r.uniforms[i].value = new sr().fromArray(e.value);
                    break;
                  case "v3":
                    r.uniforms[i].value = new xr().fromArray(e.value);
                    break;
                  case "v4":
                    r.uniforms[i].value = new pr().fromArray(e.value);
                    break;
                  case "m3":
                    r.uniforms[i].value = new or().fromArray(e.value);
                    break;
                  case "m4":
                    r.uniforms[i].value = new Yr().fromArray(e.value);
                    break;
                  default:
                    r.uniforms[i].value = e.value;
                }
              }
            if (
              (void 0 !== t.defines && (r.defines = t.defines),
                void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader),
                void 0 !== t.fragmentShader &&
                (r.fragmentShader = t.fragmentShader),
                void 0 !== t.extensions)
            )
              for (const i in t.extensions) r.extensions[i] = t.extensions[i];
            if (
              (void 0 !== t.shading && (r.flatShading = 1 === t.shading),
                void 0 !== t.size && (r.size = t.size),
                void 0 !== t.sizeAttenuation &&
                (r.sizeAttenuation = t.sizeAttenuation),
                void 0 !== t.map && (r.map = n(t.map)),
                void 0 !== t.matcap && (r.matcap = n(t.matcap)),
                void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)),
                void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)),
                void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale),
                void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)),
                void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType),
                void 0 !== t.normalScale)
            ) {
              let e = t.normalScale;
              !1 === Array.isArray(e) && (e = [e, e]),
                (r.normalScale = new sr().fromArray(e));
            }
            return (
              void 0 !== t.displacementMap &&
              (r.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale &&
              (r.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias &&
              (r.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity &&
              (r.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)),
              void 0 !== t.envMap && (r.envMap = n(t.envMap)),
              void 0 !== t.envMapIntensity &&
              (r.envMapIntensity = t.envMapIntensity),
              void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity),
              void 0 !== t.refractionRatio &&
              (r.refractionRatio = t.refractionRatio),
              void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity &&
              (r.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity &&
              (r.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)),
              void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)),
              void 0 !== t.clearcoatRoughnessMap &&
              (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
              void 0 !== t.clearcoatNormalMap &&
              (r.clearcoatNormalMap = n(t.clearcoatNormalMap)),
              void 0 !== t.clearcoatNormalScale &&
              (r.clearcoatNormalScale = new sr().fromArray(
                t.clearcoatNormalScale
              )),
              void 0 !== t.transmissionMap &&
              (r.transmissionMap = n(t.transmissionMap)),
              void 0 !== t.thicknessMap && (r.thicknessMap = n(t.thicknessMap)),
              r
            );
          }
          setTextures(t) {
            return (this.textures = t), this;
          }
        }
        exports.MaterialLoader = Zm;
        class Jm {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
              return new TextDecoder().decode(t);
            let e = "";
            for (let r = 0, i = t.length; r < i; r++)
              e += String.fromCharCode(t[r]);
            try {
              return decodeURIComponent(escape(e));
            } catch (n) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1);
          }
        }
        exports.LoaderUtils = Jm;
        class Qm extends ms {
          constructor() {
            super(),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(t) {
            return super.copy(t), (this.instanceCount = t.instanceCount), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = super.toJSON(this);
            return (
              (t.instanceCount = this.instanceCount),
              (t.isInstancedBufferGeometry = !0),
              t
            );
          }
        }
        (exports.InstancedBufferGeometry = Qm),
          (Qm.prototype.isInstancedBufferGeometry = !0);
        class Km extends Xi {
          constructor(t, e, n, r) {
            "number" == typeof n &&
              ((r = n),
                (n = !1),
                console.error(
                  "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
                )),
              super(t, e, n),
              (this.meshPerAttribute = r || 1);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute),
              (t.isInstancedBufferAttribute = !0),
              t
            );
          }
        }
        (exports.InstancedBufferAttribute = Km),
          (Km.prototype.isInstancedBufferAttribute = !0);
        class $m extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = new qd(i.manager);
            s.setPath(i.path),
              s.setRequestHeader(i.requestHeader),
              s.setWithCredentials(i.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(i.parse(JSON.parse(n)));
                  } catch (s) {
                    r ? r(s) : console.error(s), i.manager.itemError(t);
                  }
                },
                n,
                r
              );
          }
          parse(t) {
            const e = {},
              n = {};
            function r(t, r) {
              if (void 0 !== e[r]) return e[r];
              const i = t.interleavedBuffers[r],
                s = (function (t, e) {
                  if (void 0 !== n[e]) return n[e];
                  const r = t.arrayBuffers[e],
                    i = new Uint32Array(r).buffer;
                  return (n[e] = i), i;
                })(t, i.buffer),
                o = os(i.type, s),
                a = new $h(o, i.stride);
              return (a.uuid = i.uuid), (e[r] = a), a;
            }
            const i = t.isInstancedBufferGeometry ? new Qm() : new ms(),
              s = t.data.index;
            if (void 0 !== s) {
              const t = os(s.type, s.array);
              i.setIndex(new Xi(t, 1));
            }
            const o = t.data.attributes;
            for (const h in o) {
              const e = o[h];
              let n;
              if (e.isInterleavedBufferAttribute) {
                const i = r(t.data, e.data);
                n = new eu(i, e.itemSize, e.offset, e.normalized);
              } else {
                const t = os(e.type, e.array);
                n = new (e.isInstancedBufferAttribute ? Km : Xi)(
                  t,
                  e.itemSize,
                  e.normalized
                );
              }
              void 0 !== e.name && (n.name = e.name),
                void 0 !== e.usage && n.setUsage(e.usage),
                void 0 !== e.updateRange &&
                ((n.updateRange.offset = e.updateRange.offset),
                  (n.updateRange.count = e.updateRange.count)),
                i.setAttribute(h, n);
            }
            const a = t.data.morphAttributes;
            if (a)
              for (const h in a) {
                const e = a[h],
                  n = [];
                for (let i = 0, s = e.length; i < s; i++) {
                  const s = e[i];
                  let o;
                  if (s.isInterleavedBufferAttribute) {
                    const e = r(t.data, s.data);
                    o = new eu(e, s.itemSize, s.offset, s.normalized);
                  } else {
                    const t = os(s.type, s.array);
                    o = new Xi(t, s.itemSize, s.normalized);
                  }
                  void 0 !== s.name && (o.name = s.name), n.push(o);
                }
                i.morphAttributes[h] = n;
              }
            t.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== l)
              for (let h = 0, u = l.length; h !== u; ++h) {
                const t = l[h];
                i.addGroup(t.start, t.count, t.materialIndex);
              }
            const c = t.data.boundingSphere;
            if (void 0 !== c) {
              const t = new xr();
              void 0 !== c.center && t.fromArray(c.center),
                (i.boundingSphere = new Or(t, c.radius));
            }
            return (
              t.name && (i.name = t.name),
              t.userData && (i.userData = t.userData),
              i
            );
          }
        }
        exports.BufferGeometryLoader = $m;
        class tf extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = "" === this.path ? Jm.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || s;
            const o = new qd(this.manager);
            o.setPath(this.path),
              o.setRequestHeader(this.requestHeader),
              o.setWithCredentials(this.withCredentials),
              o.load(
                t,
                function (n) {
                  let s = null;
                  try {
                    s = JSON.parse(n);
                  } catch (a) {
                    return (
                      void 0 !== r && r(a),
                      void console.error(
                        "THREE:ObjectLoader: Can't parse " + t + ".",
                        a.message
                      )
                    );
                  }
                  const o = s.metadata;
                  void 0 !== o &&
                    void 0 !== o.type &&
                    "geometry" !== o.type.toLowerCase()
                    ? i.parse(s, e)
                    : console.error("THREE.ObjectLoader: Can't load " + t);
                },
                n,
                r
              );
          }
          parse(t, e) {
            const n = this.parseAnimations(t.animations),
              r = this.parseShapes(t.shapes),
              i = this.parseGeometries(t.geometries, r),
              s = this.parseImages(t.images, function () {
                void 0 !== e && e(l);
              }),
              o = this.parseTextures(t.textures, s),
              a = this.parseMaterials(t.materials, o),
              l = this.parseObject(t.object, i, a, n),
              c = this.parseSkeletons(t.skeletons, l);
            if ((this.bindSkeletons(l, c), void 0 !== e)) {
              let t = !1;
              for (const e in s)
                if (s[e] instanceof HTMLImageElement) {
                  t = !0;
                  break;
                }
              !1 === t && e(l);
            }
            return l;
          }
          parseShapes(t) {
            const e = {};
            if (void 0 !== t)
              for (let n = 0, r = t.length; n < r; n++) {
                const r = new Lm().fromJSON(t[n]);
                e[r.uuid] = r;
              }
            return e;
          }
          parseSkeletons(t, e) {
            const n = {},
              r = {};
            if (
              (e.traverse(function (t) {
                t.isBone && (r[t.uuid] = t);
              }),
                void 0 !== t)
            )
              for (let i = 0, s = t.length; i < s; i++) {
                const e = new Pu().fromJSON(t[i], r);
                n[e.uuid] = e;
              }
            return n;
          }
          parseGeometries(t, e) {
            const n = {};
            let r;
            if (void 0 !== t) {
              const i = new $m();
              for (let s = 0, o = t.length; s < o; s++) {
                let o;
                const a = t[s];
                switch (a.type) {
                  case "PlaneGeometry":
                  case "PlaneBufferGeometry":
                    o = new dd[a.type](
                      a.width,
                      a.height,
                      a.widthSegments,
                      a.heightSegments
                    );
                    break;
                  case "BoxGeometry":
                  case "BoxBufferGeometry":
                    o = new dd[a.type](
                      a.width,
                      a.height,
                      a.depth,
                      a.widthSegments,
                      a.heightSegments,
                      a.depthSegments
                    );
                    break;
                  case "CircleGeometry":
                  case "CircleBufferGeometry":
                    o = new dd[a.type](
                      a.radius,
                      a.segments,
                      a.thetaStart,
                      a.thetaLength
                    );
                    break;
                  case "CylinderGeometry":
                  case "CylinderBufferGeometry":
                    o = new dd[a.type](
                      a.radiusTop,
                      a.radiusBottom,
                      a.height,
                      a.radialSegments,
                      a.heightSegments,
                      a.openEnded,
                      a.thetaStart,
                      a.thetaLength
                    );
                    break;
                  case "ConeGeometry":
                  case "ConeBufferGeometry":
                    o = new dd[a.type](
                      a.radius,
                      a.height,
                      a.radialSegments,
                      a.heightSegments,
                      a.openEnded,
                      a.thetaStart,
                      a.thetaLength
                    );
                    break;
                  case "SphereGeometry":
                  case "SphereBufferGeometry":
                    o = new dd[a.type](
                      a.radius,
                      a.widthSegments,
                      a.heightSegments,
                      a.phiStart,
                      a.phiLength,
                      a.thetaStart,
                      a.thetaLength
                    );
                    break;
                  case "DodecahedronGeometry":
                  case "DodecahedronBufferGeometry":
                  case "IcosahedronGeometry":
                  case "IcosahedronBufferGeometry":
                  case "OctahedronGeometry":
                  case "OctahedronBufferGeometry":
                  case "TetrahedronGeometry":
                  case "TetrahedronBufferGeometry":
                    o = new dd[a.type](a.radius, a.detail);
                    break;
                  case "RingGeometry":
                  case "RingBufferGeometry":
                    o = new dd[a.type](
                      a.innerRadius,
                      a.outerRadius,
                      a.thetaSegments,
                      a.phiSegments,
                      a.thetaStart,
                      a.thetaLength
                    );
                    break;
                  case "TorusGeometry":
                  case "TorusBufferGeometry":
                    o = new dd[a.type](
                      a.radius,
                      a.tube,
                      a.radialSegments,
                      a.tubularSegments,
                      a.arc
                    );
                    break;
                  case "TorusKnotGeometry":
                  case "TorusKnotBufferGeometry":
                    o = new dd[a.type](
                      a.radius,
                      a.tube,
                      a.tubularSegments,
                      a.radialSegments,
                      a.p,
                      a.q
                    );
                    break;
                  case "TubeGeometry":
                  case "TubeBufferGeometry":
                    o = new dd[a.type](
                      new Tm[a.path.type]().fromJSON(a.path),
                      a.tubularSegments,
                      a.radius,
                      a.radialSegments,
                      a.closed
                    );
                    break;
                  case "LatheGeometry":
                  case "LatheBufferGeometry":
                    o = new dd[a.type](
                      a.points,
                      a.segments,
                      a.phiStart,
                      a.phiLength
                    );
                    break;
                  case "PolyhedronGeometry":
                  case "PolyhedronBufferGeometry":
                    o = new dd[a.type](
                      a.vertices,
                      a.indices,
                      a.radius,
                      a.details
                    );
                    break;
                  case "ShapeGeometry":
                  case "ShapeBufferGeometry":
                    r = [];
                    for (let n = 0, i = a.shapes.length; n < i; n++) {
                      const t = e[a.shapes[n]];
                      r.push(t);
                    }
                    o = new dd[a.type](r, a.curveSegments);
                    break;
                  case "ExtrudeGeometry":
                  case "ExtrudeBufferGeometry":
                    r = [];
                    for (let n = 0, i = a.shapes.length; n < i; n++) {
                      const t = e[a.shapes[n]];
                      r.push(t);
                    }
                    const t = a.options.extrudePath;
                    void 0 !== t &&
                      (a.options.extrudePath = new Tm[t.type]().fromJSON(t)),
                      (o = new dd[a.type](r, a.options));
                    break;
                  case "BufferGeometry":
                  case "InstancedBufferGeometry":
                    o = i.parse(a);
                    break;
                  case "Geometry":
                    console.error(
                      'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
                    );
                    break;
                  default:
                    console.warn(
                      'THREE.ObjectLoader: Unsupported geometry type "' +
                      a.type +
                      '"'
                    );
                    continue;
                }
                (o.uuid = a.uuid),
                  void 0 !== a.name && (o.name = a.name),
                  !0 === o.isBufferGeometry &&
                  void 0 !== a.userData &&
                  (o.userData = a.userData),
                  (n[a.uuid] = o);
              }
            }
            return n;
          }
          parseMaterials(t, e) {
            const n = {},
              r = {};
            if (void 0 !== t) {
              const i = new Zm();
              i.setTextures(e);
              for (let e = 0, s = t.length; e < s; e++) {
                const s = t[e];
                if ("MultiMaterial" === s.type) {
                  const t = [];
                  for (let e = 0; e < s.materials.length; e++) {
                    const r = s.materials[e];
                    void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)),
                      t.push(n[r.uuid]);
                  }
                  r[s.uuid] = t;
                } else
                  void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
                    (r[s.uuid] = n[s.uuid]);
              }
            }
            return r;
          }
          parseAnimations(t) {
            const e = {};
            if (void 0 !== t)
              for (let n = 0; n < t.length; n++) {
                const r = t[n],
                  i = zd.parse(r);
                e[i.uuid] = i;
              }
            return e;
          }
          parseImages(t, e) {
            const n = this,
              r = {};
            let i;
            function s(t) {
              if ("string" == typeof t) {
                const e = t;
                return (function (t) {
                  return (
                    n.manager.itemStart(t),
                    i.load(
                      t,
                      function () {
                        n.manager.itemEnd(t);
                      },
                      void 0,
                      function () {
                        n.manager.itemError(t), n.manager.itemEnd(t);
                      }
                    )
                  );
                })(
                  /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e
                );
              }
              return t.data
                ? { data: os(t.type, t.data), width: t.width, height: t.height }
                : null;
            }
            if (void 0 !== t && t.length > 0) {
              const n = new kd(e);
              (i = new Zd(n)).setCrossOrigin(this.crossOrigin);
              for (let e = 0, i = t.length; e < i; e++) {
                const n = t[e],
                  i = n.url;
                if (Array.isArray(i)) {
                  r[n.uuid] = [];
                  for (let t = 0, e = i.length; t < e; t++) {
                    const e = s(i[t]);
                    null !== e &&
                      (e instanceof HTMLImageElement
                        ? r[n.uuid].push(e)
                        : r[n.uuid].push(new Lu(e.data, e.width, e.height)));
                  }
                } else {
                  const t = s(n.url);
                  null !== t && (r[n.uuid] = t);
                }
              }
            }
            return r;
          }
          parseTextures(t, e) {
            function n(t, e) {
              return "number" == typeof t
                ? t
                : (console.warn(
                  "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                  t
                ),
                  e[t]);
            }
            const r = {};
            if (void 0 !== t)
              for (let i = 0, s = t.length; i < s; i++) {
                const s = t[i];
                let o;
                void 0 === s.image &&
                  console.warn(
                    'THREE.ObjectLoader: No "image" specified for',
                    s.uuid
                  ),
                  void 0 === e[s.image] &&
                  console.warn(
                    "THREE.ObjectLoader: Undefined image",
                    s.image
                  );
                const a = e[s.image];
                Array.isArray(a)
                  ? ((o = new Xs(a)), 6 === a.length && (o.needsUpdate = !0))
                  : ((o =
                    a && a.data
                      ? new Lu(a.data, a.width, a.height)
                      : new hr(a)),
                    a && (o.needsUpdate = !0)),
                  (o.uuid = s.uuid),
                  void 0 !== s.name && (o.name = s.name),
                  void 0 !== s.mapping && (o.mapping = n(s.mapping, ef)),
                  void 0 !== s.offset && o.offset.fromArray(s.offset),
                  void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
                  void 0 !== s.center && o.center.fromArray(s.center),
                  void 0 !== s.rotation && (o.rotation = s.rotation),
                  void 0 !== s.wrap &&
                  ((o.wrapS = n(s.wrap[0], nf)),
                    (o.wrapT = n(s.wrap[1], nf))),
                  void 0 !== s.format && (o.format = s.format),
                  void 0 !== s.type && (o.type = s.type),
                  void 0 !== s.encoding && (o.encoding = s.encoding),
                  void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, rf)),
                  void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, rf)),
                  void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
                  void 0 !== s.flipY && (o.flipY = s.flipY),
                  void 0 !== s.premultiplyAlpha &&
                  (o.premultiplyAlpha = s.premultiplyAlpha),
                  void 0 !== s.unpackAlignment &&
                  (o.unpackAlignment = s.unpackAlignment),
                  (r[s.uuid] = o);
              }
            return r;
          }
          parseObject(t, e, n, r) {
            let i, s, o;
            function a(t) {
              return (
                void 0 === e[t] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", t),
                e[t]
              );
            }
            function l(t) {
              if (void 0 !== t) {
                if (Array.isArray(t)) {
                  const e = [];
                  for (let r = 0, i = t.length; r < i; r++) {
                    const i = t[r];
                    void 0 === n[i] &&
                      console.warn("THREE.ObjectLoader: Undefined material", i),
                      e.push(n[i]);
                  }
                  return e;
                }
                return (
                  void 0 === n[t] &&
                  console.warn("THREE.ObjectLoader: Undefined material", t),
                  n[t]
                );
              }
            }
            switch (t.type) {
              case "Scene":
                (i = new Kh()),
                  void 0 !== t.background &&
                  Number.isInteger(t.background) &&
                  (i.background = new Vi(t.background)),
                  void 0 !== t.fog &&
                  ("Fog" === t.fog.type
                    ? (i.fog = new Qh(t.fog.color, t.fog.near, t.fog.far))
                    : "FogExp2" === t.fog.type &&
                    (i.fog = new Jh(t.fog.color, t.fog.density)));
                break;
              case "PerspectiveCamera":
                (i = new Vs(t.fov, t.aspect, t.near, t.far)),
                  void 0 !== t.focus && (i.focus = t.focus),
                  void 0 !== t.zoom && (i.zoom = t.zoom),
                  void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
                  void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
                  void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
              case "OrthographicCamera":
                (i = new km(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                  void 0 !== t.zoom && (i.zoom = t.zoom),
                  void 0 !== t.view && (i.view = Object.assign({}, t.view));
                break;
              case "AmbientLight":
                i = new jm(t.color, t.intensity);
                break;
              case "DirectionalLight":
                i = new Wm(t.color, t.intensity);
                break;
              case "PointLight":
                i = new Um(t.color, t.intensity, t.distance, t.decay);
                break;
              case "RectAreaLight":
                i = new qm(t.color, t.intensity, t.width, t.height);
                break;
              case "SpotLight":
                i = new Nm(
                  t.color,
                  t.intensity,
                  t.distance,
                  t.angle,
                  t.penumbra,
                  t.decay
                );
                break;
              case "HemisphereLight":
                i = new Cm(t.color, t.groundColor, t.intensity);
                break;
              case "LightProbe":
                i = new Ym().fromJSON(t);
                break;
              case "SkinnedMesh":
                (s = a(t.geometry)),
                  (o = l(t.material)),
                  (i = new Eu(s, o)),
                  void 0 !== t.bindMode && (i.bindMode = t.bindMode),
                  void 0 !== t.bindMatrix &&
                  i.bindMatrix.fromArray(t.bindMatrix),
                  void 0 !== t.skeleton && (i.skeleton = t.skeleton);
                break;
              case "Mesh":
                (s = a(t.geometry)), (o = l(t.material)), (i = new Ds(s, o));
                break;
              case "InstancedMesh":
                (s = a(t.geometry)), (o = l(t.material));
                const e = t.count,
                  n = t.instanceMatrix,
                  r = t.instanceColor;
                ((i = new Nu(s, o, e)).instanceMatrix = new Xi(
                  new Float32Array(n.array),
                  16
                )),
                  void 0 !== r &&
                  (i.instanceColor = new Xi(
                    new Float32Array(r.array),
                    r.itemSize
                  ));
                break;
              case "LOD":
                i = new _u();
                break;
              case "Line":
                i = new Vu(a(t.geometry), l(t.material));
                break;
              case "LineLoop":
                i = new Xu(a(t.geometry), l(t.material));
                break;
              case "LineSegments":
                i = new qu(a(t.geometry), l(t.material));
                break;
              case "PointCloud":
              case "Points":
                i = new $u(a(t.geometry), l(t.material));
                break;
              case "Sprite":
                i = new gu(l(t.material));
                break;
              case "Group":
                i = new kh();
                break;
              case "Bone":
                i = new Au();
                break;
              default:
                i = new yi();
            }
            if (
              ((i.uuid = t.uuid),
                void 0 !== t.name && (i.name = t.name),
                void 0 !== t.matrix
                  ? (i.matrix.fromArray(t.matrix),
                    void 0 !== t.matrixAutoUpdate &&
                    (i.matrixAutoUpdate = t.matrixAutoUpdate),
                    i.matrixAutoUpdate &&
                    i.matrix.decompose(i.position, i.quaternion, i.scale))
                  : (void 0 !== t.position && i.position.fromArray(t.position),
                    void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
                    void 0 !== t.quaternion &&
                    i.quaternion.fromArray(t.quaternion),
                    void 0 !== t.scale && i.scale.fromArray(t.scale)),
                void 0 !== t.castShadow && (i.castShadow = t.castShadow),
                void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
                t.shadow &&
                (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
                  void 0 !== t.shadow.normalBias &&
                  (i.shadow.normalBias = t.shadow.normalBias),
                  void 0 !== t.shadow.radius &&
                  (i.shadow.radius = t.shadow.radius),
                  void 0 !== t.shadow.mapSize &&
                  i.shadow.mapSize.fromArray(t.shadow.mapSize),
                  void 0 !== t.shadow.camera &&
                  (i.shadow.camera = this.parseObject(t.shadow.camera))),
                void 0 !== t.visible && (i.visible = t.visible),
                void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
                void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
                void 0 !== t.userData && (i.userData = t.userData),
                void 0 !== t.layers && (i.layers.mask = t.layers),
                void 0 !== t.children)
            ) {
              const s = t.children;
              for (let t = 0; t < s.length; t++)
                i.add(this.parseObject(s[t], e, n, r));
            }
            if (void 0 !== t.animations) {
              const e = t.animations;
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                i.animations.push(r[n]);
              }
            }
            if ("LOD" === t.type) {
              void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
              const e = t.levels;
              for (let t = 0; t < e.length; t++) {
                const n = e[t],
                  r = i.getObjectByProperty("uuid", n.object);
                void 0 !== r && i.addLevel(r, n.distance);
              }
            }
            return i;
          }
          bindSkeletons(t, e) {
            0 !== Object.keys(e).length &&
              t.traverse(function (t) {
                if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                  const n = e[t.skeleton];
                  void 0 === n
                    ? console.warn(
                      "THREE.ObjectLoader: No skeleton found with UUID:",
                      t.skeleton
                    )
                    : t.bind(n, t.bindMatrix);
                }
              });
          }
          setTexturePath(t) {
            return (
              console.warn(
                "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
              ),
              this.setResourcePath(t)
            );
          }
        }
        exports.ObjectLoader = tf;
        const ef = {
          UVMapping: et,
          CubeReflectionMapping: nt,
          CubeRefractionMapping: rt,
          EquirectangularReflectionMapping: it,
          EquirectangularRefractionMapping: st,
          CubeUVReflectionMapping: ot,
          CubeUVRefractionMapping: at,
        },
          nf = {
            RepeatWrapping: lt,
            ClampToEdgeWrapping: ct,
            MirroredRepeatWrapping: ht,
          },
          rf = {
            NearestFilter: ut,
            NearestMipmapNearestFilter: pt,
            NearestMipmapLinearFilter: mt,
            LinearFilter: gt,
            LinearMipmapNearestFilter: xt,
            LinearMipmapLinearFilter: yt,
          };
        class sf extends Wd {
          constructor(t) {
            super(t),
              "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
              "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (this.options = { premultiplyAlpha: "none" });
          }
          setOptions(t) {
            return (this.options = t), this;
          }
          load(t, e, n, r) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const i = this,
              s = Ud.get(t);
            if (void 0 !== s)
              return (
                i.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), i.manager.itemEnd(t);
                }, 0),
                s
              );
            const o = {};
            (o.credentials =
              "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              (o.headers = this.requestHeader),
              fetch(t, o)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(i.options, { colorSpaceConversion: "none" })
                  );
                })
                .then(function (n) {
                  Ud.add(t, n), e && e(n), i.manager.itemEnd(t);
                })
                .catch(function (e) {
                  r && r(e), i.manager.itemError(t), i.manager.itemEnd(t);
                }),
              i.manager.itemStart(t);
          }
        }
        (exports.ImageBitmapLoader = sf),
          (sf.prototype.isImageBitmapLoader = !0);
        class of {
          constructor() {
            (this.type = "ShapePath"),
              (this.color = new Vi()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(t, e) {
            return (
              (this.currentPath = new Am()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(t, e),
              this
            );
          }
          lineTo(t, e) {
            return this.currentPath.lineTo(t, e), this;
          }
          quadraticCurveTo(t, e, n, r) {
            return this.currentPath.quadraticCurveTo(t, e, n, r), this;
          }
          bezierCurveTo(t, e, n, r, i, s) {
            return this.currentPath.bezierCurveTo(t, e, n, r, i, s), this;
          }
          splineThru(t) {
            return this.currentPath.splineThru(t), this;
          }
          toShapes(t, e) {
            function n(t) {
              const e = [];
              for (let n = 0, r = t.length; n < r; n++) {
                const r = t[n],
                  i = new Lm();
                (i.curves = r.curves), e.push(i);
              }
              return e;
            }
            function r(t, e) {
              const n = e.length;
              let r = !1;
              for (let i = n - 1, s = 0; s < n; i = s++) {
                let n = e[i],
                  o = e[s],
                  a = o.x - n.x,
                  l = o.y - n.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (l < 0 && ((n = e[s]), (a = -a), (o = e[i]), (l = -l)),
                      t.y < n.y || t.y > o.y)
                  )
                    continue;
                  if (t.y === n.y) {
                    if (t.x === n.x) return !0;
                  } else {
                    const e = l * (t.x - n.x) - a * (t.y - n.y);
                    if (0 === e) return !0;
                    if (e < 0) continue;
                    r = !r;
                  }
                } else {
                  if (t.y !== n.y) continue;
                  if ((o.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= o.x))
                    return !0;
                }
              }
              return r;
            }
            const i = Xp.isClockWise,
              s = this.subPaths;
            if (0 === s.length) return [];
            if (!0 === e) return n(s);
            let o, a, l;
            const c = [];
            if (1 === s.length)
              return (
                (a = s[0]), ((l = new Lm()).curves = a.curves), c.push(l), c
              );
            let h = !i(s[0].getPoints());
            h = t ? !h : h;
            const u = [],
              p = [];
            let d,
              m,
              f = [],
              g = 0;
            (p[g] = void 0), (f[g] = []);
            for (let x = 0, v = s.length; x < v; x++)
              (o = i((d = (a = s[x]).getPoints()))),
                (o = t ? !o : o)
                  ? (!h && p[g] && g++,
                    (p[g] = { s: new Lm(), p: d }),
                    (p[g].s.curves = a.curves),
                    h && g++,
                    (f[g] = []))
                  : f[g].push({ h: a, p: d[0] });
            if (!p[0]) return n(s);
            if (p.length > 1) {
              let t = !1;
              const e = [];
              for (let n = 0, r = p.length; n < r; n++) u[n] = [];
              for (let n = 0, i = p.length; n < i; n++) {
                const i = f[n];
                for (let s = 0; s < i.length; s++) {
                  const o = i[s];
                  let a = !0;
                  for (let i = 0; i < p.length; i++)
                    r(o.p, p[i].p) &&
                      (n !== i && e.push({ froms: n, tos: i, hole: s }),
                        a ? ((a = !1), u[i].push(o)) : (t = !0));
                  a && u[n].push(o);
                }
              }
              e.length > 0 && (t || (f = u));
            }
            for (let x = 0, v = p.length; x < v; x++) {
              (l = p[x].s), c.push(l);
              for (let t = 0, e = (m = f[x]).length; t < e; t++)
                l.holes.push(m[t].h);
            }
            return c;
          }
        }
        exports.ShapePath = of;
        class af {
          constructor(t) {
            (this.type = "Font"), (this.data = t);
          }
          generateShapes(t, e = 100) {
            const n = [],
              r = lf(t, e, this.data);
            for (let i = 0, s = r.length; i < s; i++)
              Array.prototype.push.apply(n, r[i].toShapes());
            return n;
          }
        }
        function lf(t, e, n) {
          const r = Array.from(t),
            i = e / n.resolution,
            s =
              (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) *
              i,
            o = [];
          let a = 0,
            l = 0;
          for (let c = 0; c < r.length; c++) {
            const t = r[c];
            if ("\n" === t) (a = 0), (l -= s);
            else {
              const e = cf(t, i, a, l, n);
              (a += e.offsetX), o.push(e.path);
            }
          }
          return o;
        }
        function cf(t, e, n, r, i) {
          const s = i.glyphs[t] || i.glyphs["?"];
          if (!s)
            return void console.error(
              'THREE.Font: character "' +
              t +
              '" does not exists in font family ' +
              i.familyName +
              "."
            );
          const o = new of();
          let a, l, c, h, u, p, d, m;
          if (s.o) {
            const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
            for (let i = 0, s = t.length; i < s;) {
              switch (t[i++]) {
                case "m":
                  (a = t[i++] * e + n), (l = t[i++] * e + r), o.moveTo(a, l);
                  break;
                case "l":
                  (a = t[i++] * e + n), (l = t[i++] * e + r), o.lineTo(a, l);
                  break;
                case "q":
                  (c = t[i++] * e + n),
                    (h = t[i++] * e + r),
                    (u = t[i++] * e + n),
                    (p = t[i++] * e + r),
                    o.quadraticCurveTo(u, p, c, h);
                  break;
                case "b":
                  (c = t[i++] * e + n),
                    (h = t[i++] * e + r),
                    (u = t[i++] * e + n),
                    (p = t[i++] * e + r),
                    (d = t[i++] * e + n),
                    (m = t[i++] * e + r),
                    o.bezierCurveTo(u, p, d, m, c, h);
              }
            }
          }
          return { offsetX: s.ha * e, path: o };
        }
        (exports.Font = af), (af.prototype.isFont = !0);
        class hf extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = new qd(this.manager);
            s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(i.withCredentials),
              s.load(
                t,
                function (t) {
                  let n;
                  try {
                    n = JSON.parse(t);
                  } catch (s) {
                    console.warn(
                      "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                    ),
                      (n = JSON.parse(t.substring(65, t.length - 2)));
                  }
                  const r = i.parse(n);
                  e && e(r);
                },
                n,
                r
              );
          }
          parse(t) {
            return new af(t);
          }
        }
        let uf;
        exports.FontLoader = hf;
        const pf = {
          getContext: function () {
            return (
              void 0 === uf &&
              (uf = new (window.AudioContext || window.webkitAudioContext)()),
              uf
            );
          },
          setContext: function (t) {
            uf = t;
          },
        };
        exports.AudioContext = pf;
        class df extends Wd {
          constructor(t) {
            super(t);
          }
          load(t, e, n, r) {
            const i = this,
              s = new qd(this.manager);
            s.setResponseType("arraybuffer"),
              s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    const o = n.slice(0);
                    pf.getContext().decodeAudioData(o, function (t) {
                      e(t);
                    });
                  } catch (s) {
                    r ? r(s) : console.error(s), i.manager.itemError(t);
                  }
                },
                n,
                r
              );
          }
        }
        exports.AudioLoader = df;
        class mf extends Ym {
          constructor(t, e, n = 1) {
            super(void 0, n);
            const r = new Vi().set(t),
              i = new Vi().set(e),
              s = new xr(r.r, r.g, r.b),
              o = new xr(i.r, i.g, i.b),
              a = Math.sqrt(Math.PI),
              l = a * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),
              this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l);
          }
        }
        (exports.HemisphereLightProbe = mf),
          (mf.prototype.isHemisphereLightProbe = !0);
        class ff extends Ym {
          constructor(t, e = 1) {
            super(void 0, e);
            const n = new Vi().set(t);
            this.sh.coefficients[0]
              .set(n.r, n.g, n.b)
              .multiplyScalar(2 * Math.sqrt(Math.PI));
          }
        }
        (exports.AmbientLightProbe = ff),
          (ff.prototype.isAmbientLightProbe = !0);
        const gf = new Yr(),
          xf = new Yr();
        class vf {
          constructor() {
            (this.type = "StereoCamera"),
              (this.aspect = 1),
              (this.eyeSep = 0.064),
              (this.cameraL = new Vs()),
              this.cameraL.layers.enable(1),
              (this.cameraL.matrixAutoUpdate = !1),
              (this.cameraR = new Vs()),
              this.cameraR.layers.enable(2),
              (this.cameraR.matrixAutoUpdate = !1),
              (this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null,
              });
          }
          update(t) {
            const e = this._cache;
            if (
              e.focus !== t.focus ||
              e.fov !== t.fov ||
              e.aspect !== t.aspect * this.aspect ||
              e.near !== t.near ||
              e.far !== t.far ||
              e.zoom !== t.zoom ||
              e.eyeSep !== this.eyeSep
            ) {
              (e.focus = t.focus),
                (e.fov = t.fov),
                (e.aspect = t.aspect * this.aspect),
                (e.near = t.near),
                (e.far = t.far),
                (e.zoom = t.zoom),
                (e.eyeSep = this.eyeSep);
              const n = t.projectionMatrix.clone(),
                r = e.eyeSep / 2,
                i = (r * e.near) / e.focus,
                s = (e.near * Math.tan(Nn * e.fov * 0.5)) / e.zoom;
              let o, a;
              (xf.elements[12] = -r),
                (gf.elements[12] = r),
                (o = -s * e.aspect + i),
                (a = s * e.aspect + i),
                (n.elements[0] = (2 * e.near) / (a - o)),
                (n.elements[8] = (a + o) / (a - o)),
                this.cameraL.projectionMatrix.copy(n),
                (o = -s * e.aspect - i),
                (a = s * e.aspect - i),
                (n.elements[0] = (2 * e.near) / (a - o)),
                (n.elements[8] = (a + o) / (a - o)),
                this.cameraR.projectionMatrix.copy(n);
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(xf),
              this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(gf);
          }
        }
        exports.StereoCamera = vf;
        class yf {
          constructor(t = !0) {
            (this.autoStart = t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = _f()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              const e = _f();
              (t = (e - this.oldTime) / 1e3),
                (this.oldTime = e),
                (this.elapsedTime += t);
            }
            return t;
          }
        }
        function _f() {
          return ("undefined" == typeof performance ? Date : performance).now();
        }
        exports.Clock = yf;
        const Mf = new xr(),
          wf = new gr(),
          bf = new xr(),
          Sf = new xr();
        class Tf extends yi {
          constructor() {
            super(),
              (this.type = "AudioListener"),
              (this.context = pf.getContext()),
              (this.gain = this.context.createGain()),
              this.gain.connect(this.context.destination),
              (this.filter = null),
              (this.timeDelta = 0),
              (this._clock = new yf());
          }
          getInput() {
            return this.gain;
          }
          removeFilter() {
            return (
              null !== this.filter &&
              (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                (this.filter = null)),
              this
            );
          }
          getFilter() {
            return this.filter;
          }
          setFilter(t) {
            return (
              null !== this.filter
                ? (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination))
                : this.gain.disconnect(this.context.destination),
              (this.filter = t),
              this.gain.connect(this.filter),
              this.filter.connect(this.context.destination),
              this
            );
          }
          getMasterVolume() {
            return this.gain.gain.value;
          }
          setMasterVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t);
            const e = this.context.listener,
              n = this.up;
            if (
              ((this.timeDelta = this._clock.getDelta()),
                this.matrixWorld.decompose(Mf, wf, bf),
                Sf.set(0, 0, -1).applyQuaternion(wf),
                e.positionX)
            ) {
              const t = this.context.currentTime + this.timeDelta;
              e.positionX.linearRampToValueAtTime(Mf.x, t),
                e.positionY.linearRampToValueAtTime(Mf.y, t),
                e.positionZ.linearRampToValueAtTime(Mf.z, t),
                e.forwardX.linearRampToValueAtTime(Sf.x, t),
                e.forwardY.linearRampToValueAtTime(Sf.y, t),
                e.forwardZ.linearRampToValueAtTime(Sf.z, t),
                e.upX.linearRampToValueAtTime(n.x, t),
                e.upY.linearRampToValueAtTime(n.y, t),
                e.upZ.linearRampToValueAtTime(n.z, t);
            } else
              e.setPosition(Mf.x, Mf.y, Mf.z),
                e.setOrientation(Sf.x, Sf.y, Sf.z, n.x, n.y, n.z);
          }
        }
        exports.AudioListener = Tf;
        class Ef extends yi {
          constructor(t) {
            super(),
              (this.type = "Audio"),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = "empty"),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = []);
          }
          getOutput() {
            return this.gain;
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "audioNode"),
              (this.source = t),
              this.connect(),
              this
            );
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaNode"),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            );
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaStreamNode"),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            );
          }
          setBuffer(t) {
            return (
              (this.buffer = t),
              (this.sourceType = "buffer"),
              this.autoplay && this.play(),
              this
            );
          }
          play(t = 0) {
            if (!0 === this.isPlaying)
              return void console.warn(
                "THREE.Audio: Audio is already playing."
              );
            if (!1 === this.hasPlaybackControl)
              return void console.warn(
                "THREE.Audio: this Audio has no playback control."
              );
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(
                this._startedAt,
                this._progress + this.offset,
                this.duration
              ),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            );
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                ((this._progress +=
                  Math.max(this.context.currentTime - this._startedAt, 0) *
                  this.playbackRate),
                  !0 === this.loop &&
                  (this._progress =
                    this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return (this._connected = !0), this;
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
          }
          getFilters() {
            return this.filters;
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(),
                  (this.filters = t.slice()),
                  this.connect())
                : (this.filters = t.slice()),
              this
            );
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                this.source.detune.setTargetAtTime(
                  this.detune,
                  this.context.currentTime,
                  0.01
                ),
                this
              );
          }
          getDetune() {
            return this.detune;
          }
          getFilter() {
            return this.getFilters()[0];
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : []);
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                this.source.playbackRate.setTargetAtTime(
                  this.playbackRate,
                  this.context.currentTime,
                  0.01
                ),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          getPlaybackRate() {
            return this.playbackRate;
          }
          onEnded() {
            this.isPlaying = !1;
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                "THREE.Audio: this Audio has no playback control."
              ),
                !1)
              : this.loop;
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = t),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          setLoopStart(t) {
            return (this.loopStart = t), this;
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this;
          }
          getVolume() {
            return this.gain.gain.value;
          }
          setVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
        }
        exports.Audio = Ef;
        const Af = new xr(),
          Lf = new gr(),
          Rf = new xr(),
          Cf = new xr();
        class Pf extends Ef {
          constructor(t) {
            super(t),
              (this.panner = this.context.createPanner()),
              (this.panner.panningModel = "HRTF"),
              this.panner.connect(this.gain);
          }
          getOutput() {
            return this.panner;
          }
          getRefDistance() {
            return this.panner.refDistance;
          }
          setRefDistance(t) {
            return (this.panner.refDistance = t), this;
          }
          getRolloffFactor() {
            return this.panner.rolloffFactor;
          }
          setRolloffFactor(t) {
            return (this.panner.rolloffFactor = t), this;
          }
          getDistanceModel() {
            return this.panner.distanceModel;
          }
          setDistanceModel(t) {
            return (this.panner.distanceModel = t), this;
          }
          getMaxDistance() {
            return this.panner.maxDistance;
          }
          setMaxDistance(t) {
            return (this.panner.maxDistance = t), this;
          }
          setDirectionalCone(t, e, n) {
            return (
              (this.panner.coneInnerAngle = t),
              (this.panner.coneOuterAngle = e),
              (this.panner.coneOuterGain = n),
              this
            );
          }
          updateMatrixWorld(t) {
            if (
              (super.updateMatrixWorld(t),
                !0 === this.hasPlaybackControl && !1 === this.isPlaying)
            )
              return;
            this.matrixWorld.decompose(Af, Lf, Rf),
              Cf.set(0, 0, 1).applyQuaternion(Lf);
            const e = this.panner;
            if (e.positionX) {
              const t = this.context.currentTime + this.listener.timeDelta;
              e.positionX.linearRampToValueAtTime(Af.x, t),
                e.positionY.linearRampToValueAtTime(Af.y, t),
                e.positionZ.linearRampToValueAtTime(Af.z, t),
                e.orientationX.linearRampToValueAtTime(Cf.x, t),
                e.orientationY.linearRampToValueAtTime(Cf.y, t),
                e.orientationZ.linearRampToValueAtTime(Cf.z, t);
            } else
              e.setPosition(Af.x, Af.y, Af.z),
                e.setOrientation(Cf.x, Cf.y, Cf.z);
          }
        }
        exports.PositionalAudio = Pf;
        class Df {
          constructor(t, e = 2048) {
            (this.analyser = t.context.createAnalyser()),
              (this.analyser.fftSize = e),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              t.getOutput().connect(this.analyser);
          }
          getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          }
          getAverageFrequency() {
            let t = 0;
            const e = this.getFrequencyData();
            for (let n = 0; n < e.length; n++) t += e[n];
            return t / e.length;
          }
        }
        exports.AudioAnalyser = Df;
        class If {
          constructor(t, e, n) {
            let r, i, s;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case "quaternion":
                (r = this._slerp),
                  (i = this._slerpAdditive),
                  (s = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (r = this._select),
                  (i = this._select),
                  (s = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (r = this._lerp),
                  (i = this._lerpAdditive),
                  (s = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = r),
              (this._mixBufferRegionAdditive = i),
              (this._setIdentity = s),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              r = this.valueSize,
              i = t * r + r;
            let s = this.cumulativeWeight;
            if (0 === s) {
              for (let t = 0; t !== r; ++t) n[i + t] = n[t];
              s = e;
            } else {
              const t = e / (s += e);
              this._mixBufferRegion(n, i, 0, t, r);
            }
            this.cumulativeWeight = s;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              r = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, r, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              r = t * e + e,
              i = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              o = this.binding;
            if (
              ((this.cumulativeWeight = 0),
                (this.cumulativeWeightAdditive = 0),
                i < 1)
            ) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, r, t, 1 - i, e);
            }
            s > 0 &&
              this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
            for (let a = e, l = e + e; a !== l; ++a)
              if (n[a] !== n[a + e]) {
                o.setValue(n, r);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              r = n * this._origIndex;
            t.getValue(e, r);
            for (let i = n, s = r; i !== s; ++i) e[i] = e[r + (i % n)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
              this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, r, i) {
            if (r >= 0.5) for (let s = 0; s !== i; ++s) t[e + s] = t[n + s];
          }
          _slerp(t, e, n, r) {
            gr.slerpFlat(t, e, t, e, t, n, r);
          }
          _slerpAdditive(t, e, n, r, i) {
            const s = this._workIndex * i;
            gr.multiplyQuaternionsFlat(t, s, t, e, t, n),
              gr.slerpFlat(t, e, t, e, t, s, r);
          }
          _lerp(t, e, n, r, i) {
            const s = 1 - r;
            for (let o = 0; o !== i; ++o) {
              const i = e + o;
              t[i] = t[i] * s + t[n + o] * r;
            }
          }
          _lerpAdditive(t, e, n, r, i) {
            for (let s = 0; s !== i; ++s) {
              const i = e + s;
              t[i] = t[i] + t[n + s] * r;
            }
          }
        }
        exports.PropertyMixer = If;
        const Bf = "\\[\\]\\.:\\/",
          Ff = new RegExp("[\\[\\]\\.:\\/]", "g"),
          Nf = "[^\\[\\]\\.:\\/]",
          Gf = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
          zf = /((?:WC+[\/:])*)/.source.replace("WC", Nf),
          Of = /(WCOD+)?/.source.replace("WCOD", Gf),
          Hf = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Nf),
          Uf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Nf),
          kf = new RegExp("^" + zf + Of + Hf + Uf + "$"),
          Vf = ["material", "materials", "bones"];
        class Wf {
          constructor(t, e, n) {
            const r = n || jf.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, r));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              r = this._bindings[n];
            void 0 !== r && r.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (
              let r = this._targetGroup.nCachedObjects_, i = n.length;
              r !== i;
              ++r
            )
              n[r].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].unbind();
          }
        }
        class jf {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || jf.parseTrackName(e)),
              (this.node = jf.findNode(t, this.parsedPath.nodeName) || t),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup
              ? new jf.Composite(t, e, n)
              : new jf(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Ff, "");
          }
          static parseTrackName(t) {
            const e = kf.exec(t);
            if (!e)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
              r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r) {
              const t = n.nodeName.substring(r + 1);
              -1 !== Vf.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, r)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                t
              );
            return n;
          }
          static findNode(t, e) {
            if (
              !e ||
              "" === e ||
              "." === e ||
              -1 === e ||
              e === t.name ||
              e === t.uuid
            )
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                for (let r = 0; r < t.length; r++) {
                  const i = t[r];
                  if (i.name === e || i.uuid === e) return i;
                  const s = n(i.children);
                  if (s) return s;
                }
                return null;
              },
                r = n(t.children);
              if (r) return r;
            }
            return null;
          }
          _getValue_unavailable() { }
          _setValue_unavailable() { }
          _getValue_direct(t, e) {
            t[e] = this.node[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              r = e.propertyName;
            let i = e.propertyIndex;
            if (
              (t ||
                ((t = jf.findNode(this.rootNode, e.nodeName) || this.rootNode),
                  (this.node = t)),
                (this.getValue = this._getValue_unavailable),
                (this.setValue = this._setValue_unavailable),
                !t)
            )
              return void console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                this.path +
                " but it wasn't found."
              );
            if (n) {
              let r = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === r) {
                      r = e;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== r) {
                if (void 0 === t[r])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[r];
              }
            }
            const s = t[r];
            if (void 0 === s) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                r +
                " but it wasn't found.",
                t
              );
            }
            let o = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (o = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                (o = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== i) {
              if ("morphTargetInfluences" === r) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.isBufferGeometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[i] &&
                  (i = t.morphTargetDictionary[i]);
              }
              (a = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = i);
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray
                ? ((a = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = s))
                : Array.isArray(s)
                  ? ((a = this.BindingType.EntireArray),
                    (this.resolvedProperty = s))
                  : (this.propertyName = r);
            (this.getValue = this.GetterByBindingType[a]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (exports.PropertyBinding = jf),
          (jf.Composite = Wf),
          (jf.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (jf.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2,
          }),
          (jf.prototype.GetterByBindingType = [
            jf.prototype._getValue_direct,
            jf.prototype._getValue_array,
            jf.prototype._getValue_arrayElement,
            jf.prototype._getValue_toArray,
          ]),
          (jf.prototype.SetterByBindingTypeAndVersioning = [
            [
              jf.prototype._setValue_direct,
              jf.prototype._setValue_direct_setNeedsUpdate,
              jf.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              jf.prototype._setValue_array,
              jf.prototype._setValue_array_setNeedsUpdate,
              jf.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              jf.prototype._setValue_arrayElement,
              jf.prototype._setValue_arrayElement_setNeedsUpdate,
              jf.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              jf.prototype._setValue_fromArray,
              jf.prototype._setValue_fromArray_setNeedsUpdate,
              jf.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        class qf {
          constructor() {
            (this.uuid = zn()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0);
            const t = {};
            this._indicesByUUID = t;
            for (let n = 0, r = arguments.length; n !== r; ++n)
              t[arguments[n].uuid] = n;
            (this._paths = []),
              (this._parsedPaths = []),
              (this._bindings = []),
              (this._bindingsIndicesByPath = {});
            const e = this;
            this.stats = {
              objects: {
                get total() {
                  return e._objects.length;
                },
                get inUse() {
                  return this.total - e.nCachedObjects_;
                },
              },
              get bindingsPerObject() {
                return e._bindings.length;
              },
            };
          }
          add() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._paths,
              r = this._parsedPaths,
              i = this._bindings,
              s = i.length;
            let o = void 0,
              a = t.length,
              l = this.nCachedObjects_;
            for (let c = 0, h = arguments.length; c !== h; ++c) {
              const h = arguments[c],
                u = h.uuid;
              let p = e[u];
              if (void 0 === p) {
                (p = a++), (e[u] = p), t.push(h);
                for (let t = 0, e = s; t !== e; ++t)
                  i[t].push(new jf(h, n[t], r[t]));
              } else if (p < l) {
                o = t[p];
                const a = --l,
                  c = t[a];
                (e[c.uuid] = p), (t[p] = c), (e[u] = a), (t[a] = h);
                for (let t = 0, e = s; t !== e; ++t) {
                  const e = i[t],
                    s = e[a];
                  let o = e[p];
                  (e[p] = s),
                    void 0 === o && (o = new jf(h, n[t], r[t])),
                    (e[a] = o);
                }
              } else
                t[p] !== o &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = l;
          }
          remove() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              r = n.length;
            let i = this.nCachedObjects_;
            for (let s = 0, o = arguments.length; s !== o; ++s) {
              const o = arguments[s],
                a = o.uuid,
                l = e[a];
              if (void 0 !== l && l >= i) {
                const s = i++,
                  c = t[s];
                (e[c.uuid] = l), (t[l] = c), (e[a] = s), (t[s] = o);
                for (let t = 0, e = r; t !== e; ++t) {
                  const e = n[t],
                    r = e[s],
                    i = e[l];
                  (e[l] = r), (e[s] = i);
                }
              }
            }
            this.nCachedObjects_ = i;
          }
          uncache() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              r = n.length;
            let i = this.nCachedObjects_,
              s = t.length;
            for (let o = 0, a = arguments.length; o !== a; ++o) {
              const a = arguments[o].uuid,
                l = e[a];
              if (void 0 !== l)
                if ((delete e[a], l < i)) {
                  const o = --i,
                    a = t[o],
                    c = --s,
                    h = t[c];
                  (e[a.uuid] = l),
                    (t[l] = a),
                    (e[h.uuid] = o),
                    (t[o] = h),
                    t.pop();
                  for (let t = 0, e = r; t !== e; ++t) {
                    const e = n[t],
                      r = e[o],
                      i = e[c];
                    (e[l] = r), (e[o] = i), e.pop();
                  }
                } else {
                  const i = --s,
                    o = t[i];
                  i > 0 && (e[o.uuid] = l), (t[l] = o), t.pop();
                  for (let t = 0, e = r; t !== e; ++t) {
                    const e = n[t];
                    (e[l] = e[i]), e.pop();
                  }
                }
            }
            this.nCachedObjects_ = i;
          }
          subscribe_(t, e) {
            const n = this._bindingsIndicesByPath;
            let r = n[t];
            const i = this._bindings;
            if (void 0 !== r) return i[r];
            const s = this._paths,
              o = this._parsedPaths,
              a = this._objects,
              l = a.length,
              c = this.nCachedObjects_,
              h = new Array(l);
            (r = i.length), (n[t] = r), s.push(t), o.push(e), i.push(h);
            for (let u = c, p = a.length; u !== p; ++u) {
              const n = a[u];
              h[u] = new jf(n, t, e);
            }
            return h;
          }
          unsubscribe_(t) {
            const e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              const r = this._paths,
                i = this._parsedPaths,
                s = this._bindings,
                o = s.length - 1,
                a = s[o];
              (e[t[o]] = n),
                (s[n] = a),
                s.pop(),
                (i[n] = i[o]),
                i.pop(),
                (r[n] = r[o]),
                r.pop();
            }
          }
        }
        (exports.AnimationObjectGroup = qf),
          (qf.prototype.isAnimationObjectGroup = !0);
        class Xf {
          constructor(t, e, n = null, r = e.blendMode) {
            (this._mixer = t),
              (this._clip = e),
              (this._localRoot = n),
              (this.blendMode = r);
            const i = e.tracks,
              s = i.length,
              o = new Array(s),
              a = { endingStart: Oe, endingEnd: Oe };
            for (let l = 0; l !== s; ++l) {
              const t = i[l].createInterpolant(null);
              (o[l] = t), (t.settings = a);
            }
            (this._interpolantSettings = a),
              (this._interpolants = o),
              (this._propertyBindings = new Array(s)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = Be),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t),
              (this._effectiveWeight = this.enabled ? t : 0),
              this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                r = t._clip.duration,
                i = r / n,
                s = n / r;
              t.warp(1, i, e), this.warp(s, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
              ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (
              (this.timeScale = this._clip.duration / t), this.stopWarping()
            );
          }
          syncWith(t) {
            return (
              (this.time = t.time),
              (this.timeScale = t.timeScale),
              this.stopWarping()
            );
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const r = this._mixer,
              i = r.time,
              s = this.timeScale;
            let o = this._timeScaleInterpolant;
            null === o &&
              ((o = r._lendControlInterpolant()),
                (this._timeScaleInterpolant = o));
            const a = o.parameterPositions,
              l = o.sampleValues;
            return (
              (a[0] = i), (a[1] = i + n), (l[0] = t / s), (l[1] = e / s), this
            );
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
              ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, r) {
            if (!this.enabled) return void this._updateWeight(t);
            const i = this._startTime;
            if (null !== i) {
              const r = (t - i) * n;
              if (r < 0 || 0 === n) return;
              (this._startTime = null), (e = n * r);
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e),
              o = this._updateWeight(t);
            if (o > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              switch (this.blendMode) {
                case Ve:
                  for (let n = 0, r = t.length; n !== r; ++n)
                    t[n].evaluate(s), e[n].accumulateAdditive(o);
                  break;
                case ke:
                default:
                  for (let n = 0, i = t.length; n !== i; ++n)
                    t[n].evaluate(s), e[n].accumulate(r, o);
              }
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const r = n.evaluate(t)[0];
                (e *= r),
                  t > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === r && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              if (null !== n) {
                (e *= n.evaluate(t)[0]),
                  t > n.parameterPositions[1] &&
                  (this.stopWarping(),
                    0 === e ? (this.paused = !0) : (this.timeScale = e));
              }
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let r = this.time + t,
              i = this._loopCount;
            const s = n === Fe;
            if (0 === t) return -1 === i ? r : s && 1 == (1 & i) ? e - r : r;
            if (n === Ie) {
              -1 === i && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (r >= e) r = e;
                else {
                  if (!(r < 0)) {
                    this.time = r;
                    break t;
                  }
                  r = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = r),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === i &&
                  (t >= 0
                    ? ((i = 0), this._setEndings(!0, 0 === this.repetitions, s))
                    : this._setEndings(0 === this.repetitions, !0, s)),
                  r >= e || r < 0)
              ) {
                const n = Math.floor(r / e);
                (r -= e * n), (i += Math.abs(n));
                const o = this.repetitions - i;
                if (o <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (r = t > 0 ? e : 0),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === o) {
                    const e = t < 0;
                    this._setEndings(e, !e, s);
                  } else this._setEndings(!1, !1, s);
                  (this._loopCount = i),
                    (this.time = r),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: n,
                    });
                }
              } else this.time = r;
              if (s && 1 == (1 & i)) return e - r;
            }
            return r;
          }
          _setEndings(t, e, n) {
            const r = this._interpolantSettings;
            n
              ? ((r.endingStart = He), (r.endingEnd = He))
              : ((r.endingStart = t ? (this.zeroSlopeAtStart ? He : Oe) : Ue),
                (r.endingEnd = e ? (this.zeroSlopeAtEnd ? He : Oe) : Ue));
          }
          _scheduleFading(t, e, n) {
            const r = this._mixer,
              i = r.time;
            let s = this._weightInterpolant;
            null === s &&
              ((s = r._lendControlInterpolant()),
                (this._weightInterpolant = s));
            const o = s.parameterPositions,
              a = s.sampleValues;
            return (o[0] = i), (a[0] = e), (o[1] = i + t), (a[1] = n), this;
          }
        }
        class Yf extends In {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              r = t._clip.tracks,
              i = r.length,
              s = t._propertyBindings,
              o = t._interpolants,
              a = n.uuid,
              l = this._bindingsByRootAndName;
            let c = l[a];
            void 0 === c && ((c = {}), (l[a] = c));
            for (let h = 0; h !== i; ++h) {
              const t = r[h],
                i = t.name;
              let l = c[i];
              if (void 0 !== l) s[h] = l;
              else {
                if (void 0 !== (l = s[h])) {
                  null === l._cacheIndex &&
                    (++l.referenceCount, this._addInactiveBinding(l, a, i));
                  continue;
                }
                const r = e && e._propertyBindings[h].binding.parsedPath;
                ++(l = new If(
                  jf.create(n, i, r),
                  t.ValueTypeName,
                  t.getValueSize()
                )).referenceCount,
                  this._addInactiveBinding(l, a, i),
                  (s[h] = l);
              }
              o[h].resultBuffer = l.buffer;
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  r = this._actionsByClip[n];
                this._bindAction(t, r && r.knownActions[0]),
                  this._addInactiveAction(t, n, e);
              }
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == n.useCount++ &&
                  (this._lendBinding(n), n.saveOriginalState());
              }
              this._lendAction(t);
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.useCount &&
                  (n.restoreOriginalState(), this._takeBackBinding(n));
              }
              this._takeBackAction(t);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            const t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          }
          _addInactiveAction(t, e, n) {
            const r = this._actions,
              i = this._actionsByClip;
            let s = i[e];
            if (void 0 === s)
              (s = { knownActions: [t], actionByRoot: {} }),
                (t._byClipCacheIndex = 0),
                (i[e] = s);
            else {
              const e = s.knownActions;
              (t._byClipCacheIndex = e.length), e.push(t);
            }
            (t._cacheIndex = r.length), r.push(t), (s.actionByRoot[n] = t);
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              r = t._cacheIndex;
            (n._cacheIndex = r), (e[r] = n), e.pop(), (t._cacheIndex = null);
            const i = t._clip.uuid,
              s = this._actionsByClip,
              o = s[i],
              a = o.knownActions,
              l = a[a.length - 1],
              c = t._byClipCacheIndex;
            (l._byClipCacheIndex = c),
              (a[c] = l),
              a.pop(),
              (t._byClipCacheIndex = null),
              delete o.actionByRoot[(t._localRoot || this._root).uuid],
              0 === a.length && delete s[i],
              this._removeInactiveBindingsForAction(t);
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let n = 0, r = e.length; n !== r; ++n) {
              const t = e[n];
              0 == --t.referenceCount && this._removeInactiveBinding(t);
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              r = this._nActiveActions++,
              i = e[r];
            (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              r = --this._nActiveActions,
              i = e[r];
            (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _addInactiveBinding(t, e, n) {
            const r = this._bindingsByRootAndName,
              i = this._bindings;
            let s = r[e];
            void 0 === s && ((s = {}), (r[e] = s)),
              (s[n] = t),
              (t._cacheIndex = i.length),
              i.push(t);
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              r = n.rootNode.uuid,
              i = n.path,
              s = this._bindingsByRootAndName,
              o = s[r],
              a = e[e.length - 1],
              l = t._cacheIndex;
            (a._cacheIndex = l),
              (e[l] = a),
              e.pop(),
              delete o[i],
              0 === Object.keys(o).length && delete s[r];
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              r = this._nActiveBindings++,
              i = e[r];
            (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              r = --this._nActiveBindings,
              i = e[r];
            (t._cacheIndex = r), (e[r] = t), (i._cacheIndex = n), (e[n] = i);
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++;
            let n = t[e];
            return (
              void 0 === n &&
              (((n = new Ld(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )).__cacheIndex = e),
                (t[e] = n)),
              n
            );
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              r = --this._nActiveControlInterpolants,
              i = e[r];
            (t.__cacheIndex = r), (e[r] = t), (i.__cacheIndex = n), (e[n] = i);
          }
          clipAction(t, e, n) {
            const r = e || this._root,
              i = r.uuid;
            let s = "string" == typeof t ? zd.findByName(r, t) : t;
            const o = null !== s ? s.uuid : t,
              a = this._actionsByClip[o];
            let l = null;
            if (
              (void 0 === n && (n = null !== s ? s.blendMode : ke),
                void 0 !== a)
            ) {
              const t = a.actionByRoot[i];
              if (void 0 !== t && t.blendMode === n) return t;
              (l = a.knownActions[0]), null === s && (s = l._clip);
            }
            if (null === s) return null;
            const c = new Xf(this, s, e, n);
            return this._bindAction(c, l), this._addInactiveAction(c, o, i), c;
          }
          existingAction(t, e) {
            const n = e || this._root,
              r = n.uuid,
              i = "string" == typeof t ? zd.findByName(n, t) : t,
              s = i ? i.uuid : t,
              o = this._actionsByClip[s];
            return (void 0 !== o && o.actionByRoot[r]) || null;
          }
          stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this;
          }
          update(t) {
            t *= this.timeScale;
            const e = this._actions,
              n = this._nActiveActions,
              r = (this.time += t),
              i = Math.sign(t),
              s = (this._accuIndex ^= 1);
            for (let l = 0; l !== n; ++l) {
              e[l]._update(r, t, i, s);
            }
            const o = this._bindings,
              a = this._nActiveBindings;
            for (let l = 0; l !== a; ++l) o[l].apply(s);
            return this;
          }
          setTime(t) {
            this.time = 0;
            for (let e = 0; e < this._actions.length; e++)
              this._actions[e].time = 0;
            return this.update(t);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              r = this._actionsByClip,
              i = r[n];
            if (void 0 !== i) {
              const t = i.knownActions;
              for (let n = 0, r = t.length; n !== r; ++n) {
                const r = t[n];
                this._deactivateAction(r);
                const i = r._cacheIndex,
                  s = e[e.length - 1];
                (r._cacheIndex = null),
                  (r._byClipCacheIndex = null),
                  (s._cacheIndex = i),
                  (e[i] = s),
                  e.pop(),
                  this._removeInactiveBindingsForAction(r);
              }
              delete r[n];
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip;
            for (const i in n) {
              const t = n[i].actionByRoot[e];
              void 0 !== t &&
                (this._deactivateAction(t), this._removeInactiveAction(t));
            }
            const r = this._bindingsByRootAndName[e];
            if (void 0 !== r)
              for (const i in r) {
                const t = r[i];
                t.restoreOriginalState(), this._removeInactiveBinding(t);
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          }
        }
        (exports.AnimationMixer = Yf),
          (Yf.prototype._controlInterpolantsResultBuffer = new Float32Array(1));
        class Zf {
          constructor(t) {
            "string" == typeof t &&
              (console.warn(
                "THREE.Uniform: Type parameter is no longer needed."
              ),
                (t = arguments[1])),
              (this.value = t);
          }
          clone() {
            return new Zf(
              void 0 === this.value.clone ? this.value : this.value.clone()
            );
          }
        }
        exports.Uniform = Zf;
        class Jf extends $h {
          constructor(t, e, n = 1) {
            super(t, e), (this.meshPerAttribute = n || 1);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          clone(t) {
            const e = super.clone(t);
            return (e.meshPerAttribute = this.meshPerAttribute), e;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.isInstancedInterleavedBuffer = !0),
              (e.meshPerAttribute = this.meshPerAttribute),
              e
            );
          }
        }
        (exports.InstancedInterleavedBuffer = Jf),
          (Jf.prototype.isInstancedInterleavedBuffer = !0);
        class Qf {
          constructor(t, e, n, r, i) {
            (this.buffer = t),
              (this.type = e),
              (this.itemSize = n),
              (this.elementSize = r),
              (this.count = i),
              (this.version = 0);
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setBuffer(t) {
            return (this.buffer = t), this;
          }
          setType(t, e) {
            return (this.type = t), (this.elementSize = e), this;
          }
          setItemSize(t) {
            return (this.itemSize = t), this;
          }
          setCount(t) {
            return (this.count = t), this;
          }
        }
        (exports.GLBufferAttribute = Qf),
          (Qf.prototype.isGLBufferAttribute = !0);
        class Kf {
          constructor(t, e, n = 0, r = 1 / 0) {
            (this.ray = new Xr(t, e)),
              (this.near = n),
              (this.far = r),
              (this.camera = null),
              (this.layers = new si()),
              (this.params = {
                Mesh: {},
                Line: { threshold: 1 },
                LOD: {},
                Points: { threshold: 1 },
                Sprite: {},
              });
          }
          set(t, e) {
            this.ray.set(t, e);
          }
          setFromCamera(t, e) {
            e && e.isPerspectiveCamera
              ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction
                  .set(t.x, t.y, 0.5)
                  .unproject(e)
                  .sub(this.ray.origin)
                  .normalize(),
                (this.camera = e))
              : e && e.isOrthographicCamera
                ? (this.ray.origin
                  .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                  .unproject(e),
                  this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error(
                  "THREE.Raycaster: Unsupported camera type: " + e.type
                );
          }
          intersectObject(t, e = !1, n = []) {
            return tg(t, this, n, e), n.sort($f), n;
          }
          intersectObjects(t, e = !1, n = []) {
            for (let r = 0, i = t.length; r < i; r++) tg(t[r], this, n, e);
            return n.sort($f), n;
          }
        }
        function $f(t, e) {
          return t.distance - e.distance;
        }
        function tg(t, e, n, r) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === r)) {
            const r = t.children;
            for (let t = 0, i = r.length; t < i; t++) tg(r[t], e, n, !0);
          }
        }
        exports.Raycaster = Kf;
        class eg {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.phi = e), (this.theta = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.phi = t.phi),
              (this.theta = t.theta),
              this
            );
          }
          makeSafe() {
            return (
              (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))),
              this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + e * e + n * n)),
              0 === this.radius
                ? ((this.theta = 0), (this.phi = 0))
                : ((this.theta = Math.atan2(t, n)),
                  (this.phi = Math.acos(On(e / this.radius, -1, 1)))),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        exports.Spherical = eg;
        class ng {
          constructor(t = 1, e = 0, n = 0) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          }
          set(t, e, n) {
            return (this.radius = t), (this.theta = e), (this.y = n), this;
          }
          copy(t) {
            return (
              (this.radius = t.radius),
              (this.theta = t.theta),
              (this.y = t.y),
              this
            );
          }
          setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z);
          }
          setFromCartesianCoords(t, e, n) {
            return (
              (this.radius = Math.sqrt(t * t + n * n)),
              (this.theta = Math.atan2(t, n)),
              (this.y = e),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        exports.Cylindrical = ng;
        const rg = new sr();
        class ig {
          constructor(t = new sr(1 / 0, 1 / 0), e = new sr(-1 / 0, -1 / 0)) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = rg.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Box2: .getCenter() target is now required"
              ),
                (t = new sr())),
              this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
              (console.warn("THREE.Box2: .getSize() target is now required"),
                (t = new sr())),
              this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Box2: .getParameter() target is now required"
              ),
                (e = new sr())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y)
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
              (console.warn(
                "THREE.Box2: .clampPoint() target is now required"
              ),
                (e = new sr())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return rg.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this;
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        (exports.Box2 = ig), (ig.prototype.isBox2 = !0);
        const sg = new xr(),
          og = new xr();
        class ag {
          constructor(t = new xr(), e = new xr()) {
            (this.start = t), (this.end = e);
          }
          set(t, e) {
            return this.start.copy(t), this.end.copy(e), this;
          }
          copy(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this;
          }
          getCenter(t) {
            return (
              void 0 === t &&
              (console.warn(
                "THREE.Line3: .getCenter() target is now required"
              ),
                (t = new xr())),
              t.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          }
          delta(t) {
            return (
              void 0 === t &&
              (console.warn("THREE.Line3: .delta() target is now required"),
                (t = new xr())),
              t.subVectors(this.end, this.start)
            );
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(t, e) {
            return (
              void 0 === e &&
              (console.warn("THREE.Line3: .at() target is now required"),
                (e = new xr())),
              this.delta(e).multiplyScalar(t).add(this.start)
            );
          }
          closestPointToPointParameter(t, e) {
            sg.subVectors(t, this.start), og.subVectors(this.end, this.start);
            const n = og.dot(og);
            let r = og.dot(sg) / n;
            return e && (r = On(r, 0, 1)), r;
          }
          closestPointToPoint(t, e, n) {
            const r = this.closestPointToPointParameter(t, e);
            return (
              void 0 === n &&
              (console.warn(
                "THREE.Line3: .closestPointToPoint() target is now required"
              ),
                (n = new xr())),
              this.delta(n).multiplyScalar(r).add(this.start)
            );
          }
          applyMatrix4(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
          }
          equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        exports.Line3 = ag;
        class lg extends yi {
          constructor(t) {
            super(),
              (this.material = t),
              (this.render = function () { }),
              (this.hasPositions = !1),
              (this.hasNormals = !1),
              (this.hasColors = !1),
              (this.hasUvs = !1),
              (this.positionArray = null),
              (this.normalArray = null),
              (this.colorArray = null),
              (this.uvArray = null),
              (this.count = 0);
          }
        }
        (exports.ImmediateRenderObject = lg),
          (lg.prototype.isImmediateRenderObject = !0);
        const cg = new xr();
        class hg extends yi {
          constructor(t, e) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = e);
            const n = new ms(),
              r = [
                0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0,
                0, 1, 1, 0, 0, 0, 0, -1, 1,
              ];
            for (let s = 0, o = 1, a = 32; s < a; s++, o++) {
              const t = (s / a) * Math.PI * 2,
                e = (o / a) * Math.PI * 2;
              r.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1);
            }
            n.setAttribute("position", new ns(r, 3));
            const i = new Gu({ fog: !1, toneMapped: !1 });
            (this.cone = new qu(n, i)), this.add(this.cone), this.update();
          }
          dispose() {
            this.cone.geometry.dispose(), this.cone.material.dispose();
          }
          update() {
            this.light.updateMatrixWorld();
            const t = this.light.distance ? this.light.distance : 1e3,
              e = t * Math.tan(this.light.angle);
            this.cone.scale.set(e, e, t),
              cg.setFromMatrixPosition(this.light.target.matrixWorld),
              this.cone.lookAt(cg),
              void 0 !== this.color
                ? this.cone.material.color.set(this.color)
                : this.cone.material.color.copy(this.light.color);
          }
        }
        exports.SpotLightHelper = hg;
        const ug = new xr(),
          pg = new Yr(),
          dg = new Yr();
        class mg extends qu {
          constructor(t) {
            const e = fg(t),
              n = new ms(),
              r = [],
              i = [],
              s = new Vi(0, 0, 1),
              o = new Vi(0, 1, 0);
            for (let a = 0; a < e.length; a++) {
              const t = e[a];
              t.parent &&
                t.parent.isBone &&
                (r.push(0, 0, 0),
                  r.push(0, 0, 0),
                  i.push(s.r, s.g, s.b),
                  i.push(o.r, o.g, o.b));
            }
            n.setAttribute("position", new ns(r, 3)),
              n.setAttribute("color", new ns(i, 3)),
              super(
                n,
                new Gu({
                  vertexColors: !0,
                  depthTest: !1,
                  depthWrite: !1,
                  toneMapped: !1,
                  transparent: !0,
                })
              ),
              (this.type = "SkeletonHelper"),
              (this.isSkeletonHelper = !0),
              (this.root = t),
              (this.bones = e),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1);
          }
          updateMatrixWorld(t) {
            const e = this.bones,
              n = this.geometry,
              r = n.getAttribute("position");
            dg.copy(this.root.matrixWorld).invert();
            for (let i = 0, s = 0; i < e.length; i++) {
              const t = e[i];
              t.parent &&
                t.parent.isBone &&
                (pg.multiplyMatrices(dg, t.matrixWorld),
                  ug.setFromMatrixPosition(pg),
                  r.setXYZ(s, ug.x, ug.y, ug.z),
                  pg.multiplyMatrices(dg, t.parent.matrixWorld),
                  ug.setFromMatrixPosition(pg),
                  r.setXYZ(s + 1, ug.x, ug.y, ug.z),
                  (s += 2));
            }
            (n.getAttribute("position").needsUpdate = !0),
              super.updateMatrixWorld(t);
          }
        }
        function fg(t) {
          const e = [];
          t && t.isBone && e.push(t);
          for (let n = 0; n < t.children.length; n++)
            e.push.apply(e, fg(t.children[n]));
          return e;
        }
        exports.SkeletonHelper = mg;
        class gg extends Ds {
          constructor(t, e, n) {
            super(
              new od(e, 4, 2),
              new Wi({ wireframe: !0, fog: !1, toneMapped: !1 })
            ),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.color = n),
              (this.type = "PointLightHelper"),
              (this.matrix = this.light.matrixWorld),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
          update() {
            void 0 !== this.color
              ? this.material.color.set(this.color)
              : this.material.color.copy(this.light.color);
          }
        }
        exports.PointLightHelper = gg;
        const xg = new xr(),
          vg = new Vi(),
          yg = new Vi();
        class _g extends yi {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n);
            const r = new ed(e);
            r.rotateY(0.5 * Math.PI),
              (this.material = new Wi({
                wireframe: !0,
                fog: !1,
                toneMapped: !1,
              })),
              void 0 === this.color && (this.material.vertexColors = !0);
            const i = r.getAttribute("position"),
              s = new Float32Array(3 * i.count);
            r.setAttribute("color", new Xi(s, 3)),
              this.add(new Ds(r, this.material)),
              this.update();
          }
          dispose() {
            this.children[0].geometry.dispose(),
              this.children[0].material.dispose();
          }
          update() {
            const t = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color);
            else {
              const e = t.geometry.getAttribute("color");
              vg.copy(this.light.color), yg.copy(this.light.groundColor);
              for (let t = 0, n = e.count; t < n; t++) {
                const r = t < n / 2 ? vg : yg;
                e.setXYZ(t, r.r, r.g, r.b);
              }
              e.needsUpdate = !0;
            }
            t.lookAt(xg.setFromMatrixPosition(this.light.matrixWorld).negate());
          }
        }
        exports.HemisphereLightHelper = _g;
        class Mg extends qu {
          constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
            (n = new Vi(n)), (r = new Vi(r));
            const i = e / 2,
              s = t / e,
              o = t / 2,
              a = [],
              l = [];
            for (let h = 0, u = 0, p = -o; h <= e; h++, p += s) {
              a.push(-o, 0, p, o, 0, p), a.push(p, 0, -o, p, 0, o);
              const t = h === i ? n : r;
              t.toArray(l, u),
                (u += 3),
                t.toArray(l, u),
                (u += 3),
                t.toArray(l, u),
                (u += 3),
                t.toArray(l, u),
                (u += 3);
            }
            const c = new ms();
            c.setAttribute("position", new ns(a, 3)),
              c.setAttribute("color", new ns(l, 3)),
              super(c, new Gu({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "GridHelper");
          }
        }
        exports.GridHelper = Mg;
        class wg extends qu {
          constructor(t = 10, e = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
            (i = new Vi(i)), (s = new Vi(s));
            const o = [],
              a = [];
            for (let c = 0; c <= e; c++) {
              const n = (c / e) * (2 * Math.PI),
                r = Math.sin(n) * t,
                l = Math.cos(n) * t;
              o.push(0, 0, 0), o.push(r, 0, l);
              const h = 1 & c ? i : s;
              a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b);
            }
            for (let c = 0; c <= n; c++) {
              const e = 1 & c ? i : s,
                l = t - (t / n) * c;
              for (let t = 0; t < r; t++) {
                let n = (t / r) * (2 * Math.PI),
                  i = Math.sin(n) * l,
                  s = Math.cos(n) * l;
                o.push(i, 0, s),
                  a.push(e.r, e.g, e.b),
                  (n = ((t + 1) / r) * (2 * Math.PI)),
                  (i = Math.sin(n) * l),
                  (s = Math.cos(n) * l),
                  o.push(i, 0, s),
                  a.push(e.r, e.g, e.b);
              }
            }
            const l = new ms();
            l.setAttribute("position", new ns(o, 3)),
              l.setAttribute("color", new ns(a, 3)),
              super(l, new Gu({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "PolarGridHelper");
          }
        }
        exports.PolarGridHelper = wg;
        const bg = new xr(),
          Sg = new xr(),
          Tg = new xr();
        class Eg extends yi {
          constructor(t, e, n) {
            super(),
              (this.light = t),
              this.light.updateMatrixWorld(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.color = n),
              void 0 === e && (e = 1);
            let r = new ms();
            r.setAttribute(
              "position",
              new ns([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
            );
            const i = new Gu({ fog: !1, toneMapped: !1 });
            (this.lightPlane = new Vu(r, i)),
              this.add(this.lightPlane),
              (r = new ms()).setAttribute(
                "position",
                new ns([0, 0, 0, 0, 0, 1], 3)
              ),
              (this.targetLine = new Vu(r, i)),
              this.add(this.targetLine),
              this.update();
          }
          dispose() {
            this.lightPlane.geometry.dispose(),
              this.lightPlane.material.dispose(),
              this.targetLine.geometry.dispose(),
              this.targetLine.material.dispose();
          }
          update() {
            bg.setFromMatrixPosition(this.light.matrixWorld),
              Sg.setFromMatrixPosition(this.light.target.matrixWorld),
              Tg.subVectors(Sg, bg),
              this.lightPlane.lookAt(Sg),
              void 0 !== this.color
                ? (this.lightPlane.material.color.set(this.color),
                  this.targetLine.material.color.set(this.color))
                : (this.lightPlane.material.color.copy(this.light.color),
                  this.targetLine.material.color.copy(this.light.color)),
              this.targetLine.lookAt(Sg),
              (this.targetLine.scale.z = Tg.length());
          }
        }
        exports.DirectionalLightHelper = Eg;
        const Ag = new xr(),
          Lg = new ks();
        class Rg extends qu {
          constructor(t) {
            const e = new ms(),
              n = new Gu({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
              r = [],
              i = [],
              s = {},
              o = new Vi(16755200),
              a = new Vi(16711680),
              l = new Vi(43775),
              c = new Vi(16777215),
              h = new Vi(3355443);
            function u(t, e, n) {
              p(t, n), p(e, n);
            }
            function p(t, e) {
              r.push(0, 0, 0),
                i.push(e.r, e.g, e.b),
                void 0 === s[t] && (s[t] = []),
                s[t].push(r.length / 3 - 1);
            }
            u("n1", "n2", o),
              u("n2", "n4", o),
              u("n4", "n3", o),
              u("n3", "n1", o),
              u("f1", "f2", o),
              u("f2", "f4", o),
              u("f4", "f3", o),
              u("f3", "f1", o),
              u("n1", "f1", o),
              u("n2", "f2", o),
              u("n3", "f3", o),
              u("n4", "f4", o),
              u("p", "n1", a),
              u("p", "n2", a),
              u("p", "n3", a),
              u("p", "n4", a),
              u("u1", "u2", l),
              u("u2", "u3", l),
              u("u3", "u1", l),
              u("c", "t", c),
              u("p", "c", h),
              u("cn1", "cn2", h),
              u("cn3", "cn4", h),
              u("cf1", "cf2", h),
              u("cf3", "cf4", h),
              e.setAttribute("position", new ns(r, 3)),
              e.setAttribute("color", new ns(i, 3)),
              super(e, n),
              (this.type = "CameraHelper"),
              (this.camera = t),
              this.camera.updateProjectionMatrix &&
              this.camera.updateProjectionMatrix(),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1),
              (this.pointMap = s),
              this.update();
          }
          update() {
            const t = this.geometry,
              e = this.pointMap;
            Lg.projectionMatrixInverse.copy(
              this.camera.projectionMatrixInverse
            ),
              Cg("c", e, t, Lg, 0, 0, -1),
              Cg("t", e, t, Lg, 0, 0, 1),
              Cg("n1", e, t, Lg, -1, -1, -1),
              Cg("n2", e, t, Lg, 1, -1, -1),
              Cg("n3", e, t, Lg, -1, 1, -1),
              Cg("n4", e, t, Lg, 1, 1, -1),
              Cg("f1", e, t, Lg, -1, -1, 1),
              Cg("f2", e, t, Lg, 1, -1, 1),
              Cg("f3", e, t, Lg, -1, 1, 1),
              Cg("f4", e, t, Lg, 1, 1, 1),
              Cg("u1", e, t, Lg, 0.7, 1.1, -1),
              Cg("u2", e, t, Lg, -0.7, 1.1, -1),
              Cg("u3", e, t, Lg, 0, 2, -1),
              Cg("cf1", e, t, Lg, -1, 0, 1),
              Cg("cf2", e, t, Lg, 1, 0, 1),
              Cg("cf3", e, t, Lg, 0, -1, 1),
              Cg("cf4", e, t, Lg, 0, 1, 1),
              Cg("cn1", e, t, Lg, -1, 0, -1),
              Cg("cn2", e, t, Lg, 1, 0, -1),
              Cg("cn3", e, t, Lg, 0, -1, -1),
              Cg("cn4", e, t, Lg, 0, 1, -1),
              (t.getAttribute("position").needsUpdate = !0);
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }
        function Cg(t, e, n, r, i, s, o) {
          Ag.set(i, s, o).unproject(r);
          const a = e[t];
          if (void 0 !== a) {
            const t = n.getAttribute("position");
            for (let e = 0, n = a.length; e < n; e++)
              t.setXYZ(a[e], Ag.x, Ag.y, Ag.z);
          }
        }
        exports.CameraHelper = Rg;
        const Pg = new _r();
        class Dg extends qu {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
              6, 3, 7,
            ]),
              r = new Float32Array(24),
              i = new ms();
            i.setIndex(new Xi(n, 1)),
              i.setAttribute("position", new Xi(r, 3)),
              super(i, new Gu({ color: e, toneMapped: !1 })),
              (this.object = t),
              (this.type = "BoxHelper"),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          update(t) {
            if (
              (void 0 !== t &&
                console.warn(
                  "THREE.BoxHelper: .update() has no longer arguments."
                ),
                void 0 !== this.object && Pg.setFromObject(this.object),
                Pg.isEmpty())
            )
              return;
            const e = Pg.min,
              n = Pg.max,
              r = this.geometry.attributes.position,
              i = r.array;
            (i[0] = n.x),
              (i[1] = n.y),
              (i[2] = n.z),
              (i[3] = e.x),
              (i[4] = n.y),
              (i[5] = n.z),
              (i[6] = e.x),
              (i[7] = e.y),
              (i[8] = n.z),
              (i[9] = n.x),
              (i[10] = e.y),
              (i[11] = n.z),
              (i[12] = n.x),
              (i[13] = n.y),
              (i[14] = e.z),
              (i[15] = e.x),
              (i[16] = n.y),
              (i[17] = e.z),
              (i[18] = e.x),
              (i[19] = e.y),
              (i[20] = e.z),
              (i[21] = n.x),
              (i[22] = e.y),
              (i[23] = e.z),
              (r.needsUpdate = !0),
              this.geometry.computeBoundingSphere();
          }
          setFromObject(t) {
            return (this.object = t), this.update(), this;
          }
          copy(t) {
            return (
              qu.prototype.copy.call(this, t), (this.object = t.object), this
            );
          }
        }
        exports.BoxHelper = Dg;
        class Ig extends qu {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([
              0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
              6, 3, 7,
            ]),
              r = new ms();
            r.setIndex(new Xi(n, 1)),
              r.setAttribute(
                "position",
                new ns(
                  [
                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1,
                    -1, -1, -1, 1, -1, -1,
                  ],
                  3
                )
              ),
              super(r, new Gu({ color: e, toneMapped: !1 })),
              (this.box = t),
              (this.type = "Box3Helper"),
              this.geometry.computeBoundingSphere();
          }
          updateMatrixWorld(t) {
            const e = this.box;
            e.isEmpty() ||
              (e.getCenter(this.position),
                e.getSize(this.scale),
                this.scale.multiplyScalar(0.5),
                super.updateMatrixWorld(t));
          }
        }
        exports.Box3Helper = Ig;
        class Bg extends Vu {
          constructor(t, e = 1, n = 16776960) {
            const r = n,
              i = new ms();
            i.setAttribute(
              "position",
              new ns(
                [
                  1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                  1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                ],
                3
              )
            ),
              i.computeBoundingSphere(),
              super(i, new Gu({ color: r, toneMapped: !1 })),
              (this.type = "PlaneHelper"),
              (this.plane = t),
              (this.size = e);
            const s = new ms();
            s.setAttribute(
              "position",
              new ns(
                [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                3
              )
            ),
              s.computeBoundingSphere(),
              this.add(
                new Ds(
                  s,
                  new Wi({
                    color: r,
                    opacity: 0.2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1,
                  })
                )
              );
          }
          updateMatrixWorld(t) {
            let e = -this.plane.constant;
            Math.abs(e) < 1e-8 && (e = 1e-8),
              this.scale.set(0.5 * this.size, 0.5 * this.size, e),
              (this.children[0].material.side = e < 0 ? p : u),
              this.lookAt(this.plane.normal),
              super.updateMatrixWorld(t);
          }
        }
        exports.PlaneHelper = Bg;
        const Fg = new xr();
        let Ng, Gg;
        class zg extends yi {
          constructor(
            t = new xr(0, 0, 1),
            e = new xr(0, 0, 0),
            n = 1,
            r = 16776960,
            i = 0.2 * n,
            s = 0.2 * i
          ) {
            super(),
              (this.type = "ArrowHelper"),
              void 0 === Ng &&
              ((Ng = new ms()).setAttribute(
                "position",
                new ns([0, 0, 0, 0, 1, 0], 3)
              ),
                (Gg = new op(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
              this.position.copy(e),
              (this.line = new Vu(Ng, new Gu({ color: r, toneMapped: !1 }))),
              (this.line.matrixAutoUpdate = !1),
              this.add(this.line),
              (this.cone = new Ds(Gg, new Wi({ color: r, toneMapped: !1 }))),
              (this.cone.matrixAutoUpdate = !1),
              this.add(this.cone),
              this.setDirection(t),
              this.setLength(n, i, s);
          }
          setDirection(t) {
            if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
            else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
            else {
              Fg.set(t.z, 0, -t.x).normalize();
              const e = Math.acos(t.y);
              this.quaternion.setFromAxisAngle(Fg, e);
            }
          }
          setLength(t, e = 0.2 * t, n = 0.2 * e) {
            this.line.scale.set(1, Math.max(1e-4, t - e), 1),
              this.line.updateMatrix(),
              this.cone.scale.set(n, e, n),
              (this.cone.position.y = t),
              this.cone.updateMatrix();
          }
          setColor(t) {
            this.line.material.color.set(t), this.cone.material.color.set(t);
          }
          copy(t) {
            return (
              super.copy(t, !1),
              this.line.copy(t.line),
              this.cone.copy(t.cone),
              this
            );
          }
        }
        exports.ArrowHelper = zg;
        class Og extends qu {
          constructor(t = 1) {
            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              n = new ms();
            n.setAttribute("position", new ns(e, 3)),
              n.setAttribute(
                "color",
                new ns(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3
                )
              ),
              super(n, new Gu({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "AxesHelper");
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }
        exports.AxesHelper = Og;
        const Hg = new Float32Array(1),
          Ug = new Int32Array(Hg.buffer);
        class kg {
          static toHalfFloat(t) {
            Hg[0] = t;
            const e = Ug[0];
            let n = (e >> 16) & 32768,
              r = (e >> 12) & 2047;
            const i = (e >> 23) & 255;
            return i < 103
              ? n
              : i > 142
                ? ((n |= 31744), (n |= (255 == i ? 0 : 1) && 8388607 & e))
                : i < 113
                  ? (n |= ((r |= 2048) >> (114 - i)) + ((r >> (113 - i)) & 1))
                  : ((n |= ((i - 112) << 10) | (r >> 1)), (n += 1 & r));
          }
        }
        exports.DataUtils = kg;
        const Vg = 4,
          Wg = 8,
          jg = Math.pow(2, Wg),
          qg = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          Xg = Wg - Vg + 1 + qg.length,
          Yg = 20,
          Zg = {
            [Xe]: 0,
            [Ye]: 1,
            [Je]: 2,
            [Ke]: 3,
            [$e]: 4,
            [tn]: 5,
            [Ze]: 6,
          },
          Jg = new Wi({ side: p, depthWrite: !1, depthTest: !1 }),
          Qg = new Ds(new Fs(), Jg),
          Kg = new km(),
          { _lodPlanes: $g, _sizeLods: tx, _sigmas: ex } = hx(),
          nx = new Vi();
        let rx = null;
        const ix = (1 + Math.sqrt(5)) / 2,
          sx = 1 / ix,
          ox = [
            new xr(1, 1, 1),
            new xr(-1, 1, 1),
            new xr(1, 1, -1),
            new xr(-1, 1, -1),
            new xr(0, ix, sx),
            new xr(0, ix, -sx),
            new xr(sx, 0, ix),
            new xr(-sx, 0, ix),
            new xr(ix, sx, 0),
            new xr(-ix, sx, 0),
          ];
        function ax(t) {
          const e = Math.max(t.r, t.g, t.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
          return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255;
        }
        class lx {
          constructor(t) {
            (this._renderer = t),
              (this._pingPongRenderTarget = null),
              (this._blurMaterial = dx(Yg)),
              (this._equirectShader = null),
              (this._cubemapShader = null),
              this._compileMaterial(this._blurMaterial);
          }
          fromScene(t, e = 0, n = 0.1, r = 100) {
            rx = this._renderer.getRenderTarget();
            const i = this._allocateTargets();
            return (
              this._sceneToCubeUV(t, n, r, i),
              e > 0 && this._blur(i, 0, 0, e),
              this._applyPMREM(i),
              this._cleanup(i),
              i
            );
          }
          fromEquirectangular(t) {
            return this._fromTexture(t);
          }
          fromCubemap(t) {
            return this._fromTexture(t);
          }
          compileCubemapShader() {
            null === this._cubemapShader &&
              ((this._cubemapShader = fx()),
                this._compileMaterial(this._cubemapShader));
          }
          compileEquirectangularShader() {
            null === this._equirectShader &&
              ((this._equirectShader = mx()),
                this._compileMaterial(this._equirectShader));
          }
          dispose() {
            this._blurMaterial.dispose(),
              null !== this._cubemapShader && this._cubemapShader.dispose(),
              null !== this._equirectShader && this._equirectShader.dispose();
            for (let t = 0; t < $g.length; t++) $g[t].dispose();
          }
          _cleanup(t) {
            this._pingPongRenderTarget.dispose(),
              this._renderer.setRenderTarget(rx),
              (t.scissorTest = !1),
              px(t, 0, 0, t.width, t.height);
          }
          _fromTexture(t) {
            rx = this._renderer.getRenderTarget();
            const e = this._allocateTargets(t);
            return (
              this._textureToCubeUV(t, e),
              this._applyPMREM(e),
              this._cleanup(e),
              e
            );
          }
          _allocateTargets(t) {
            const e = {
              magFilter: ut,
              minFilter: ut,
              generateMipmaps: !1,
              type: Mt,
              format: zt,
              encoding: cx(t) ? t.encoding : Je,
              depthBuffer: !1,
            },
              n = ux(e);
            return (
              (n.depthBuffer = !t), (this._pingPongRenderTarget = ux(e)), n
            );
          }
          _compileMaterial(t) {
            const e = new Ds($g[0], t);
            this._renderer.compile(e, Kg);
          }
          _sceneToCubeUV(t, e, n, r) {
            const i = new Vs(90, 1, e, n),
              s = [1, -1, 1, 1, 1, 1],
              o = [1, 1, 1, -1, -1, -1],
              a = this._renderer,
              l = a.autoClear,
              c = a.outputEncoding,
              h = a.toneMapping;
            a.getClearColor(nx),
              (a.toneMapping = Z),
              (a.outputEncoding = Xe),
              (a.autoClear = !1);
            let u = !1;
            const p = t.background;
            if (p) {
              if (p.isColor) {
                Jg.color.copy(p).convertSRGBToLinear(), (t.background = null);
                const e = ax(Jg.color);
                (Jg.opacity = e), (u = !0);
              }
            } else {
              Jg.color.copy(nx).convertSRGBToLinear();
              const t = ax(Jg.color);
              (Jg.opacity = t), (u = !0);
            }
            for (let d = 0; d < 6; d++) {
              const e = d % 3;
              0 == e
                ? (i.up.set(0, s[d], 0), i.lookAt(o[d], 0, 0))
                : 1 == e
                  ? (i.up.set(0, 0, s[d]), i.lookAt(0, o[d], 0))
                  : (i.up.set(0, s[d], 0), i.lookAt(0, 0, o[d])),
                px(r, e * jg, d > 2 ? jg : 0, jg, jg),
                a.setRenderTarget(r),
                u && a.render(Qg, i),
                a.render(t, i);
            }
            (a.toneMapping = h), (a.outputEncoding = c), (a.autoClear = l);
          }
          _textureToCubeUV(t, e) {
            const n = this._renderer;
            t.isCubeTexture
              ? null == this._cubemapShader && (this._cubemapShader = fx())
              : null == this._equirectShader && (this._equirectShader = mx());
            const r = t.isCubeTexture
              ? this._cubemapShader
              : this._equirectShader,
              i = new Ds($g[0], r),
              s = r.uniforms;
            (s.envMap.value = t),
              t.isCubeTexture ||
              s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
              (s.inputEncoding.value = Zg[t.encoding]),
              (s.outputEncoding.value = Zg[e.texture.encoding]),
              px(e, 0, 0, 3 * jg, 2 * jg),
              n.setRenderTarget(e),
              n.render(i, Kg);
          }
          _applyPMREM(t) {
            const e = this._renderer,
              n = e.autoClear;
            e.autoClear = !1;
            for (let r = 1; r < Xg; r++) {
              const e = Math.sqrt(ex[r] * ex[r] - ex[r - 1] * ex[r - 1]),
                n = ox[(r - 1) % ox.length];
              this._blur(t, r - 1, r, e, n);
            }
            e.autoClear = n;
          }
          _blur(t, e, n, r, i) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, r, "latitudinal", i),
              this._halfBlur(s, t, n, n, r, "longitudinal", i);
          }
          _halfBlur(t, e, n, r, i, s, o) {
            const a = this._renderer,
              l = this._blurMaterial;
            "latitudinal" !== s &&
              "longitudinal" !== s &&
              console.error(
                "blur direction must be either latitudinal or longitudinal!"
              );
            const c = new Ds($g[r], l),
              h = l.uniforms,
              u = tx[n] - 1,
              p = isFinite(i)
                ? Math.PI / (2 * u)
                : (2 * Math.PI) / (2 * Yg - 1),
              d = i / p,
              m = isFinite(i) ? 1 + Math.floor(3 * d) : Yg;
            m > Yg &&
              console.warn(
                `sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Yg}`
              );
            const f = [];
            let g = 0;
            for (let v = 0; v < Yg; ++v) {
              const t = v / d,
                e = Math.exp((-t * t) / 2);
              f.push(e), 0 == v ? (g += e) : v < m && (g += 2 * e);
            }
            for (let v = 0; v < f.length; v++) f[v] = f[v] / g;
            (h.envMap.value = t.texture),
              (h.samples.value = m),
              (h.weights.value = f),
              (h.latitudinal.value = "latitudinal" === s),
              o && (h.poleAxis.value = o),
              (h.dTheta.value = p),
              (h.mipInt.value = Wg - n),
              (h.inputEncoding.value = Zg[t.texture.encoding]),
              (h.outputEncoding.value = Zg[t.texture.encoding]);
            const x = tx[r];
            px(
              e,
              3 * Math.max(0, jg - 2 * x),
              (0 === r ? 0 : 2 * jg) + 2 * x * (r > Wg - Vg ? r - Wg + Vg : 0),
              3 * x,
              2 * x
            ),
              a.setRenderTarget(e),
              a.render(c, Kg);
          }
        }
        function cx(t) {
          return (
            void 0 !== t &&
            t.type === Mt &&
            (t.encoding === Xe || t.encoding === Ye || t.encoding === Ze)
          );
        }
        function hx() {
          const t = [],
            e = [],
            n = [];
          let r = Wg;
          for (let i = 0; i < Xg; i++) {
            const s = Math.pow(2, r);
            e.push(s);
            let o = 1 / s;
            i > Wg - Vg ? (o = qg[i - Wg + Vg - 1]) : 0 == i && (o = 0),
              n.push(o);
            const a = 1 / (s - 1),
              l = -a / 2,
              c = 1 + a / 2,
              h = [l, l, c, l, c, c, l, l, c, c, l, c],
              u = 6,
              p = 6,
              d = 3,
              m = 2,
              f = 1,
              g = new Float32Array(d * p * u),
              x = new Float32Array(m * p * u),
              v = new Float32Array(f * p * u);
            for (let t = 0; t < u; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                r = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              g.set(r, d * p * t), x.set(h, m * p * t);
              const i = [t, t, t, t, t, t];
              v.set(i, f * p * t);
            }
            const y = new ms();
            y.setAttribute("position", new Xi(g, d)),
              y.setAttribute("uv", new Xi(x, m)),
              y.setAttribute("faceIndex", new Xi(v, f)),
              t.push(y),
              r > Vg && r--;
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
        }
        function ux(t) {
          const e = new dr(3 * jg, 3 * jg, t);
          return (
            (e.texture.mapping = ot),
            (e.texture.name = "PMREM.cubeUv"),
            (e.scissorTest = !0),
            e
          );
        }
        function px(t, e, n, r, i) {
          t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
        }
        function dx(t) {
          const e = new Float32Array(t),
            n = new xr(0, 1, 0);
          return new fd({
            name: "SphericalGaussianBlur",
            defines: { n: t },
            uniforms: {
              envMap: { value: null },
              samples: { value: 1 },
              weights: { value: e },
              latitudinal: { value: !1 },
              dTheta: { value: 0 },
              mipInt: { value: 0 },
              poleAxis: { value: n },
              inputEncoding: { value: Zg[Xe] },
              outputEncoding: { value: Zg[Xe] },
            },
            vertexShader: gx(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${xx()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: g,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function mx() {
          const t = new sr(1, 1);
          return new fd({
            name: "EquirectangularToCubeUV",
            uniforms: {
              envMap: { value: null },
              texelSize: { value: t },
              inputEncoding: { value: Zg[Xe] },
              outputEncoding: { value: Zg[Xe] },
            },
            vertexShader: gx(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${xx()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: g,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function fx() {
          return new fd({
            name: "CubemapToCubeUV",
            uniforms: {
              envMap: { value: null },
              inputEncoding: { value: Zg[Xe] },
              outputEncoding: { value: Zg[Xe] },
            },
            vertexShader: gx(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${xx()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: g,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function gx() {
          return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
        }
        function xx() {
          return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
        }
        exports.PMREMGenerator = lx;
        const vx = 0;
        exports.LineStrip = 0;
        const yx = 1;
        exports.LinePieces = 1;
        const _x = 0;
        exports.NoColors = 0;
        const Mx = 1;
        exports.FaceColors = 1;
        const wx = 2;
        function bx(t) {
          return (
            console.warn(
              "THREE.MeshFaceMaterial has been removed. Use an Array instead."
            ),
            t
          );
        }
        function Sx(t = []) {
          return (
            console.warn(
              "THREE.MultiMaterial has been removed. Use an Array instead."
            ),
            (t.isMultiMaterial = !0),
            (t.materials = t),
            (t.clone = function () {
              return t.slice();
            }),
            t
          );
        }
        function Tx(t, e) {
          return (
            console.warn("THREE.PointCloud has been renamed to THREE.Points."),
            new $u(t, e)
          );
        }
        function Ex(t) {
          return (
            console.warn("THREE.Particle has been renamed to THREE.Sprite."),
            new gu(t)
          );
        }
        function Ax(t, e) {
          return (
            console.warn(
              "THREE.ParticleSystem has been renamed to THREE.Points."
            ),
            new $u(t, e)
          );
        }
        function Lx(t) {
          return (
            console.warn(
              "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
            ),
            new Yu(t)
          );
        }
        function Rx(t) {
          return (
            console.warn(
              "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
            ),
            new Yu(t)
          );
        }
        function Cx(t) {
          return (
            console.warn(
              "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
            ),
            new Yu(t)
          );
        }
        function Px(t, e, n) {
          return (
            console.warn(
              "THREE.Vertex has been removed. Use THREE.Vector3 instead."
            ),
            new xr(t, e, n)
          );
        }
        function Dx(t, e) {
          return (
            console.warn(
              "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
            ),
            new Xi(t, e).setUsage(bn)
          );
        }
        function Ix(t, e) {
          return (
            console.warn(
              "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
            ),
            new Yi(t, e)
          );
        }
        function Bx(t, e) {
          return (
            console.warn(
              "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
            ),
            new Zi(t, e)
          );
        }
        function Fx(t, e) {
          return (
            console.warn(
              "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
            ),
            new Ji(t, e)
          );
        }
        function Nx(t, e) {
          return (
            console.warn(
              "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
            ),
            new Qi(t, e)
          );
        }
        function Gx(t, e) {
          return (
            console.warn(
              "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
            ),
            new Ki(t, e)
          );
        }
        function zx(t, e) {
          return (
            console.warn(
              "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
            ),
            new $i(t, e)
          );
        }
        function Ox(t, e) {
          return (
            console.warn(
              "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
            ),
            new ts(t, e)
          );
        }
        function Hx(t, e) {
          return (
            console.warn(
              "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
            ),
            new ns(t, e)
          );
        }
        function Ux(t, e) {
          return (
            console.warn(
              "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
            ),
            new rs(t, e)
          );
        }
        function kx(t) {
          return (
            console.warn(
              "THREE.AxisHelper has been renamed to THREE.AxesHelper."
            ),
            new Og(t)
          );
        }
        function Vx(t, e) {
          return (
            console.warn(
              "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
            ),
            new Dg(t, e)
          );
        }
        function Wx(t, e) {
          return (
            console.warn(
              "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
            ),
            new qu(
              new mp(t.geometry),
              new Gu({ color: void 0 !== e ? e : 16777215 })
            )
          );
        }
        function jx(t, e) {
          return (
            console.warn(
              "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
            ),
            new qu(
              new pd(t.geometry),
              new Gu({ color: void 0 !== e ? e : 16777215 })
            )
          );
        }
        function qx(t) {
          return (
            console.warn(
              "THREE.XHRLoader has been renamed to THREE.FileLoader."
            ),
            new qd(t)
          );
        }
        function Xx(t) {
          return (
            console.warn(
              "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
            ),
            new Qd(t)
          );
        }
        function Yx(t, e, n) {
          return (
            console.warn(
              "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
            ),
            new Ys(t, n)
          );
        }
        function Zx() {
          console.error("THREE.CanvasRenderer has been removed");
        }
        function Jx() {
          console.error("THREE.JSONLoader has been removed.");
        }
        (exports.VertexColors = 2),
          ($d.create = function (t, e) {
            return (
              console.log("THREE.Curve.create() has been deprecated"),
              (t.prototype = Object.create($d.prototype)),
              (t.prototype.constructor = t),
              (t.prototype.getPoint = e),
              t
            );
          }),
          (Am.prototype.fromPoints = function (t) {
            return (
              console.warn(
                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
              ),
              this.setFromPoints(t)
            );
          }),
          (Mg.prototype.setColors = function () {
            console.error(
              "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
            );
          }),
          (mg.prototype.update = function () {
            console.error(
              "THREE.SkeletonHelper: update() no longer needs to be called."
            );
          }),
          (Wd.prototype.extractUrlBase = function (t) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              Jm.extractUrlBase(t)
            );
          }),
          (Wd.Handlers = {
            add: function () {
              console.error(
                "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
              );
            },
            get: function () {
              console.error(
                "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
              );
            },
          }),
          (ig.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box2: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (ig.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box2: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (ig.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (ig.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box2: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (_r.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (_r.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (_r.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (_r.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (_r.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (Or.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (Qs.prototype.setFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
              ),
              this.setFromProjectionMatrix(t)
            );
          }),
          (ag.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Line3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (or.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (or.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (or.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          }),
          (or.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (or.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          }),
          (or.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (Yr.prototype.extractPosition = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(t)
            );
          }),
          (Yr.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (Yr.prototype.getPosition = function () {
            return (
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              new xr().setFromMatrixColumn(this, 3)
            );
          }),
          (Yr.prototype.setRotationFromQuaternion = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(t)
            );
          }),
          (Yr.prototype.multiplyToArray = function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          }),
          (Yr.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Yr.prototype.multiplyVector4 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Yr.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          }),
          (Yr.prototype.rotateAxis = function (t) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              t.transformDirection(this);
          }),
          (Yr.prototype.crossVector = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Yr.prototype.translate = function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          }),
          (Yr.prototype.rotateX = function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          }),
          (Yr.prototype.rotateY = function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          }),
          (Yr.prototype.rotateZ = function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          }),
          (Yr.prototype.rotateByAxis = function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          }),
          (Yr.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (Yr.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          }),
          (Yr.prototype.makeFrustum = function (t, e, n, r, i, s) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(t, e, r, n, i, s)
            );
          }),
          (Yr.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (bi.prototype.isIntersectionLine = function (t) {
            return (
              console.warn(
                "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
              ),
              this.intersectsLine(t)
            );
          }),
          (gr.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
              ),
              t.applyQuaternion(this)
            );
          }),
          (gr.prototype.inverse = function () {
            return (
              console.warn(
                "THREE.Quaternion: .inverse() has been renamed to invert()."
              ),
              this.invert()
            );
          }),
          (Xr.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (Xr.prototype.isIntersectionPlane = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(t)
            );
          }),
          (Xr.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (Bi.prototype.area = function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          }),
          (Bi.prototype.barycoordFromPoint = function (t, e) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(t, e)
            );
          }),
          (Bi.prototype.midpoint = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(t)
            );
          }),
          (Bi.prototypenormal = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(t)
            );
          }),
          (Bi.prototype.plane = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(t)
            );
          }),
          (Bi.barycoordFromPoint = function (t, e, n, r, i) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              Bi.getBarycoord(t, e, n, r, i)
            );
          }),
          (Bi.normal = function (t, e, n, r) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              Bi.getNormal(t, e, n, r)
            );
          }),
          (Lm.prototype.extractAllPoints = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(t)
            );
          }),
          (Lm.prototype.extrude = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new Jp(this, t)
            );
          }),
          (Lm.prototype.makeGeometry = function (t) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new id(this, t)
            );
          }),
          (sr.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (sr.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (sr.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (xr.prototype.setEulerFromRotationMatrix = function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          }),
          (xr.prototype.setEulerFromQuaternion = function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          }),
          (xr.prototype.getPositionFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(t)
            );
          }),
          (xr.prototype.getScaleFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(t)
            );
          }),
          (xr.prototype.getColumnFromMatrix = function (t, e) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(e, t)
            );
          }),
          (xr.prototype.applyProjection = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(t)
            );
          }),
          (xr.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (xr.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (xr.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (pr.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (pr.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (yi.prototype.getChildByName = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(t)
            );
          }),
          (yi.prototype.renderDepth = function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          }),
          (yi.prototype.translate = function (t, e) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(e, t)
            );
          }),
          (yi.prototype.getWorldRotation = function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          }),
          (yi.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(yi.prototype, {
            eulerOrder: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Object3D: .eulerOrder is now .rotation.order."
                  ),
                  this.rotation.order
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                  (this.rotation.order = t);
              },
            },
            useQuaternion: {
              get: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
              set: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
            },
          }),
          (Ds.prototype.setDrawMode = function () {
            console.error(
              "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          }),
          Object.defineProperties(Ds.prototype, {
            drawMode: {
              get: function () {
                return (
                  console.error(
                    "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                  ),
                  0
                );
              },
              set: function () {
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
                );
              },
            },
          }),
          (Eu.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.");
          }),
          (Vs.prototype.setLens = function (t, e) {
            console.warn(
              "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
            ),
              void 0 !== e && (this.filmGauge = e),
              this.setFocalLength(t);
          }),
          Object.defineProperties(Rm.prototype, {
            onlyShadow: {
              set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.");
              },
            },
            shadowCameraFov: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
                ),
                  (this.shadow.camera.fov = t);
              },
            },
            shadowCameraLeft: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
                ),
                  (this.shadow.camera.left = t);
              },
            },
            shadowCameraRight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
                ),
                  (this.shadow.camera.right = t);
              },
            },
            shadowCameraTop: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
                ),
                  (this.shadow.camera.top = t);
              },
            },
            shadowCameraBottom: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
                ),
                  (this.shadow.camera.bottom = t);
              },
            },
            shadowCameraNear: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
                ),
                  (this.shadow.camera.near = t);
              },
            },
            shadowCameraFar: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
                ),
                  (this.shadow.camera.far = t);
              },
            },
            shadowCameraVisible: {
              set: function () {
                console.warn(
                  "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
                );
              },
            },
            shadowBias: {
              set: function (t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                  (this.shadow.bias = t);
              },
            },
            shadowDarkness: {
              set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
              },
            },
            shadowMapWidth: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
                ),
                  (this.shadow.mapSize.width = t);
              },
            },
            shadowMapHeight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
                ),
                  (this.shadow.mapSize.height = t);
              },
            },
          }),
          Object.defineProperties(Xi.prototype, {
            length: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                  ),
                  this.array.length
                );
              },
            },
            dynamic: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                  ),
                  this.usage === bn
                );
              },
              set: function () {
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                  this.setUsage(bn);
              },
            },
          }),
          (Xi.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? bn : wn),
              this
            );
          }),
          (Xi.prototype.copyIndicesArray = function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          }),
          (Xi.prototype.setArray = function () {
            console.error(
              "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (ms.prototype.addIndex = function (t) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(t);
          }),
          (ms.prototype.addAttribute = function (t, e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
              ),
              (e && e.isBufferAttribute) ||
                (e && e.isInterleavedBufferAttribute)
                ? "index" === t
                  ? (console.warn(
                    "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                  ),
                    this.setIndex(e),
                    this)
                  : this.setAttribute(t, e)
                : (console.warn(
                  "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                ),
                  this.setAttribute(t, new Xi(arguments[1], arguments[2])))
            );
          }),
          (ms.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(t, e);
          }),
          (ms.prototype.clearDrawCalls = function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          }),
          (ms.prototype.computeOffsets = function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          }),
          (ms.prototype.removeAttribute = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
              ),
              this.deleteAttribute(t)
            );
          }),
          (ms.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(ms.prototype, {
            drawcalls: {
              get: function () {
                return (
                  console.error(
                    "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
            offsets: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferGeometry: .offsets has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
          }),
          ($h.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? bn : wn),
              this
            );
          }),
          ($h.prototype.setArray = function () {
            console.error(
              "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (Jp.prototype.getArrays = function () {
            console.error(
              "THREE.ExtrudeGeometry: .getArrays() has been removed."
            );
          }),
          (Jp.prototype.addShapeList = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShapeList() has been removed."
            );
          }),
          (Jp.prototype.addShape = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShape() has been removed."
            );
          }),
          (Kh.prototype.dispose = function () {
            console.error("THREE.Scene: .dispose() has been removed.");
          }),
          (Zf.prototype.onUpdate = function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          }),
          Object.defineProperties(Ni.prototype, {
            wrapAround: {
              get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
            },
            overdraw: {
              get: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
            },
            wrapRGB: {
              get: function () {
                return (
                  console.warn("THREE.Material: .wrapRGB has been removed."),
                  new Vi()
                );
              },
            },
            shading: {
              get: function () {
                console.error(
                  "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = t === m);
              },
            },
            stencilMask: {
              get: function () {
                return (
                  console.warn(
                    "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                  ),
                  this.stencilFuncMask
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                  this.type +
                  ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                  (this.stencilFuncMask = t);
              },
            },
          }),
          Object.defineProperties(Us.prototype, {
            derivatives: {
              get: function () {
                return (
                  console.warn(
                    "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                  ),
                  this.extensions.derivatives
                );
              },
              set: function (t) {
                console.warn(
                  "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                  (this.extensions.derivatives = t);
              },
            },
          }),
          (Yh.prototype.clearTarget = function (t, e, n, r) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            ),
              this.setRenderTarget(t),
              this.clear(e, n, r);
          }),
          (Yh.prototype.animate = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(t);
          }),
          (Yh.prototype.getCurrentRenderTarget = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          }),
          (Yh.prototype.getMaxAnisotropy = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          }),
          (Yh.prototype.getPrecision = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          }),
          (Yh.prototype.resetGLState = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          }),
          (Yh.prototype.supportsFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          }),
          (Yh.prototype.supportsHalfFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          }),
          (Yh.prototype.supportsStandardDerivatives = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          }),
          (Yh.prototype.supportsCompressedTextureS3TC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          }),
          (Yh.prototype.supportsCompressedTexturePVRTC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          }),
          (Yh.prototype.supportsBlendMinMax = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          }),
          (Yh.prototype.supportsVertexTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          }),
          (Yh.prototype.supportsInstancedArrays = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          }),
          (Yh.prototype.enableScissorTest = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(t);
          }),
          (Yh.prototype.initMaterial = function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          }),
          (Yh.prototype.addPrePlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          }),
          (Yh.prototype.addPostPlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          }),
          (Yh.prototype.updateShadowMap = function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          }),
          (Yh.prototype.setFaceCulling = function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          }),
          (Yh.prototype.allocTextureUnit = function () {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          }),
          (Yh.prototype.setTexture = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          }),
          (Yh.prototype.setTexture2D = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          }),
          (Yh.prototype.setTextureCube = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          }),
          (Yh.prototype.getActiveMipMapLevel = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
              ),
              this.getActiveMipmapLevel()
            );
          }),
          Object.defineProperties(Yh.prototype, {
            shadowMapEnabled: {
              get: function () {
                return this.shadowMap.enabled;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
                ),
                  (this.shadowMap.enabled = t);
              },
            },
            shadowMapType: {
              get: function () {
                return this.shadowMap.type;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
                ),
                  (this.shadowMap.type = t);
              },
            },
            shadowMapCullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            context: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                  ),
                  this.getContext()
                );
              },
            },
            vr: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .vr has been renamed to .xr"
                  ),
                  this.xr
                );
              },
            },
            gammaInput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                  ),
                  !1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                );
              },
            },
            gammaOutput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                  ),
                  !1
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                  (this.outputEncoding = !0 === t ? Ye : Xe);
              },
            },
            toneMappingWhitePoint: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                  ),
                  1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                );
              },
            },
          }),
          Object.defineProperties(Gh.prototype, {
            cullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderReverseSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderSingleSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
          }),
          Object.defineProperties(dr.prototype, {
            wrapS: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                  ),
                  this.texture.wrapS
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                  (this.texture.wrapS = t);
              },
            },
            wrapT: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                  ),
                  this.texture.wrapT
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                  (this.texture.wrapT = t);
              },
            },
            magFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                  ),
                  this.texture.magFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                  (this.texture.magFilter = t);
              },
            },
            minFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                  ),
                  this.texture.minFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                  (this.texture.minFilter = t);
              },
            },
            anisotropy: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                  ),
                  this.texture.anisotropy
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                  (this.texture.anisotropy = t);
              },
            },
            offset: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                  ),
                  this.texture.offset
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                  (this.texture.offset = t);
              },
            },
            repeat: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                  ),
                  this.texture.repeat
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                  (this.texture.repeat = t);
              },
            },
            format: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .format is now .texture.format."
                  ),
                  this.texture.format
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                  (this.texture.format = t);
              },
            },
            type: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .type is now .texture.type."
                  ),
                  this.texture.type
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                  (this.texture.type = t);
              },
            },
            generateMipmaps: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                  ),
                  this.texture.generateMipmaps
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                  (this.texture.generateMipmaps = t);
              },
            },
          }),
          (Ef.prototype.load = function (t) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            const e = this;
            return (
              new df().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          }),
          (Df.prototype.getData = function () {
            return (
              console.warn(
                "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
              ),
              this.getFrequencyData()
            );
          }),
          (qs.prototype.updateCubeMap = function (t, e) {
            return (
              console.warn(
                "THREE.CubeCamera: .updateCubeMap() is now .update()."
              ),
              this.update(t, e)
            );
          }),
          (qs.prototype.clear = function (t, e, n, r) {
            return (
              console.warn(
                "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
              ),
              this.renderTarget.clear(t, e, n, r)
            );
          }),
          (lr.crossOrigin = void 0),
          (lr.loadTexture = function (t, e, n, r) {
            console.warn(
              "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
            );
            const i = new Kd();
            i.setCrossOrigin(this.crossOrigin);
            const s = i.load(t, n, void 0, r);
            return e && (s.mapping = e), s;
          }),
          (lr.loadTextureCube = function (t, e, n, r) {
            console.warn(
              "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
            );
            const i = new Jd();
            i.setCrossOrigin(this.crossOrigin);
            const s = i.load(t, n, void 0, r);
            return e && (s.mapping = e), s;
          }),
          (lr.loadCompressedTexture = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
            );
          }),
          (lr.loadCompressedTextureCube = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
            );
          });
        const Qx = {
          createMultiMaterialObject: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
          detach: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
          attach: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
        };
        function Kx() {
          console.error(
            "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
          );
        }
        (exports.SceneUtils = Qx),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: "129" } })
          ),
          "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
            : (window.__THREE__ = "129"));
      },
      {},
    ],
    CCS2: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.default = void 0);
        var e = function () {
          var t = 0,
            l = document.createElement("div");
          function n(e) {
            return l.appendChild(e.dom), e;
          }
          function a(e) {
            for (var n = 0; n < l.children.length; n++)
              l.children[n].style.display = n === e ? "block" : "none";
            t = e;
          }
          (l.style.cssText =
            "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
            l.addEventListener(
              "click",
              function (e) {
                e.preventDefault(), a(++t % l.children.length);
              },
              !1
            );
          var i = (performance || Date).now(),
            o = i,
            r = 0,
            f = n(new e.Panel("FPS", "#0ff", "#002")),
            d = n(new e.Panel("MS", "#0f0", "#020"));
          if (self.performance && self.performance.memory)
            var c = n(new e.Panel("MB", "#f08", "#201"));
          return (
            a(0),
            {
              REVISION: 16,
              dom: l,
              addPanel: n,
              showPanel: a,
              begin: function () {
                i = (performance || Date).now();
              },
              end: function () {
                r++;
                var e = (performance || Date).now();
                if (
                  (d.update(e - i, 200),
                    e >= o + 1e3 &&
                    (f.update((1e3 * r) / (e - o), 100), (o = e), (r = 0), c))
                ) {
                  var t = performance.memory;
                  c.update(
                    t.usedJSHeapSize / 1048576,
                    t.jsHeapSizeLimit / 1048576
                  );
                }
                return e;
              },
              update: function () {
                i = this.end();
              },
              domElement: l,
              setMode: a,
            }
          );
        };
        e.Panel = function (e, t, l) {
          var n = 1 / 0,
            a = 0,
            i = Math.round,
            o = i(window.devicePixelRatio || 1),
            r = 80 * o,
            f = 48 * o,
            d = 3 * o,
            c = 2 * o,
            p = 3 * o,
            s = 15 * o,
            u = 74 * o,
            m = 30 * o,
            h = document.createElement("canvas");
          (h.width = r),
            (h.height = f),
            (h.style.cssText = "width:80px;height:48px");
          var v = h.getContext("2d");
          return (
            (v.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif"),
            (v.textBaseline = "top"),
            (v.fillStyle = l),
            v.fillRect(0, 0, r, f),
            (v.fillStyle = t),
            v.fillText(e, d, c),
            v.fillRect(p, s, u, m),
            (v.fillStyle = l),
            (v.globalAlpha = 0.9),
            v.fillRect(p, s, u, m),
            {
              dom: h,
              update: function (f, x) {
                (n = Math.min(n, f)),
                  (a = Math.max(a, f)),
                  (v.fillStyle = l),
                  (v.globalAlpha = 1),
                  v.fillRect(0, 0, r, s),
                  (v.fillStyle = t),
                  v.fillText(
                    i(f) + " " + e + " (" + i(n) + "-" + i(a) + ")",
                    d,
                    c
                  ),
                  v.drawImage(h, p + o, s, u - o, m, p, s, u - o, m),
                  v.fillRect(p + u - o, s, o, m),
                  (v.fillStyle = l),
                  (v.globalAlpha = 0.9),
                  v.fillRect(p + u - o, s, o, i((1 - f / x) * m));
              },
            }
          );
        };
        var t = e;
        exports.default = t;
      },
      {},
    ],
    S3Gv: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.GLTFLoader = void 0);
        var e = require("three");
        class t extends e.Loader {
          constructor(e) {
            super(e),
              (this.dracoLoader = null),
              (this.ktx2Loader = null),
              (this.meshoptDecoder = null),
              (this.pluginCallbacks = []),
              this.register(function (e) {
                return new a(e);
              }),
              this.register(function (e) {
                return new l(e);
              }),
              this.register(function (e) {
                return new c(e);
              }),
              this.register(function (e) {
                return new i(e);
              }),
              this.register(function (e) {
                return new r(e);
              }),
              this.register(function (e) {
                return new u(e);
              });
          }
          load(t, s, n, r) {
            const o = this;
            let a;
            (a =
              "" !== this.resourcePath
                ? this.resourcePath
                : "" !== this.path
                  ? this.path
                  : e.LoaderUtils.extractUrlBase(t)),
              this.manager.itemStart(t);
            const i = function (e) {
              r ? r(e) : console.error(e),
                o.manager.itemError(t),
                o.manager.itemEnd(t);
            },
              l = new e.FileLoader(this.manager);
            l.setPath(this.path),
              l.setResponseType("arraybuffer"),
              l.setRequestHeader(this.requestHeader),
              l.setWithCredentials(this.withCredentials),
              l.load(
                t,
                function (e) {
                  try {
                    o.parse(
                      e,
                      a,
                      function (e) {
                        s(e), o.manager.itemEnd(t);
                      },
                      i
                    );
                  } catch (n) {
                    i(n);
                  }
                },
                n,
                i
              );
          }
          setDRACOLoader(e) {
            return (this.dracoLoader = e), this;
          }
          setDDSLoader() {
            throw new Error(
              'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
            );
          }
          setKTX2Loader(e) {
            return (this.ktx2Loader = e), this;
          }
          setMeshoptDecoder(e) {
            return (this.meshoptDecoder = e), this;
          }
          register(e) {
            return (
              -1 === this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.push(e),
              this
            );
          }
          unregister(e) {
            return (
              -1 !== this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
              this
            );
          }
          parse(t, s, r, a) {
            let i;
            const l = {},
              c = {};
            if ("string" == typeof t) i = t;
            else {
              if (e.LoaderUtils.decodeText(new Uint8Array(t, 0, 4)) === h) {
                try {
                  l[n.KHR_BINARY_GLTF] = new m(t);
                } catch (d) {
                  return void (a && a(d));
                }
                i = l[n.KHR_BINARY_GLTF].content;
              } else i = e.LoaderUtils.decodeText(new Uint8Array(t));
            }
            const u = JSON.parse(i);
            if (void 0 === u.asset || u.asset.version[0] < 2)
              return void (
                a &&
                a(
                  new Error(
                    "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                  )
                )
              );
            const p = new G(u, {
              path: s || this.resourcePath || "",
              crossOrigin: this.crossOrigin,
              requestHeader: this.requestHeader,
              manager: this.manager,
              ktx2Loader: this.ktx2Loader,
              meshoptDecoder: this.meshoptDecoder,
            });
            p.fileLoader.setRequestHeader(this.requestHeader);
            for (let e = 0; e < this.pluginCallbacks.length; e++) {
              const t = this.pluginCallbacks[e](p);
              (c[t.name] = t), (l[t.name] = !0);
            }
            if (u.extensionsUsed)
              for (let e = 0; e < u.extensionsUsed.length; ++e) {
                const t = u.extensionsUsed[e],
                  s = u.extensionsRequired || [];
                switch (t) {
                  case n.KHR_MATERIALS_UNLIT:
                    l[t] = new o();
                    break;
                  case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    l[t] = new x();
                    break;
                  case n.KHR_DRACO_MESH_COMPRESSION:
                    l[t] = new f(u, this.dracoLoader);
                    break;
                  case n.KHR_TEXTURE_TRANSFORM:
                    l[t] = new g();
                    break;
                  case n.KHR_MESH_QUANTIZATION:
                    l[t] = new M();
                    break;
                  default:
                    s.indexOf(t) >= 0 &&
                      void 0 === c[t] &&
                      console.warn(
                        'THREE.GLTFLoader: Unknown extension "' + t + '".'
                      );
                }
              }
            p.setExtensions(l), p.setPlugins(c), p.parse(r, a);
          }
        }
        function s() {
          let e = {};
          return {
            get: function (t) {
              return e[t];
            },
            add: function (t, s) {
              e[t] = s;
            },
            remove: function (t) {
              delete e[t];
            },
            removeAll: function () {
              e = {};
            },
          };
        }
        exports.GLTFLoader = t;
        const n = {
          KHR_BINARY_GLTF: "KHR_binary_glTF",
          KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
          KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
          KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
          KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            "KHR_materials_pbrSpecularGlossiness",
          KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
          KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
          KHR_TEXTURE_BASISU: "KHR_texture_basisu",
          KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
          KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
          EXT_TEXTURE_WEBP: "EXT_texture_webp",
          EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        };
        class r {
          constructor(e) {
            (this.parser = e),
              (this.name = n.KHR_LIGHTS_PUNCTUAL),
              (this.cache = { refs: {}, uses: {} });
          }
          _markDefs() {
            const e = this.parser,
              t = this.parser.json.nodes || [];
            for (let s = 0, n = t.length; s < n; s++) {
              const n = t[s];
              n.extensions &&
                n.extensions[this.name] &&
                void 0 !== n.extensions[this.name].light &&
                e._addNodeRef(this.cache, n.extensions[this.name].light);
            }
          }
          _loadLight(t) {
            const s = this.parser,
              n = "light:" + t;
            let r = s.cache.get(n);
            if (r) return r;
            const o = s.json,
              a = (((o.extensions && o.extensions[this.name]) || {}).lights ||
                [])[t];
            let i;
            const l = new e.Color(16777215);
            void 0 !== a.color && l.fromArray(a.color);
            const c = void 0 !== a.range ? a.range : 0;
            switch (a.type) {
              case "directional":
                (i = new e.DirectionalLight(l)).target.position.set(0, 0, -1),
                  i.add(i.target);
                break;
              case "point":
                (i = new e.PointLight(l)).distance = c;
                break;
              case "spot":
                ((i = new e.SpotLight(l)).distance = c),
                  (a.spot = a.spot || {}),
                  (a.spot.innerConeAngle =
                    void 0 !== a.spot.innerConeAngle
                      ? a.spot.innerConeAngle
                      : 0),
                  (a.spot.outerConeAngle =
                    void 0 !== a.spot.outerConeAngle
                      ? a.spot.outerConeAngle
                      : Math.PI / 4),
                  (i.angle = a.spot.outerConeAngle),
                  (i.penumbra =
                    1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
                  i.target.position.set(0, 0, -1),
                  i.add(i.target);
                break;
              default:
                throw new Error(
                  "THREE.GLTFLoader: Unexpected light type: " + a.type
                );
            }
            return (
              i.position.set(0, 0, 0),
              (i.decay = 2),
              void 0 !== a.intensity && (i.intensity = a.intensity),
              (i.name = s.createUniqueName(a.name || "light_" + t)),
              (r = Promise.resolve(i)),
              s.cache.add(n, r),
              r
            );
          }
          createNodeAttachment(e) {
            const t = this,
              s = this.parser,
              n = s.json.nodes[e],
              r = ((n.extensions && n.extensions[this.name]) || {}).light;
            return void 0 === r
              ? null
              : this._loadLight(r).then(function (e) {
                return s._getNodeRef(t.cache, r, e);
              });
          }
        }
        class o {
          constructor() {
            this.name = n.KHR_MATERIALS_UNLIT;
          }
          getMaterialType() {
            return e.MeshBasicMaterial;
          }
          extendParams(t, s, n) {
            const r = [];
            (t.color = new e.Color(1, 1, 1)), (t.opacity = 1);
            const o = s.pbrMetallicRoughness;
            if (o) {
              if (Array.isArray(o.baseColorFactor)) {
                const e = o.baseColorFactor;
                t.color.fromArray(e), (t.opacity = e[3]);
              }
              void 0 !== o.baseColorTexture &&
                r.push(n.assignTexture(t, "map", o.baseColorTexture));
            }
            return Promise.all(r);
          }
        }
        class a {
          constructor(e) {
            (this.parser = e), (this.name = n.KHR_MATERIALS_CLEARCOAT);
          }
          getMaterialType(t) {
            const s = this.parser.json.materials[t];
            return s.extensions && s.extensions[this.name]
              ? e.MeshPhysicalMaterial
              : null;
          }
          extendMaterialParams(t, s) {
            const n = this.parser,
              r = n.json.materials[t];
            if (!r.extensions || !r.extensions[this.name])
              return Promise.resolve();
            const o = [],
              a = r.extensions[this.name];
            if (
              (void 0 !== a.clearcoatFactor &&
                (s.clearcoat = a.clearcoatFactor),
                void 0 !== a.clearcoatTexture &&
                o.push(n.assignTexture(s, "clearcoatMap", a.clearcoatTexture)),
                void 0 !== a.clearcoatRoughnessFactor &&
                (s.clearcoatRoughness = a.clearcoatRoughnessFactor),
                void 0 !== a.clearcoatRoughnessTexture &&
                o.push(
                  n.assignTexture(
                    s,
                    "clearcoatRoughnessMap",
                    a.clearcoatRoughnessTexture
                  )
                ),
                void 0 !== a.clearcoatNormalTexture &&
                (o.push(
                  n.assignTexture(
                    s,
                    "clearcoatNormalMap",
                    a.clearcoatNormalTexture
                  )
                ),
                  void 0 !== a.clearcoatNormalTexture.scale))
            ) {
              const t = a.clearcoatNormalTexture.scale;
              s.clearcoatNormalScale = new e.Vector2(t, -t);
            }
            return Promise.all(o);
          }
        }
        class i {
          constructor(e) {
            (this.parser = e), (this.name = n.KHR_MATERIALS_TRANSMISSION);
          }
          getMaterialType(t) {
            const s = this.parser.json.materials[t];
            return s.extensions && s.extensions[this.name]
              ? e.MeshPhysicalMaterial
              : null;
          }
          extendMaterialParams(e, t) {
            const s = this.parser,
              n = s.json.materials[e];
            if (!n.extensions || !n.extensions[this.name])
              return Promise.resolve();
            const r = [],
              o = n.extensions[this.name];
            return (
              void 0 !== o.transmissionFactor &&
              (t.transmission = o.transmissionFactor),
              void 0 !== o.transmissionTexture &&
              r.push(
                s.assignTexture(t, "transmissionMap", o.transmissionTexture)
              ),
              Promise.all(r)
            );
          }
        }
        class l {
          constructor(e) {
            (this.parser = e), (this.name = n.KHR_TEXTURE_BASISU);
          }
          loadTexture(e) {
            const t = this.parser,
              s = t.json,
              n = s.textures[e];
            if (!n.extensions || !n.extensions[this.name]) return null;
            const r = n.extensions[this.name],
              o = s.images[r.source],
              a = t.options.ktx2Loader;
            if (!a) {
              if (
                s.extensionsRequired &&
                s.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
                );
              return null;
            }
            return t.loadTextureImage(e, o, a);
          }
        }
        class c {
          constructor(e) {
            (this.parser = e),
              (this.name = n.EXT_TEXTURE_WEBP),
              (this.isSupported = null);
          }
          loadTexture(e) {
            const t = this.name,
              s = this.parser,
              n = s.json,
              r = n.textures[e];
            if (!r.extensions || !r.extensions[t]) return null;
            const o = r.extensions[t],
              a = n.images[o.source];
            let i = s.textureLoader;
            if (a.uri) {
              const e = s.options.manager.getHandler(a.uri);
              null !== e && (i = e);
            }
            return this.detectSupport().then(function (r) {
              if (r) return s.loadTextureImage(e, a, i);
              if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
                throw new Error(
                  "THREE.GLTFLoader: WebP required by asset but unsupported."
                );
              return s.loadTexture(e);
            });
          }
          detectSupport() {
            return (
              this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
              this.isSupported
            );
          }
        }
        class u {
          constructor(e) {
            (this.name = n.EXT_MESHOPT_COMPRESSION), (this.parser = e);
          }
          loadBufferView(e) {
            const t = this.parser.json,
              s = t.bufferViews[e];
            if (s.extensions && s.extensions[this.name]) {
              const e = s.extensions[this.name],
                n = this.parser.getDependency("buffer", e.buffer),
                r = this.parser.options.meshoptDecoder;
              if (!r || !r.supported) {
                if (
                  t.extensionsRequired &&
                  t.extensionsRequired.indexOf(this.name) >= 0
                )
                  throw new Error(
                    "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                  );
                return null;
              }
              return Promise.all([n, r.ready]).then(function (t) {
                const s = e.byteOffset || 0,
                  n = e.byteLength || 0,
                  o = e.count,
                  a = e.byteStride,
                  i = new ArrayBuffer(o * a),
                  l = new Uint8Array(t[0], s, n);
                return (
                  r.decodeGltfBuffer(
                    new Uint8Array(i),
                    o,
                    a,
                    l,
                    e.mode,
                    e.filter
                  ),
                  i
                );
              });
            }
            return null;
          }
        }
        const h = "glTF",
          p = 12,
          d = { JSON: 1313821514, BIN: 5130562 };
        class m {
          constructor(t) {
            (this.name = n.KHR_BINARY_GLTF),
              (this.content = null),
              (this.body = null);
            const s = new DataView(t, 0, p);
            if (
              ((this.header = {
                magic: e.LoaderUtils.decodeText(new Uint8Array(t.slice(0, 4))),
                version: s.getUint32(4, !0),
                length: s.getUint32(8, !0),
              }),
                this.header.magic !== h)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported glTF-Binary header."
              );
            if (this.header.version < 2)
              throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
            const r = this.header.length - p,
              o = new DataView(t, p);
            let a = 0;
            for (; a < r;) {
              const s = o.getUint32(a, !0);
              a += 4;
              const n = o.getUint32(a, !0);
              if (((a += 4), n === d.JSON)) {
                const n = new Uint8Array(t, p + a, s);
                this.content = e.LoaderUtils.decodeText(n);
              } else if (n === d.BIN) {
                const e = p + a;
                this.body = t.slice(e, e + s);
              }
              a += s;
            }
            if (null === this.content)
              throw new Error("THREE.GLTFLoader: JSON content not found.");
          }
        }
        class f {
          constructor(e, t) {
            if (!t)
              throw new Error(
                "THREE.GLTFLoader: No DRACOLoader instance provided."
              );
            (this.name = n.KHR_DRACO_MESH_COMPRESSION),
              (this.json = e),
              (this.dracoLoader = t),
              this.dracoLoader.preload();
          }
          decodePrimitive(e, t) {
            const s = this.json,
              n = this.dracoLoader,
              r = e.extensions[this.name].bufferView,
              o = e.extensions[this.name].attributes,
              a = {},
              i = {},
              l = {};
            for (const c in o) {
              const e = _[c] || c.toLowerCase();
              a[e] = o[c];
            }
            for (const c in e.attributes) {
              const t = _[c] || c.toLowerCase();
              if (void 0 !== o[c]) {
                const n = s.accessors[e.attributes[c]],
                  r = S[n.componentType];
                (l[t] = r), (i[t] = !0 === n.normalized);
              }
            }
            return t.getDependency("bufferView", r).then(function (e) {
              return new Promise(function (t) {
                n.decodeDracoFile(
                  e,
                  function (e) {
                    for (const t in e.attributes) {
                      const s = e.attributes[t],
                        n = i[t];
                      void 0 !== n && (s.normalized = n);
                    }
                    t(e);
                  },
                  a,
                  l
                );
              });
            });
          }
        }
        class g {
          constructor() {
            this.name = n.KHR_TEXTURE_TRANSFORM;
          }
          extendTexture(e, t) {
            return (
              void 0 !== t.texCoord &&
              console.warn(
                'THREE.GLTFLoader: Custom UV sets in "' +
                this.name +
                '" extension not yet supported.'
              ),
              void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale
                ? e
                : ((e = e.clone()),
                  void 0 !== t.offset && e.offset.fromArray(t.offset),
                  void 0 !== t.rotation && (e.rotation = t.rotation),
                  void 0 !== t.scale && e.repeat.fromArray(t.scale),
                  (e.needsUpdate = !0),
                  e)
            );
          }
        }
        class T extends e.MeshStandardMaterial {
          constructor(t) {
            super(), (this.isGLTFSpecularGlossinessMaterial = !0);
            const s = [
              "#ifdef USE_SPECULARMAP",
              "\tuniform sampler2D specularMap;",
              "#endif",
            ].join("\n"),
              n = [
                "#ifdef USE_GLOSSINESSMAP",
                "\tuniform sampler2D glossinessMap;",
                "#endif",
              ].join("\n"),
              r = [
                "vec3 specularFactor = specular;",
                "#ifdef USE_SPECULARMAP",
                "\tvec4 texelSpecular = texture2D( specularMap, vUv );",
                "\ttexelSpecular = sRGBToLinear( texelSpecular );",
                "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
                "\tspecularFactor *= texelSpecular.rgb;",
                "#endif",
              ].join("\n"),
              o = [
                "float glossinessFactor = glossiness;",
                "#ifdef USE_GLOSSINESSMAP",
                "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );",
                "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
                "\tglossinessFactor *= texelGlossiness.a;",
                "#endif",
              ].join("\n"),
              a = [
                "PhysicalMaterial material;",
                "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
                "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
                "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
                "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
                "material.specularRoughness += geometryRoughness;",
                "material.specularRoughness = min( material.specularRoughness, 1.0 );",
                "material.specularColor = specularFactor;",
              ].join("\n"),
              i = {
                specular: { value: new e.Color().setHex(16777215) },
                glossiness: { value: 1 },
                specularMap: { value: null },
                glossinessMap: { value: null },
              };
            (this._extraUniforms = i),
              (this.onBeforeCompile = function (e) {
                for (const t in i) e.uniforms[t] = i[t];
                e.fragmentShader = e.fragmentShader
                  .replace("uniform float roughness;", "uniform vec3 specular;")
                  .replace(
                    "uniform float metalness;",
                    "uniform float glossiness;"
                  )
                  .replace("#include <roughnessmap_pars_fragment>", s)
                  .replace("#include <metalnessmap_pars_fragment>", n)
                  .replace("#include <roughnessmap_fragment>", r)
                  .replace("#include <metalnessmap_fragment>", o)
                  .replace("#include <lights_physical_fragment>", a);
              }),
              Object.defineProperties(this, {
                specular: {
                  get: function () {
                    return i.specular.value;
                  },
                  set: function (e) {
                    i.specular.value = e;
                  },
                },
                specularMap: {
                  get: function () {
                    return i.specularMap.value;
                  },
                  set: function (e) {
                    (i.specularMap.value = e),
                      e
                        ? (this.defines.USE_SPECULARMAP = "")
                        : delete this.defines.USE_SPECULARMAP;
                  },
                },
                glossiness: {
                  get: function () {
                    return i.glossiness.value;
                  },
                  set: function (e) {
                    i.glossiness.value = e;
                  },
                },
                glossinessMap: {
                  get: function () {
                    return i.glossinessMap.value;
                  },
                  set: function (e) {
                    (i.glossinessMap.value = e),
                      e
                        ? ((this.defines.USE_GLOSSINESSMAP = ""),
                          (this.defines.USE_UV = ""))
                        : (delete this.defines.USE_GLOSSINESSMAP,
                          delete this.defines.USE_UV);
                  },
                },
              }),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this.setValues(t);
          }
          copy(e) {
            return (
              super.copy(e),
              (this.specularMap = e.specularMap),
              this.specular.copy(e.specular),
              (this.glossinessMap = e.glossinessMap),
              (this.glossiness = e.glossiness),
              delete this.metalness,
              delete this.roughness,
              delete this.metalnessMap,
              delete this.roughnessMap,
              this
            );
          }
        }
        class x {
          constructor() {
            (this.name = n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
              (this.specularGlossinessParams = [
                "color",
                "map",
                "lightMap",
                "lightMapIntensity",
                "aoMap",
                "aoMapIntensity",
                "emissive",
                "emissiveIntensity",
                "emissiveMap",
                "bumpMap",
                "bumpScale",
                "normalMap",
                "normalMapType",
                "displacementMap",
                "displacementScale",
                "displacementBias",
                "specularMap",
                "specular",
                "glossinessMap",
                "glossiness",
                "alphaMap",
                "envMap",
                "envMapIntensity",
                "refractionRatio",
              ]);
          }
          getMaterialType() {
            return T;
          }
          extendParams(t, s, n) {
            const r = s.extensions[this.name];
            (t.color = new e.Color(1, 1, 1)), (t.opacity = 1);
            const o = [];
            if (Array.isArray(r.diffuseFactor)) {
              const e = r.diffuseFactor;
              t.color.fromArray(e), (t.opacity = e[3]);
            }
            if (
              (void 0 !== r.diffuseTexture &&
                o.push(n.assignTexture(t, "map", r.diffuseTexture)),
                (t.emissive = new e.Color(0, 0, 0)),
                (t.glossiness =
                  void 0 !== r.glossinessFactor ? r.glossinessFactor : 1),
                (t.specular = new e.Color(1, 1, 1)),
                Array.isArray(r.specularFactor) &&
                t.specular.fromArray(r.specularFactor),
                void 0 !== r.specularGlossinessTexture)
            ) {
              const e = r.specularGlossinessTexture;
              o.push(n.assignTexture(t, "glossinessMap", e)),
                o.push(n.assignTexture(t, "specularMap", e));
            }
            return Promise.all(o);
          }
          createMaterial(t) {
            const s = new T(t);
            return (
              (s.fog = !0),
              (s.color = t.color),
              (s.map = void 0 === t.map ? null : t.map),
              (s.lightMap = null),
              (s.lightMapIntensity = 1),
              (s.aoMap = void 0 === t.aoMap ? null : t.aoMap),
              (s.aoMapIntensity = 1),
              (s.emissive = t.emissive),
              (s.emissiveIntensity = 1),
              (s.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap),
              (s.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap),
              (s.bumpScale = 1),
              (s.normalMap = void 0 === t.normalMap ? null : t.normalMap),
              (s.normalMapType = e.TangentSpaceNormalMap),
              t.normalScale && (s.normalScale = t.normalScale),
              (s.displacementMap = null),
              (s.displacementScale = 1),
              (s.displacementBias = 0),
              (s.specularMap = void 0 === t.specularMap ? null : t.specularMap),
              (s.specular = t.specular),
              (s.glossinessMap =
                void 0 === t.glossinessMap ? null : t.glossinessMap),
              (s.glossiness = t.glossiness),
              (s.alphaMap = null),
              (s.envMap = void 0 === t.envMap ? null : t.envMap),
              (s.envMapIntensity = 1),
              (s.refractionRatio = 0.98),
              s
            );
          }
        }
        class M {
          constructor() {
            this.name = n.KHR_MESH_QUANTIZATION;
          }
        }
        class R extends e.Interpolant {
          constructor(e, t, s, n) {
            super(e, t, s, n);
          }
          copySampleValue_(e) {
            const t = this.resultBuffer,
              s = this.sampleValues,
              n = this.valueSize,
              r = e * n * 3 + n;
            for (let o = 0; o !== n; o++) t[o] = s[r + o];
            return t;
          }
        }
        (R.prototype.beforeStart_ = R.prototype.copySampleValue_),
          (R.prototype.afterEnd_ = R.prototype.copySampleValue_),
          (R.prototype.interpolate_ = function (e, t, s, n) {
            const r = this.resultBuffer,
              o = this.sampleValues,
              a = this.valueSize,
              i = 2 * a,
              l = 3 * a,
              c = n - t,
              u = (s - t) / c,
              h = u * u,
              p = h * u,
              d = e * l,
              m = d - l,
              f = -2 * p + 3 * h,
              g = p - h,
              T = 1 - f,
              x = g - h + u;
            for (let M = 0; M !== a; M++) {
              const e = o[m + M + a],
                t = o[m + M + i] * c,
                s = o[d + M + a],
                n = o[d + M] * c;
              r[M] = T * e + x * t + f * s + g * n;
            }
            return r;
          });
        const v = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
          S = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array,
          },
          A = {
            9728: e.NearestFilter,
            9729: e.LinearFilter,
            9984: e.NearestMipmapNearestFilter,
            9985: e.LinearMipmapNearestFilter,
            9986: e.NearestMipmapLinearFilter,
            9987: e.LinearMipmapLinearFilter,
          },
          E = {
            33071: e.ClampToEdgeWrapping,
            33648: e.MirroredRepeatWrapping,
            10497: e.RepeatWrapping,
          },
          L = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16,
          },
          _ = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex",
          },
          y = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences",
          },
          w = {
            CUBICSPLINE: void 0,
            LINEAR: e.InterpolateLinear,
            STEP: e.InterpolateDiscrete,
          },
          b = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
        function I(e, t) {
          return "string" != typeof e || "" === e
            ? ""
            : (/^https?:\/\//i.test(t) &&
              /^\//.test(e) &&
              (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e)
                ? e
                : /^data:.*,.*$/i.test(e)
                  ? e
                  : /^blob:.*$/i.test(e)
                    ? e
                    : t + e);
        }
        function N(t) {
          return (
            void 0 === t.DefaultMaterial &&
            (t.DefaultMaterial = new e.MeshStandardMaterial({
              color: 16777215,
              emissive: 0,
              metalness: 1,
              roughness: 1,
              transparent: !1,
              depthTest: !0,
              side: e.FrontSide,
            })),
            t.DefaultMaterial
          );
        }
        function P(e, t, s) {
          for (const n in s.extensions)
            void 0 === e[n] &&
              ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
                (t.userData.gltfExtensions[n] = s.extensions[n]));
        }
        function O(e, t) {
          void 0 !== t.extras &&
            ("object" == typeof t.extras
              ? Object.assign(e.userData, t.extras)
              : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " +
                t.extras
              ));
        }
        function C(e, t, s) {
          let n = !1,
            r = !1;
          for (let i = 0, l = t.length; i < l; i++) {
            const e = t[i];
            if (
              (void 0 !== e.POSITION && (n = !0),
                void 0 !== e.NORMAL && (r = !0),
                n && r)
            )
              break;
          }
          if (!n && !r) return Promise.resolve(e);
          const o = [],
            a = [];
          for (let i = 0, l = t.length; i < l; i++) {
            const l = t[i];
            if (n) {
              const t =
                void 0 !== l.POSITION
                  ? s.getDependency("accessor", l.POSITION)
                  : e.attributes.position;
              o.push(t);
            }
            if (r) {
              const t =
                void 0 !== l.NORMAL
                  ? s.getDependency("accessor", l.NORMAL)
                  : e.attributes.normal;
              a.push(t);
            }
          }
          return Promise.all([Promise.all(o), Promise.all(a)]).then(function (
            t
          ) {
            const s = t[0],
              o = t[1];
            return (
              n && (e.morphAttributes.position = s),
              r && (e.morphAttributes.normal = o),
              (e.morphTargetsRelative = !0),
              e
            );
          });
        }
        function F(e, t) {
          if ((e.updateMorphTargets(), void 0 !== t.weights))
            for (let s = 0, n = t.weights.length; s < n; s++)
              e.morphTargetInfluences[s] = t.weights[s];
          if (t.extras && Array.isArray(t.extras.targetNames)) {
            const s = t.extras.targetNames;
            if (e.morphTargetInfluences.length === s.length) {
              e.morphTargetDictionary = {};
              for (let t = 0, n = s.length; t < n; t++)
                e.morphTargetDictionary[s[t]] = t;
            } else
              console.warn(
                "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
              );
          }
        }
        function U(e) {
          const t = e.extensions && e.extensions[n.KHR_DRACO_MESH_COMPRESSION];
          let s;
          return (s = t
            ? "draco:" + t.bufferView + ":" + t.indices + ":" + H(t.attributes)
            : e.indices + ":" + H(e.attributes) + ":" + e.mode);
        }
        function H(e) {
          let t = "";
          const s = Object.keys(e).sort();
          for (let n = 0, r = s.length; n < r; n++)
            t += s[n] + ":" + e[s[n]] + ";";
          return t;
        }
        function D(e) {
          switch (e) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unsupported normalized accessor component type."
              );
          }
        }
        class G {
          constructor(t = {}, n = {}) {
            (this.json = t),
              (this.extensions = {}),
              (this.plugins = {}),
              (this.options = n),
              (this.cache = new s()),
              (this.associations = new Map()),
              (this.primitiveCache = {}),
              (this.meshCache = { refs: {}, uses: {} }),
              (this.cameraCache = { refs: {}, uses: {} }),
              (this.lightCache = { refs: {}, uses: {} }),
              (this.textureCache = {}),
              (this.nodeNamesUsed = {}),
              "undefined" != typeof createImageBitmap &&
                !1 === /Firefox/.test(navigator.userAgent)
                ? (this.textureLoader = new e.ImageBitmapLoader(
                  this.options.manager
                ))
                : (this.textureLoader = new e.TextureLoader(
                  this.options.manager
                )),
              this.textureLoader.setCrossOrigin(this.options.crossOrigin),
              this.textureLoader.setRequestHeader(this.options.requestHeader),
              (this.fileLoader = new e.FileLoader(this.options.manager)),
              this.fileLoader.setResponseType("arraybuffer"),
              "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
          }
          setExtensions(e) {
            this.extensions = e;
          }
          setPlugins(e) {
            this.plugins = e;
          }
          parse(e, t) {
            const s = this,
              n = this.json,
              r = this.extensions;
            this.cache.removeAll(),
              this._invokeAll(function (e) {
                return e._markDefs && e._markDefs();
              }),
              Promise.all(
                this._invokeAll(function (e) {
                  return e.beforeRoot && e.beforeRoot();
                })
              )
                .then(function () {
                  return Promise.all([
                    s.getDependencies("scene"),
                    s.getDependencies("animation"),
                    s.getDependencies("camera"),
                  ]);
                })
                .then(function (t) {
                  const o = {
                    scene: t[0][n.scene || 0],
                    scenes: t[0],
                    animations: t[1],
                    cameras: t[2],
                    asset: n.asset,
                    parser: s,
                    userData: {},
                  };
                  P(r, o, n),
                    O(o, n),
                    Promise.all(
                      s._invokeAll(function (e) {
                        return e.afterRoot && e.afterRoot(o);
                      })
                    ).then(function () {
                      e(o);
                    });
                })
                .catch(t);
          }
          _markDefs() {
            const e = this.json.nodes || [],
              t = this.json.skins || [],
              s = this.json.meshes || [];
            for (let n = 0, r = t.length; n < r; n++) {
              const s = t[n].joints;
              for (let t = 0, n = s.length; t < n; t++) e[s[t]].isBone = !0;
            }
            for (let n = 0, r = e.length; n < r; n++) {
              const t = e[n];
              void 0 !== t.mesh &&
                (this._addNodeRef(this.meshCache, t.mesh),
                  void 0 !== t.skin && (s[t.mesh].isSkinnedMesh = !0)),
                void 0 !== t.camera &&
                this._addNodeRef(this.cameraCache, t.camera);
            }
          }
          _addNodeRef(e, t) {
            void 0 !== t &&
              (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++);
          }
          _getNodeRef(e, t, s) {
            if (e.refs[t] <= 1) return s;
            const n = s.clone();
            return (n.name += "_instance_" + e.uses[t]++), n;
          }
          _invokeOne(e) {
            const t = Object.values(this.plugins);
            t.push(this);
            for (let s = 0; s < t.length; s++) {
              const n = e(t[s]);
              if (n) return n;
            }
            return null;
          }
          _invokeAll(e) {
            const t = Object.values(this.plugins);
            t.unshift(this);
            const s = [];
            for (let n = 0; n < t.length; n++) {
              const r = e(t[n]);
              r && s.push(r);
            }
            return s;
          }
          getDependency(e, t) {
            const s = e + ":" + t;
            let n = this.cache.get(s);
            if (!n) {
              switch (e) {
                case "scene":
                  n = this.loadScene(t);
                  break;
                case "node":
                  n = this.loadNode(t);
                  break;
                case "mesh":
                  n = this._invokeOne(function (e) {
                    return e.loadMesh && e.loadMesh(t);
                  });
                  break;
                case "accessor":
                  n = this.loadAccessor(t);
                  break;
                case "bufferView":
                  n = this._invokeOne(function (e) {
                    return e.loadBufferView && e.loadBufferView(t);
                  });
                  break;
                case "buffer":
                  n = this.loadBuffer(t);
                  break;
                case "material":
                  n = this._invokeOne(function (e) {
                    return e.loadMaterial && e.loadMaterial(t);
                  });
                  break;
                case "texture":
                  n = this._invokeOne(function (e) {
                    return e.loadTexture && e.loadTexture(t);
                  });
                  break;
                case "skin":
                  n = this.loadSkin(t);
                  break;
                case "animation":
                  n = this.loadAnimation(t);
                  break;
                case "camera":
                  n = this.loadCamera(t);
                  break;
                default:
                  throw new Error("Unknown type: " + e);
              }
              this.cache.add(s, n);
            }
            return n;
          }
          getDependencies(e) {
            let t = this.cache.get(e);
            if (!t) {
              const s = this,
                n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
              (t = Promise.all(
                n.map(function (t, n) {
                  return s.getDependency(e, n);
                })
              )),
                this.cache.add(e, t);
            }
            return t;
          }
          loadBuffer(e) {
            const t = this.json.buffers[e],
              s = this.fileLoader;
            if (t.type && "arraybuffer" !== t.type)
              throw new Error(
                "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
              );
            if (void 0 === t.uri && 0 === e)
              return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
            const r = this.options;
            return new Promise(function (e, n) {
              s.load(I(t.uri, r.path), e, void 0, function () {
                n(
                  new Error(
                    'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                  )
                );
              });
            });
          }
          loadBufferView(e) {
            const t = this.json.bufferViews[e];
            return this.getDependency("buffer", t.buffer).then(function (e) {
              const s = t.byteLength || 0,
                n = t.byteOffset || 0;
              return e.slice(n, n + s);
            });
          }
          loadAccessor(t) {
            const s = this,
              n = this.json,
              r = this.json.accessors[t];
            if (void 0 === r.bufferView && void 0 === r.sparse)
              return Promise.resolve(null);
            const o = [];
            return (
              void 0 !== r.bufferView
                ? o.push(this.getDependency("bufferView", r.bufferView))
                : o.push(null),
              void 0 !== r.sparse &&
              (o.push(
                this.getDependency("bufferView", r.sparse.indices.bufferView)
              ),
                o.push(
                  this.getDependency("bufferView", r.sparse.values.bufferView)
                )),
              Promise.all(o).then(function (t) {
                const o = t[0],
                  a = L[r.type],
                  i = S[r.componentType],
                  l = i.BYTES_PER_ELEMENT,
                  c = l * a,
                  u = r.byteOffset || 0,
                  h =
                    void 0 !== r.bufferView
                      ? n.bufferViews[r.bufferView].byteStride
                      : void 0,
                  p = !0 === r.normalized;
                let d, m;
                if (h && h !== c) {
                  const t = Math.floor(u / h),
                    n =
                      "InterleavedBuffer:" +
                      r.bufferView +
                      ":" +
                      r.componentType +
                      ":" +
                      t +
                      ":" +
                      r.count;
                  let c = s.cache.get(n);
                  c ||
                    ((d = new i(o, t * h, (r.count * h) / l)),
                      (c = new e.InterleavedBuffer(d, h / l)),
                      s.cache.add(n, c)),
                    (m = new e.InterleavedBufferAttribute(
                      c,
                      a,
                      (u % h) / l,
                      p
                    ));
                } else (d = null === o ? new i(r.count * a) : new i(o, u, r.count * a)), (m = new e.BufferAttribute(d, a, p));
                if (void 0 !== r.sparse) {
                  const s = L.SCALAR,
                    n = S[r.sparse.indices.componentType],
                    l = r.sparse.indices.byteOffset || 0,
                    c = r.sparse.values.byteOffset || 0,
                    u = new n(t[1], l, r.sparse.count * s),
                    h = new i(t[2], c, r.sparse.count * a);
                  null !== o &&
                    (m = new e.BufferAttribute(
                      m.array.slice(),
                      m.itemSize,
                      m.normalized
                    ));
                  for (let e = 0, t = u.length; e < t; e++) {
                    const t = u[e];
                    if (
                      (m.setX(t, h[e * a]),
                        a >= 2 && m.setY(t, h[e * a + 1]),
                        a >= 3 && m.setZ(t, h[e * a + 2]),
                        a >= 4 && m.setW(t, h[e * a + 3]),
                        a >= 5)
                    )
                      throw new Error(
                        "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                      );
                  }
                }
                return m;
              })
            );
          }
          loadTexture(e) {
            const t = this.json,
              s = this.options,
              n = t.textures[e],
              r = t.images[n.source];
            let o = this.textureLoader;
            if (r.uri) {
              const e = s.manager.getHandler(r.uri);
              null !== e && (o = e);
            }
            return this.loadTextureImage(e, r, o);
          }
          loadTextureImage(t, s, n) {
            const r = this,
              o = this.json,
              a = this.options,
              i = o.textures[t],
              l = (s.uri || s.bufferView) + ":" + i.sampler;
            if (this.textureCache[l]) return this.textureCache[l];
            const c = self.URL || self.webkitURL;
            let u = s.uri || "",
              h = !1,
              p = !0;
            const d =
              u.search(/\.jpe?g($|\?)/i) > 0 ||
              0 === u.search(/^data\:image\/jpeg/);
            if (
              (("image/jpeg" === s.mimeType || d) && (p = !1),
                void 0 !== s.bufferView)
            )
              u = r
                .getDependency("bufferView", s.bufferView)
                .then(function (e) {
                  if ("image/png" === s.mimeType) {
                    const t = new DataView(e, 25, 1).getUint8(0, !1);
                    p = 6 === t || 4 === t || 3 === t;
                  }
                  h = !0;
                  const t = new Blob([e], { type: s.mimeType });
                  return (u = c.createObjectURL(t));
                });
            else if (void 0 === s.uri)
              throw new Error(
                "THREE.GLTFLoader: Image " +
                t +
                " is missing URI and bufferView"
              );
            const m = Promise.resolve(u)
              .then(function (t) {
                return new Promise(function (s, r) {
                  let o = s;
                  !0 === n.isImageBitmapLoader &&
                    (o = function (t) {
                      s(new e.CanvasTexture(t));
                    }),
                    n.load(I(t, a.path), o, void 0, r);
                });
              })
              .then(function (s) {
                !0 === h && c.revokeObjectURL(u),
                  (s.flipY = !1),
                  i.name && (s.name = i.name),
                  p || (s.format = e.RGBFormat);
                const n = (o.samplers || {})[i.sampler] || {};
                return (
                  (s.magFilter = A[n.magFilter] || e.LinearFilter),
                  (s.minFilter = A[n.minFilter] || e.LinearMipmapLinearFilter),
                  (s.wrapS = E[n.wrapS] || e.RepeatWrapping),
                  (s.wrapT = E[n.wrapT] || e.RepeatWrapping),
                  r.associations.set(s, { type: "textures", index: t }),
                  s
                );
              });
            return (this.textureCache[l] = m), m;
          }
          assignTexture(e, t, s) {
            const r = this;
            return this.getDependency("texture", s.index).then(function (o) {
              if (
                (void 0 === s.texCoord ||
                  0 == s.texCoord ||
                  ("aoMap" === t && 1 == s.texCoord) ||
                  console.warn(
                    "THREE.GLTFLoader: Custom UV set " +
                    s.texCoord +
                    " for texture " +
                    t +
                    " not yet supported."
                  ),
                  r.extensions[n.KHR_TEXTURE_TRANSFORM])
              ) {
                const e =
                  void 0 !== s.extensions
                    ? s.extensions[n.KHR_TEXTURE_TRANSFORM]
                    : void 0;
                if (e) {
                  const t = r.associations.get(o);
                  (o = r.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(
                    o,
                    e
                  )),
                    r.associations.set(o, t);
                }
              }
              e[t] = o;
            });
          }
          assignFinalMaterial(t) {
            const s = t.geometry;
            let n = t.material;
            const r = void 0 !== s.attributes.tangent,
              o = void 0 !== s.attributes.color,
              a = void 0 === s.attributes.normal,
              i = Object.keys(s.morphAttributes).length > 0,
              l = i && void 0 !== s.morphAttributes.normal;
            if (t.isPoints) {
              const t = "PointsMaterial:" + n.uuid;
              let s = this.cache.get(t);
              s ||
                ((s = new e.PointsMaterial()),
                  e.Material.prototype.copy.call(s, n),
                  s.color.copy(n.color),
                  (s.map = n.map),
                  (s.sizeAttenuation = !1),
                  this.cache.add(t, s)),
                (n = s);
            } else if (t.isLine) {
              const t = "LineBasicMaterial:" + n.uuid;
              let s = this.cache.get(t);
              s ||
                ((s = new e.LineBasicMaterial()),
                  e.Material.prototype.copy.call(s, n),
                  s.color.copy(n.color),
                  this.cache.add(t, s)),
                (n = s);
            }
            if (r || o || a || i) {
              let e = "ClonedMaterial:" + n.uuid + ":";
              n.isGLTFSpecularGlossinessMaterial &&
                (e += "specular-glossiness:"),
                r && (e += "vertex-tangents:"),
                o && (e += "vertex-colors:"),
                a && (e += "flat-shading:"),
                i && (e += "morph-targets:"),
                l && (e += "morph-normals:");
              let t = this.cache.get(e);
              t ||
                ((t = n.clone()),
                  o && (t.vertexColors = !0),
                  a && (t.flatShading = !0),
                  i && (t.morphTargets = !0),
                  l && (t.morphNormals = !0),
                  r &&
                  ((t.vertexTangents = !0),
                    t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                  this.cache.add(e, t),
                  this.associations.set(t, this.associations.get(n))),
                (n = t);
            }
            n.aoMap &&
              void 0 === s.attributes.uv2 &&
              void 0 !== s.attributes.uv &&
              s.setAttribute("uv2", s.attributes.uv),
              (t.material = n);
          }
          getMaterialType() {
            return e.MeshStandardMaterial;
          }
          loadMaterial(t) {
            const s = this,
              r = this.json,
              o = this.extensions,
              a = r.materials[t];
            let i;
            const l = {},
              c = a.extensions || {},
              u = [];
            if (c[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
              const e = o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
              (i = e.getMaterialType()), u.push(e.extendParams(l, a, s));
            } else if (c[n.KHR_MATERIALS_UNLIT]) {
              const e = o[n.KHR_MATERIALS_UNLIT];
              (i = e.getMaterialType()), u.push(e.extendParams(l, a, s));
            } else {
              const n = a.pbrMetallicRoughness || {};
              if (
                ((l.color = new e.Color(1, 1, 1)),
                  (l.opacity = 1),
                  Array.isArray(n.baseColorFactor))
              ) {
                const e = n.baseColorFactor;
                l.color.fromArray(e), (l.opacity = e[3]);
              }
              void 0 !== n.baseColorTexture &&
                u.push(s.assignTexture(l, "map", n.baseColorTexture)),
                (l.metalness =
                  void 0 !== n.metallicFactor ? n.metallicFactor : 1),
                (l.roughness =
                  void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
                void 0 !== n.metallicRoughnessTexture &&
                (u.push(
                  s.assignTexture(
                    l,
                    "metalnessMap",
                    n.metallicRoughnessTexture
                  )
                ),
                  u.push(
                    s.assignTexture(
                      l,
                      "roughnessMap",
                      n.metallicRoughnessTexture
                    )
                  )),
                (i = this._invokeOne(function (e) {
                  return e.getMaterialType && e.getMaterialType(t);
                })),
                u.push(
                  Promise.all(
                    this._invokeAll(function (e) {
                      return (
                        e.extendMaterialParams && e.extendMaterialParams(t, l)
                      );
                    })
                  )
                );
            }
            !0 === a.doubleSided && (l.side = e.DoubleSide);
            const h = a.alphaMode || b.OPAQUE;
            return (
              h === b.BLEND
                ? ((l.transparent = !0), (l.depthWrite = !1))
                : ((l.transparent = !1),
                  h === b.MASK &&
                  (l.alphaTest =
                    void 0 !== a.alphaCutoff ? a.alphaCutoff : 0.5)),
              void 0 !== a.normalTexture &&
              i !== e.MeshBasicMaterial &&
              (u.push(s.assignTexture(l, "normalMap", a.normalTexture)),
                (l.normalScale = new e.Vector2(1, -1)),
                void 0 !== a.normalTexture.scale &&
                l.normalScale.set(
                  a.normalTexture.scale,
                  -a.normalTexture.scale
                )),
              void 0 !== a.occlusionTexture &&
              i !== e.MeshBasicMaterial &&
              (u.push(s.assignTexture(l, "aoMap", a.occlusionTexture)),
                void 0 !== a.occlusionTexture.strength &&
                (l.aoMapIntensity = a.occlusionTexture.strength)),
              void 0 !== a.emissiveFactor &&
              i !== e.MeshBasicMaterial &&
              (l.emissive = new e.Color().fromArray(a.emissiveFactor)),
              void 0 !== a.emissiveTexture &&
              i !== e.MeshBasicMaterial &&
              u.push(s.assignTexture(l, "emissiveMap", a.emissiveTexture)),
              Promise.all(u).then(function () {
                let r;
                return (
                  (r =
                    i === T
                      ? o[
                        n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
                      ].createMaterial(l)
                      : new i(l)),
                  a.name && (r.name = a.name),
                  r.map && (r.map.encoding = e.sRGBEncoding),
                  r.emissiveMap && (r.emissiveMap.encoding = e.sRGBEncoding),
                  O(r, a),
                  s.associations.set(r, { type: "materials", index: t }),
                  a.extensions && P(o, r, a),
                  r
                );
              })
            );
          }
          createUniqueName(t) {
            const s = e.PropertyBinding.sanitizeNodeName(t || "");
            let n = s;
            for (let e = 1; this.nodeNamesUsed[n]; ++e) n = s + "_" + e;
            return (this.nodeNamesUsed[n] = !0), n;
          }
          loadGeometries(t) {
            const s = this,
              r = this.extensions,
              o = this.primitiveCache;
            function a(e) {
              return r[n.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(e, s)
                .then(function (t) {
                  return j(t, e, s);
                });
            }
            const i = [];
            for (let l = 0, c = t.length; l < c; l++) {
              const r = t[l],
                c = U(r),
                u = o[c];
              if (u) i.push(u.promise);
              else {
                let t;
                (t =
                  r.extensions && r.extensions[n.KHR_DRACO_MESH_COMPRESSION]
                    ? a(r)
                    : j(new e.BufferGeometry(), r, s)),
                  (o[c] = { primitive: r, promise: t }),
                  i.push(t);
              }
            }
            return Promise.all(i);
          }
          loadMesh(t) {
            const s = this,
              n = this.json,
              r = this.extensions,
              o = n.meshes[t],
              a = o.primitives,
              i = [];
            for (let e = 0, l = a.length; e < l; e++) {
              const t =
                void 0 === a[e].material
                  ? N(this.cache)
                  : this.getDependency("material", a[e].material);
              i.push(t);
            }
            return (
              i.push(s.loadGeometries(a)),
              Promise.all(i).then(function (n) {
                const i = n.slice(0, n.length - 1),
                  l = n[n.length - 1],
                  c = [];
                for (let h = 0, p = l.length; h < p; h++) {
                  const n = l[h],
                    u = a[h];
                  let p;
                  const d = i[h];
                  if (
                    u.mode === v.TRIANGLES ||
                    u.mode === v.TRIANGLE_STRIP ||
                    u.mode === v.TRIANGLE_FAN ||
                    void 0 === u.mode
                  )
                    !0 !==
                      (p =
                        !0 === o.isSkinnedMesh
                          ? new e.SkinnedMesh(n, d)
                          : new e.Mesh(n, d)).isSkinnedMesh ||
                      p.geometry.attributes.skinWeight.normalized ||
                      p.normalizeSkinWeights(),
                      u.mode === v.TRIANGLE_STRIP
                        ? (p.geometry = K(p.geometry, e.TriangleStripDrawMode))
                        : u.mode === v.TRIANGLE_FAN &&
                        (p.geometry = K(p.geometry, e.TriangleFanDrawMode));
                  else if (u.mode === v.LINES) p = new e.LineSegments(n, d);
                  else if (u.mode === v.LINE_STRIP) p = new e.Line(n, d);
                  else if (u.mode === v.LINE_LOOP) p = new e.LineLoop(n, d);
                  else {
                    if (u.mode !== v.POINTS)
                      throw new Error(
                        "THREE.GLTFLoader: Primitive mode unsupported: " +
                        u.mode
                      );
                    p = new e.Points(n, d);
                  }
                  Object.keys(p.geometry.morphAttributes).length > 0 && F(p, o),
                    (p.name = s.createUniqueName(o.name || "mesh_" + t)),
                    O(p, o),
                    u.extensions && P(r, p, u),
                    s.assignFinalMaterial(p),
                    c.push(p);
                }
                if (1 === c.length) return c[0];
                const u = new e.Group();
                for (let e = 0, t = c.length; e < t; e++) u.add(c[e]);
                return u;
              })
            );
          }
          loadCamera(t) {
            let s;
            const n = this.json.cameras[t],
              r = n[n.type];
            if (r)
              return (
                "perspective" === n.type
                  ? (s = new e.PerspectiveCamera(
                    e.MathUtils.radToDeg(r.yfov),
                    r.aspectRatio || 1,
                    r.znear || 1,
                    r.zfar || 2e6
                  ))
                  : "orthographic" === n.type &&
                  (s = new e.OrthographicCamera(
                    -r.xmag,
                    r.xmag,
                    r.ymag,
                    -r.ymag,
                    r.znear,
                    r.zfar
                  )),
                n.name && (s.name = this.createUniqueName(n.name)),
                O(s, n),
                Promise.resolve(s)
              );
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
          }
          loadSkin(e) {
            const t = this.json.skins[e],
              s = { joints: t.joints };
            return void 0 === t.inverseBindMatrices
              ? Promise.resolve(s)
              : this.getDependency("accessor", t.inverseBindMatrices).then(
                function (e) {
                  return (s.inverseBindMatrices = e), s;
                }
              );
          }
          loadAnimation(t) {
            const s = this.json.animations[t],
              n = [],
              r = [],
              o = [],
              a = [],
              i = [];
            for (let e = 0, l = s.channels.length; e < l; e++) {
              const t = s.channels[e],
                l = s.samplers[t.sampler],
                c = t.target,
                u = void 0 !== c.node ? c.node : c.id,
                h = void 0 !== s.parameters ? s.parameters[l.input] : l.input,
                p = void 0 !== s.parameters ? s.parameters[l.output] : l.output;
              n.push(this.getDependency("node", u)),
                r.push(this.getDependency("accessor", h)),
                o.push(this.getDependency("accessor", p)),
                a.push(l),
                i.push(c);
            }
            return Promise.all([
              Promise.all(n),
              Promise.all(r),
              Promise.all(o),
              Promise.all(a),
              Promise.all(i),
            ]).then(function (n) {
              const r = n[0],
                o = n[1],
                a = n[2],
                i = n[3],
                l = n[4],
                c = [];
              for (let t = 0, s = r.length; t < s; t++) {
                const s = r[t],
                  n = o[t],
                  u = a[t],
                  h = i[t],
                  p = l[t];
                if (void 0 === s) continue;
                let d;
                switch (
                (s.updateMatrix(), (s.matrixAutoUpdate = !0), y[p.path])
                ) {
                  case y.weights:
                    d = e.NumberKeyframeTrack;
                    break;
                  case y.rotation:
                    d = e.QuaternionKeyframeTrack;
                    break;
                  case y.position:
                  case y.scale:
                  default:
                    d = e.VectorKeyframeTrack;
                }
                const m = s.name ? s.name : s.uuid,
                  f =
                    void 0 !== h.interpolation
                      ? w[h.interpolation]
                      : e.InterpolateLinear,
                  g = [];
                y[p.path] === y.weights
                  ? s.traverse(function (e) {
                    !0 === e.isMesh &&
                      e.morphTargetInfluences &&
                      g.push(e.name ? e.name : e.uuid);
                  })
                  : g.push(m);
                let T = u.array;
                if (u.normalized) {
                  const e = D(T.constructor),
                    t = new Float32Array(T.length);
                  for (let s = 0, n = T.length; s < n; s++) t[s] = T[s] * e;
                  T = t;
                }
                for (let e = 0, t = g.length; e < t; e++) {
                  const t = new d(g[e] + "." + y[p.path], n.array, T, f);
                  "CUBICSPLINE" === h.interpolation &&
                    ((t.createInterpolant = function (e) {
                      return new R(
                        this.times,
                        this.values,
                        this.getValueSize() / 3,
                        e
                      );
                    }),
                      (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
                        !0)),
                    c.push(t);
                }
              }
              const u = s.name ? s.name : "animation_" + t;
              return new e.AnimationClip(u, void 0, c);
            });
          }
          createNodeMesh(e) {
            const t = this.json,
              s = this,
              n = t.nodes[e];
            return void 0 === n.mesh
              ? null
              : s.getDependency("mesh", n.mesh).then(function (e) {
                const t = s._getNodeRef(s.meshCache, n.mesh, e);
                return (
                  void 0 !== n.weights &&
                  t.traverse(function (e) {
                    if (e.isMesh)
                      for (let t = 0, s = n.weights.length; t < s; t++)
                        e.morphTargetInfluences[t] = n.weights[t];
                  }),
                  t
                );
              });
          }
          loadNode(t) {
            const s = this.json,
              n = this.extensions,
              r = this,
              o = s.nodes[t],
              a = o.name ? r.createUniqueName(o.name) : "";
            return (function () {
              const e = [],
                s = r._invokeOne(function (e) {
                  return e.createNodeMesh && e.createNodeMesh(t);
                });
              return (
                s && e.push(s),
                void 0 !== o.camera &&
                e.push(
                  r.getDependency("camera", o.camera).then(function (e) {
                    return r._getNodeRef(r.cameraCache, o.camera, e);
                  })
                ),
                r
                  ._invokeAll(function (e) {
                    return e.createNodeAttachment && e.createNodeAttachment(t);
                  })
                  .forEach(function (t) {
                    e.push(t);
                  }),
                Promise.all(e)
              );
            })().then(function (s) {
              let i;
              if (
                (i =
                  !0 === o.isBone
                    ? new e.Bone()
                    : s.length > 1
                      ? new e.Group()
                      : 1 === s.length
                        ? s[0]
                        : new e.Object3D()) !== s[0]
              )
                for (let e = 0, t = s.length; e < t; e++) i.add(s[e]);
              if (
                (o.name && ((i.userData.name = o.name), (i.name = a)),
                  O(i, o),
                  o.extensions && P(n, i, o),
                  void 0 !== o.matrix)
              ) {
                const t = new e.Matrix4();
                t.fromArray(o.matrix), i.applyMatrix4(t);
              } else void 0 !== o.translation && i.position.fromArray(o.translation), void 0 !== o.rotation && i.quaternion.fromArray(o.rotation), void 0 !== o.scale && i.scale.fromArray(o.scale);
              return r.associations.set(i, { type: "nodes", index: t }), i;
            });
          }
          loadScene(t) {
            const s = this.json,
              n = this.extensions,
              r = this.json.scenes[t],
              o = this,
              a = new e.Group();
            r.name && (a.name = o.createUniqueName(r.name)),
              O(a, r),
              r.extensions && P(n, a, r);
            const i = r.nodes || [],
              l = [];
            for (let e = 0, c = i.length; e < c; e++) l.push(k(i[e], a, s, o));
            return Promise.all(l).then(function () {
              return a;
            });
          }
        }
        function k(t, s, n, r) {
          const o = n.nodes[t];
          return r
            .getDependency("node", t)
            .then(function (t) {
              if (void 0 === o.skin) return t;
              let s;
              return r
                .getDependency("skin", o.skin)
                .then(function (e) {
                  const t = [];
                  for (let n = 0, o = (s = e).joints.length; n < o; n++)
                    t.push(r.getDependency("node", s.joints[n]));
                  return Promise.all(t);
                })
                .then(function (n) {
                  return (
                    t.traverse(function (t) {
                      if (!t.isMesh) return;
                      const r = [],
                        o = [];
                      for (let a = 0, i = n.length; a < i; a++) {
                        const t = n[a];
                        if (t) {
                          r.push(t);
                          const n = new e.Matrix4();
                          void 0 !== s.inverseBindMatrices &&
                            n.fromArray(s.inverseBindMatrices.array, 16 * a),
                            o.push(n);
                        } else
                          console.warn(
                            'THREE.GLTFLoader: Joint "%s" could not be found.',
                            s.joints[a]
                          );
                      }
                      t.bind(new e.Skeleton(r, o), t.matrixWorld);
                    }),
                    t
                  );
                });
            })
            .then(function (e) {
              s.add(e);
              const t = [];
              if (o.children) {
                const s = o.children;
                for (let o = 0, a = s.length; o < a; o++) {
                  const a = s[o];
                  t.push(k(a, e, n, r));
                }
              }
              return Promise.all(t);
            });
        }
        function B(t, s, n) {
          const r = s.attributes,
            o = new e.Box3();
          if (void 0 === r.POSITION) return;
          {
            const t = n.json.accessors[r.POSITION],
              s = t.min,
              a = t.max;
            if (void 0 === s || void 0 === a)
              return void console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
            if (
              (o.set(
                new e.Vector3(s[0], s[1], s[2]),
                new e.Vector3(a[0], a[1], a[2])
              ),
                t.normalized)
            ) {
              const e = D(S[t.componentType]);
              o.min.multiplyScalar(e), o.max.multiplyScalar(e);
            }
          }
          const a = s.targets;
          if (void 0 !== a) {
            const t = new e.Vector3(),
              s = new e.Vector3();
            for (let e = 0, r = a.length; e < r; e++) {
              const r = a[e];
              if (void 0 !== r.POSITION) {
                const e = n.json.accessors[r.POSITION],
                  o = e.min,
                  a = e.max;
                if (void 0 !== o && void 0 !== a) {
                  if (
                    (s.setX(Math.max(Math.abs(o[0]), Math.abs(a[0]))),
                      s.setY(Math.max(Math.abs(o[1]), Math.abs(a[1]))),
                      s.setZ(Math.max(Math.abs(o[2]), Math.abs(a[2]))),
                      e.normalized)
                  ) {
                    const t = D(S[e.componentType]);
                    s.multiplyScalar(t);
                  }
                  t.max(s);
                } else
                  console.warn(
                    "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                  );
              }
            }
            o.expandByVector(t);
          }
          t.boundingBox = o;
          const i = new e.Sphere();
          o.getCenter(i.center),
            (i.radius = o.min.distanceTo(o.max) / 2),
            (t.boundingSphere = i);
        }
        function j(e, t, s) {
          const n = t.attributes,
            r = [];
          function o(t, n) {
            return s.getDependency("accessor", t).then(function (t) {
              e.setAttribute(n, t);
            });
          }
          for (const a in n) {
            const t = _[a] || a.toLowerCase();
            t in e.attributes || r.push(o(n[a], t));
          }
          if (void 0 !== t.indices && !e.index) {
            const n = s.getDependency("accessor", t.indices).then(function (t) {
              e.setIndex(t);
            });
            r.push(n);
          }
          return (
            O(e, t),
            B(e, t, s),
            Promise.all(r).then(function () {
              return void 0 !== t.targets ? C(e, t.targets, s) : e;
            })
          );
        }
        function K(t, s) {
          let n = t.getIndex();
          if (null === n) {
            const e = [],
              s = t.getAttribute("position");
            if (void 0 === s)
              return (
                console.error(
                  "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                t
              );
            for (let t = 0; t < s.count; t++) e.push(t);
            t.setIndex(e), (n = t.getIndex());
          }
          const r = n.count - 2,
            o = [];
          if (s === e.TriangleFanDrawMode)
            for (let e = 1; e <= r; e++)
              o.push(n.getX(0)), o.push(n.getX(e)), o.push(n.getX(e + 1));
          else
            for (let e = 0; e < r; e++)
              e % 2 == 0
                ? (o.push(n.getX(e)),
                  o.push(n.getX(e + 1)),
                  o.push(n.getX(e + 2)))
                : (o.push(n.getX(e + 2)),
                  o.push(n.getX(e + 1)),
                  o.push(n.getX(e)));
          o.length / 3 !== r &&
            console.error(
              "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          const a = t.clone();
          return a.setIndex(o), a;
        }
      },
      { three: "gBK8" },
    ],
    FRly: [
      function (require, module, exports) {
        "use strict";
        (exports.byteLength = u),
          (exports.toByteArray = i),
          (exports.fromByteArray = d);
        for (
          var r = [],
          t = [],
          e = "undefined" != typeof Uint8Array ? Uint8Array : Array,
          n =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          o = 0,
          a = n.length;
          o < a;
          ++o
        )
          (r[o] = n[o]), (t[n.charCodeAt(o)] = o);
        function h(r) {
          var t = r.length;
          if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var e = r.indexOf("=");
          return -1 === e && (e = t), [e, e === t ? 0 : 4 - (e % 4)];
        }
        function u(r) {
          var t = h(r),
            e = t[0],
            n = t[1];
          return (3 * (e + n)) / 4 - n;
        }
        function c(r, t, e) {
          return (3 * (t + e)) / 4 - e;
        }
        function i(r) {
          var n,
            o,
            a = h(r),
            u = a[0],
            i = a[1],
            f = new e(c(r, u, i)),
            A = 0,
            d = i > 0 ? u - 4 : u;
          for (o = 0; o < d; o += 4)
            (n =
              (t[r.charCodeAt(o)] << 18) |
              (t[r.charCodeAt(o + 1)] << 12) |
              (t[r.charCodeAt(o + 2)] << 6) |
              t[r.charCodeAt(o + 3)]),
              (f[A++] = (n >> 16) & 255),
              (f[A++] = (n >> 8) & 255),
              (f[A++] = 255 & n);
          return (
            2 === i &&
            ((n = (t[r.charCodeAt(o)] << 2) | (t[r.charCodeAt(o + 1)] >> 4)),
              (f[A++] = 255 & n)),
            1 === i &&
            ((n =
              (t[r.charCodeAt(o)] << 10) |
              (t[r.charCodeAt(o + 1)] << 4) |
              (t[r.charCodeAt(o + 2)] >> 2)),
              (f[A++] = (n >> 8) & 255),
              (f[A++] = 255 & n)),
            f
          );
        }
        function f(t) {
          return (
            r[(t >> 18) & 63] + r[(t >> 12) & 63] + r[(t >> 6) & 63] + r[63 & t]
          );
        }
        function A(r, t, e) {
          for (var n, o = [], a = t; a < e; a += 3)
            (n =
              ((r[a] << 16) & 16711680) +
              ((r[a + 1] << 8) & 65280) +
              (255 & r[a + 2])),
              o.push(f(n));
          return o.join("");
        }
        function d(t) {
          for (
            var e, n = t.length, o = n % 3, a = [], h = 0, u = n - o;
            h < u;
            h += 16383
          )
            a.push(A(t, h, h + 16383 > u ? u : h + 16383));
          return (
            1 === o
              ? ((e = t[n - 1]), a.push(r[e >> 2] + r[(e << 4) & 63] + "=="))
              : 2 === o &&
              ((e = (t[n - 2] << 8) + t[n - 1]),
                a.push(r[e >> 10] + r[(e >> 4) & 63] + r[(e << 2) & 63] + "=")),
            a.join("")
          );
        }
        (t["-".charCodeAt(0)] = 62), (t["_".charCodeAt(0)] = 63);
      },
      {},
    ],
    Quj6: [
      function (require, module, exports) {
        (exports.read = function (a, o, t, r, h) {
          var M,
            p,
            w = 8 * h - r - 1,
            f = (1 << w) - 1,
            e = f >> 1,
            i = -7,
            N = t ? h - 1 : 0,
            n = t ? -1 : 1,
            s = a[o + N];
          for (
            N += n, M = s & ((1 << -i) - 1), s >>= -i, i += w;
            i > 0;
            M = 256 * M + a[o + N], N += n, i -= 8
          );
          for (
            p = M & ((1 << -i) - 1), M >>= -i, i += r;
            i > 0;
            p = 256 * p + a[o + N], N += n, i -= 8
          );
          if (0 === M) M = 1 - e;
          else {
            if (M === f) return p ? NaN : (1 / 0) * (s ? -1 : 1);
            (p += Math.pow(2, r)), (M -= e);
          }
          return (s ? -1 : 1) * p * Math.pow(2, M - r);
        }),
          (exports.write = function (a, o, t, r, h, M) {
            var p,
              w,
              f,
              e = 8 * M - h - 1,
              i = (1 << e) - 1,
              N = i >> 1,
              n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              s = r ? 0 : M - 1,
              u = r ? 1 : -1,
              l = o < 0 || (0 === o && 1 / o < 0) ? 1 : 0;
            for (
              o = Math.abs(o),
              isNaN(o) || o === 1 / 0
                ? ((w = isNaN(o) ? 1 : 0), (p = i))
                : ((p = Math.floor(Math.log(o) / Math.LN2)),
                  o * (f = Math.pow(2, -p)) < 1 && (p--, (f *= 2)),
                  (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >=
                  2 && (p++, (f /= 2)),
                  p + N >= i
                    ? ((w = 0), (p = i))
                    : p + N >= 1
                      ? ((w = (o * f - 1) * Math.pow(2, h)), (p += N))
                      : ((w = o * Math.pow(2, N - 1) * Math.pow(2, h)),
                        (p = 0)));
              h >= 8;
              a[t + s] = 255 & w, s += u, w /= 256, h -= 8
            );
            for (
              p = (p << h) | w, e += h;
              e > 0;
              a[t + s] = 255 & p, s += u, p /= 256, e -= 8
            );
            a[t + s - u] |= 128 * l;
          });
      },
      {},
    ],
    aqZJ: [
      function (require, module, exports) {
        var r = {}.toString;
        module.exports =
          Array.isArray ||
          function (t) {
            return "[object Array]" == r.call(t);
          };
      },
      {},
    ],
    aMB2: [
      function (require, module, exports) {
        var global = arguments[3];
        var t = arguments[3],
          r = require("base64-js"),
          e = require("ieee754"),
          n = require("isarray");
        function i() {
          try {
            var t = new Uint8Array(1);
            return (
              (t.__proto__ = {
                __proto__: Uint8Array.prototype,
                foo: function () {
                  return 42;
                },
              }),
              42 === t.foo() &&
              "function" == typeof t.subarray &&
              0 === t.subarray(1, 1).byteLength
            );
          } catch (r) {
            return !1;
          }
        }
        function o() {
          return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
        }
        function u(t, r) {
          if (o() < r) throw new RangeError("Invalid typed array length");
          return (
            f.TYPED_ARRAY_SUPPORT
              ? ((t = new Uint8Array(r)).__proto__ = f.prototype)
              : (null === t && (t = new f(r)), (t.length = r)),
            t
          );
        }
        function f(t, r, e) {
          if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f))
            return new f(t, r, e);
          if ("number" == typeof t) {
            if ("string" == typeof r)
              throw new Error(
                "If encoding is specified then the first argument must be a string"
              );
            return c(this, t);
          }
          return s(this, t, r, e);
        }
        function s(t, r, e, n) {
          if ("number" == typeof r)
            throw new TypeError('"value" argument must not be a number');
          return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer
            ? g(t, r, e, n)
            : "string" == typeof r
              ? l(t, r, e)
              : y(t, r);
        }
        function h(t) {
          if ("number" != typeof t)
            throw new TypeError('"size" argument must be a number');
          if (t < 0)
            throw new RangeError('"size" argument must not be negative');
        }
        function a(t, r, e, n) {
          return (
            h(r),
            r <= 0
              ? u(t, r)
              : void 0 !== e
                ? "string" == typeof n
                  ? u(t, r).fill(e, n)
                  : u(t, r).fill(e)
                : u(t, r)
          );
        }
        function c(t, r) {
          if ((h(r), (t = u(t, r < 0 ? 0 : 0 | w(r))), !f.TYPED_ARRAY_SUPPORT))
            for (var e = 0; e < r; ++e) t[e] = 0;
          return t;
        }
        function l(t, r, e) {
          if (
            (("string" == typeof e && "" !== e) || (e = "utf8"),
              !f.isEncoding(e))
          )
            throw new TypeError('"encoding" must be a valid string encoding');
          var n = 0 | v(r, e),
            i = (t = u(t, n)).write(r, e);
          return i !== n && (t = t.slice(0, i)), t;
        }
        function p(t, r) {
          var e = r.length < 0 ? 0 : 0 | w(r.length);
          t = u(t, e);
          for (var n = 0; n < e; n += 1) t[n] = 255 & r[n];
          return t;
        }
        function g(t, r, e, n) {
          if ((r.byteLength, e < 0 || r.byteLength < e))
            throw new RangeError("'offset' is out of bounds");
          if (r.byteLength < e + (n || 0))
            throw new RangeError("'length' is out of bounds");
          return (
            (r =
              void 0 === e && void 0 === n
                ? new Uint8Array(r)
                : void 0 === n
                  ? new Uint8Array(r, e)
                  : new Uint8Array(r, e, n)),
            f.TYPED_ARRAY_SUPPORT
              ? ((t = r).__proto__ = f.prototype)
              : (t = p(t, r)),
            t
          );
        }
        function y(t, r) {
          if (f.isBuffer(r)) {
            var e = 0 | w(r.length);
            return 0 === (t = u(t, e)).length ? t : (r.copy(t, 0, 0, e), t);
          }
          if (r) {
            if (
              ("undefined" != typeof ArrayBuffer &&
                r.buffer instanceof ArrayBuffer) ||
              "length" in r
            )
              return "number" != typeof r.length || W(r.length)
                ? u(t, 0)
                : p(t, r);
            if ("Buffer" === r.type && n(r.data)) return p(t, r.data);
          }
          throw new TypeError(
            "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
          );
        }
        function w(t) {
          if (t >= o())
            throw new RangeError(
              "Attempt to allocate Buffer larger than maximum size: 0x" +
              o().toString(16) +
              " bytes"
            );
          return 0 | t;
        }
        function d(t) {
          return +t != t && (t = 0), f.alloc(+t);
        }
        function v(t, r) {
          if (f.isBuffer(t)) return t.length;
          if (
            "undefined" != typeof ArrayBuffer &&
            "function" == typeof ArrayBuffer.isView &&
            (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
          )
            return t.byteLength;
          "string" != typeof t && (t = "" + t);
          var e = t.length;
          if (0 === e) return 0;
          for (var n = !1; ;)
            switch (r) {
              case "ascii":
              case "latin1":
              case "binary":
                return e;
              case "utf8":
              case "utf-8":
              case void 0:
                return $(t).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * e;
              case "hex":
                return e >>> 1;
              case "base64":
                return K(t).length;
              default:
                if (n) return $(t).length;
                (r = ("" + r).toLowerCase()), (n = !0);
            }
        }
        function E(t, r, e) {
          var n = !1;
          if (((void 0 === r || r < 0) && (r = 0), r > this.length)) return "";
          if (((void 0 === e || e > this.length) && (e = this.length), e <= 0))
            return "";
          if ((e >>>= 0) <= (r >>>= 0)) return "";
          for (t || (t = "utf8"); ;)
            switch (t) {
              case "hex":
                return x(this, r, e);
              case "utf8":
              case "utf-8":
                return Y(this, r, e);
              case "ascii":
                return L(this, r, e);
              case "latin1":
              case "binary":
                return D(this, r, e);
              case "base64":
                return S(this, r, e);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return C(this, r, e);
              default:
                if (n) throw new TypeError("Unknown encoding: " + t);
                (t = (t + "").toLowerCase()), (n = !0);
            }
        }
        function b(t, r, e) {
          var n = t[r];
          (t[r] = t[e]), (t[e] = n);
        }
        function R(t, r, e, n, i) {
          if (0 === t.length) return -1;
          if (
            ("string" == typeof e
              ? ((n = e), (e = 0))
              : e > 2147483647
                ? (e = 2147483647)
                : e < -2147483648 && (e = -2147483648),
              (e = +e),
              isNaN(e) && (e = i ? 0 : t.length - 1),
              e < 0 && (e = t.length + e),
              e >= t.length)
          ) {
            if (i) return -1;
            e = t.length - 1;
          } else if (e < 0) {
            if (!i) return -1;
            e = 0;
          }
          if (("string" == typeof r && (r = f.from(r, n)), f.isBuffer(r)))
            return 0 === r.length ? -1 : _(t, r, e, n, i);
          if ("number" == typeof r)
            return (
              (r &= 255),
              f.TYPED_ARRAY_SUPPORT &&
                "function" == typeof Uint8Array.prototype.indexOf
                ? i
                  ? Uint8Array.prototype.indexOf.call(t, r, e)
                  : Uint8Array.prototype.lastIndexOf.call(t, r, e)
                : _(t, [r], e, n, i)
            );
          throw new TypeError("val must be string, number or Buffer");
        }
        function _(t, r, e, n, i) {
          var o,
            u = 1,
            f = t.length,
            s = r.length;
          if (
            void 0 !== n &&
            ("ucs2" === (n = String(n).toLowerCase()) ||
              "ucs-2" === n ||
              "utf16le" === n ||
              "utf-16le" === n)
          ) {
            if (t.length < 2 || r.length < 2) return -1;
            (u = 2), (f /= 2), (s /= 2), (e /= 2);
          }
          function h(t, r) {
            return 1 === u ? t[r] : t.readUInt16BE(r * u);
          }
          if (i) {
            var a = -1;
            for (o = e; o < f; o++)
              if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                if ((-1 === a && (a = o), o - a + 1 === s)) return a * u;
              } else -1 !== a && (o -= o - a), (a = -1);
          } else
            for (e + s > f && (e = f - s), o = e; o >= 0; o--) {
              for (var c = !0, l = 0; l < s; l++)
                if (h(t, o + l) !== h(r, l)) {
                  c = !1;
                  break;
                }
              if (c) return o;
            }
          return -1;
        }
        function A(t, r, e, n) {
          e = Number(e) || 0;
          var i = t.length - e;
          n ? (n = Number(n)) > i && (n = i) : (n = i);
          var o = r.length;
          if (o % 2 != 0) throw new TypeError("Invalid hex string");
          n > o / 2 && (n = o / 2);
          for (var u = 0; u < n; ++u) {
            var f = parseInt(r.substr(2 * u, 2), 16);
            if (isNaN(f)) return u;
            t[e + u] = f;
          }
          return u;
        }
        function m(t, r, e, n) {
          return Q($(r, t.length - e), t, e, n);
        }
        function P(t, r, e, n) {
          return Q(G(r), t, e, n);
        }
        function T(t, r, e, n) {
          return P(t, r, e, n);
        }
        function B(t, r, e, n) {
          return Q(K(r), t, e, n);
        }
        function U(t, r, e, n) {
          return Q(H(r, t.length - e), t, e, n);
        }
        function S(t, e, n) {
          return 0 === e && n === t.length
            ? r.fromByteArray(t)
            : r.fromByteArray(t.slice(e, n));
        }
        function Y(t, r, e) {
          e = Math.min(t.length, e);
          for (var n = [], i = r; i < e;) {
            var o,
              u,
              f,
              s,
              h = t[i],
              a = null,
              c = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
            if (i + c <= e)
              switch (c) {
                case 1:
                  h < 128 && (a = h);
                  break;
                case 2:
                  128 == (192 & (o = t[i + 1])) &&
                    (s = ((31 & h) << 6) | (63 & o)) > 127 &&
                    (a = s);
                  break;
                case 3:
                  (o = t[i + 1]),
                    (u = t[i + 2]),
                    128 == (192 & o) &&
                    128 == (192 & u) &&
                    (s = ((15 & h) << 12) | ((63 & o) << 6) | (63 & u)) >
                    2047 &&
                    (s < 55296 || s > 57343) &&
                    (a = s);
                  break;
                case 4:
                  (o = t[i + 1]),
                    (u = t[i + 2]),
                    (f = t[i + 3]),
                    128 == (192 & o) &&
                    128 == (192 & u) &&
                    128 == (192 & f) &&
                    (s =
                      ((15 & h) << 18) |
                      ((63 & o) << 12) |
                      ((63 & u) << 6) |
                      (63 & f)) > 65535 &&
                    s < 1114112 &&
                    (a = s);
              }
            null === a
              ? ((a = 65533), (c = 1))
              : a > 65535 &&
              ((a -= 65536),
                n.push(((a >>> 10) & 1023) | 55296),
                (a = 56320 | (1023 & a))),
              n.push(a),
              (i += c);
          }
          return O(n);
        }
        (exports.Buffer = f),
          (exports.SlowBuffer = d),
          (exports.INSPECT_MAX_BYTES = 50),
          (f.TYPED_ARRAY_SUPPORT =
            void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : i()),
          (exports.kMaxLength = o()),
          (f.poolSize = 8192),
          (f._augment = function (t) {
            return (t.__proto__ = f.prototype), t;
          }),
          (f.from = function (t, r, e) {
            return s(null, t, r, e);
          }),
          f.TYPED_ARRAY_SUPPORT &&
          ((f.prototype.__proto__ = Uint8Array.prototype),
            (f.__proto__ = Uint8Array),
            "undefined" != typeof Symbol &&
            Symbol.species &&
            f[Symbol.species] === f &&
            Object.defineProperty(f, Symbol.species, {
              value: null,
              configurable: !0,
            })),
          (f.alloc = function (t, r, e) {
            return a(null, t, r, e);
          }),
          (f.allocUnsafe = function (t) {
            return c(null, t);
          }),
          (f.allocUnsafeSlow = function (t) {
            return c(null, t);
          }),
          (f.isBuffer = function (t) {
            return !(null == t || !t._isBuffer);
          }),
          (f.compare = function (t, r) {
            if (!f.isBuffer(t) || !f.isBuffer(r))
              throw new TypeError("Arguments must be Buffers");
            if (t === r) return 0;
            for (
              var e = t.length, n = r.length, i = 0, o = Math.min(e, n);
              i < o;
              ++i
            )
              if (t[i] !== r[i]) {
                (e = t[i]), (n = r[i]);
                break;
              }
            return e < n ? -1 : n < e ? 1 : 0;
          }),
          (f.isEncoding = function (t) {
            switch (String(t).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }),
          (f.concat = function (t, r) {
            if (!n(t))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            if (0 === t.length) return f.alloc(0);
            var e;
            if (void 0 === r)
              for (r = 0, e = 0; e < t.length; ++e) r += t[e].length;
            var i = f.allocUnsafe(r),
              o = 0;
            for (e = 0; e < t.length; ++e) {
              var u = t[e];
              if (!f.isBuffer(u))
                throw new TypeError(
                  '"list" argument must be an Array of Buffers'
                );
              u.copy(i, o), (o += u.length);
            }
            return i;
          }),
          (f.byteLength = v),
          (f.prototype._isBuffer = !0),
          (f.prototype.swap16 = function () {
            var t = this.length;
            if (t % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var r = 0; r < t; r += 2) b(this, r, r + 1);
            return this;
          }),
          (f.prototype.swap32 = function () {
            var t = this.length;
            if (t % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var r = 0; r < t; r += 4)
              b(this, r, r + 3), b(this, r + 1, r + 2);
            return this;
          }),
          (f.prototype.swap64 = function () {
            var t = this.length;
            if (t % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var r = 0; r < t; r += 8)
              b(this, r, r + 7),
                b(this, r + 1, r + 6),
                b(this, r + 2, r + 5),
                b(this, r + 3, r + 4);
            return this;
          }),
          (f.prototype.toString = function () {
            var t = 0 | this.length;
            return 0 === t
              ? ""
              : 0 === arguments.length
                ? Y(this, 0, t)
                : E.apply(this, arguments);
          }),
          (f.prototype.equals = function (t) {
            if (!f.isBuffer(t))
              throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === f.compare(this, t);
          }),
          (f.prototype.inspect = function () {
            var t = "",
              r = exports.INSPECT_MAX_BYTES;
            return (
              this.length > 0 &&
              ((t = this.toString("hex", 0, r).match(/.{2}/g).join(" ")),
                this.length > r && (t += " ... ")),
              "<Buffer " + t + ">"
            );
          }),
          (f.prototype.compare = function (t, r, e, n, i) {
            if (!f.isBuffer(t))
              throw new TypeError("Argument must be a Buffer");
            if (
              (void 0 === r && (r = 0),
                void 0 === e && (e = t ? t.length : 0),
                void 0 === n && (n = 0),
                void 0 === i && (i = this.length),
                r < 0 || e > t.length || n < 0 || i > this.length)
            )
              throw new RangeError("out of range index");
            if (n >= i && r >= e) return 0;
            if (n >= i) return -1;
            if (r >= e) return 1;
            if (this === t) return 0;
            for (
              var o = (i >>>= 0) - (n >>>= 0),
              u = (e >>>= 0) - (r >>>= 0),
              s = Math.min(o, u),
              h = this.slice(n, i),
              a = t.slice(r, e),
              c = 0;
              c < s;
              ++c
            )
              if (h[c] !== a[c]) {
                (o = h[c]), (u = a[c]);
                break;
              }
            return o < u ? -1 : u < o ? 1 : 0;
          }),
          (f.prototype.includes = function (t, r, e) {
            return -1 !== this.indexOf(t, r, e);
          }),
          (f.prototype.indexOf = function (t, r, e) {
            return R(this, t, r, e, !0);
          }),
          (f.prototype.lastIndexOf = function (t, r, e) {
            return R(this, t, r, e, !1);
          }),
          (f.prototype.write = function (t, r, e, n) {
            if (void 0 === r) (n = "utf8"), (e = this.length), (r = 0);
            else if (void 0 === e && "string" == typeof r)
              (n = r), (e = this.length), (r = 0);
            else {
              if (!isFinite(r))
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              (r |= 0),
                isFinite(e)
                  ? ((e |= 0), void 0 === n && (n = "utf8"))
                  : ((n = e), (e = void 0));
            }
            var i = this.length - r;
            if (
              ((void 0 === e || e > i) && (e = i),
                (t.length > 0 && (e < 0 || r < 0)) || r > this.length)
            )
              throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            for (var o = !1; ;)
              switch (n) {
                case "hex":
                  return A(this, t, r, e);
                case "utf8":
                case "utf-8":
                  return m(this, t, r, e);
                case "ascii":
                  return P(this, t, r, e);
                case "latin1":
                case "binary":
                  return T(this, t, r, e);
                case "base64":
                  return B(this, t, r, e);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return U(this, t, r, e);
                default:
                  if (o) throw new TypeError("Unknown encoding: " + n);
                  (n = ("" + n).toLowerCase()), (o = !0);
              }
          }),
          (f.prototype.toJSON = function () {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0),
            };
          });
        var I = 4096;
        function O(t) {
          var r = t.length;
          if (r <= I) return String.fromCharCode.apply(String, t);
          for (var e = "", n = 0; n < r;)
            e += String.fromCharCode.apply(String, t.slice(n, (n += I)));
          return e;
        }
        function L(t, r, e) {
          var n = "";
          e = Math.min(t.length, e);
          for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
          return n;
        }
        function D(t, r, e) {
          var n = "";
          e = Math.min(t.length, e);
          for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
          return n;
        }
        function x(t, r, e) {
          var n = t.length;
          (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
          for (var i = "", o = r; o < e; ++o) i += Z(t[o]);
          return i;
        }
        function C(t, r, e) {
          for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2)
            i += String.fromCharCode(n[o] + 256 * n[o + 1]);
          return i;
        }
        function M(t, r, e) {
          if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
          if (t + r > e)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function k(t, r, e, n, i, o) {
          if (!f.isBuffer(t))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (r > i || r < o)
            throw new RangeError('"value" argument is out of bounds');
          if (e + n > t.length) throw new RangeError("Index out of range");
        }
        function N(t, r, e, n) {
          r < 0 && (r = 65535 + r + 1);
          for (var i = 0, o = Math.min(t.length - e, 2); i < o; ++i)
            t[e + i] =
              (r & (255 << (8 * (n ? i : 1 - i)))) >>> (8 * (n ? i : 1 - i));
        }
        function z(t, r, e, n) {
          r < 0 && (r = 4294967295 + r + 1);
          for (var i = 0, o = Math.min(t.length - e, 4); i < o; ++i)
            t[e + i] = (r >>> (8 * (n ? i : 3 - i))) & 255;
        }
        function F(t, r, e, n, i, o) {
          if (e + n > t.length) throw new RangeError("Index out of range");
          if (e < 0) throw new RangeError("Index out of range");
        }
        function j(t, r, n, i, o) {
          return (
            o || F(t, r, n, 4, 3.4028234663852886e38, -3.4028234663852886e38),
            e.write(t, r, n, i, 23, 4),
            n + 4
          );
        }
        function q(t, r, n, i, o) {
          return (
            o || F(t, r, n, 8, 1.7976931348623157e308, -1.7976931348623157e308),
            e.write(t, r, n, i, 52, 8),
            n + 8
          );
        }
        (f.prototype.slice = function (t, r) {
          var e,
            n = this.length;
          if (
            ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
              (r = void 0 === r ? n : ~~r) < 0
                ? (r += n) < 0 && (r = 0)
                : r > n && (r = n),
              r < t && (r = t),
              f.TYPED_ARRAY_SUPPORT)
          )
            (e = this.subarray(t, r)).__proto__ = f.prototype;
          else {
            var i = r - t;
            e = new f(i, void 0);
            for (var o = 0; o < i; ++o) e[o] = this[o + t];
          }
          return e;
        }),
          (f.prototype.readUIntLE = function (t, r, e) {
            (t |= 0), (r |= 0), e || M(t, r, this.length);
            for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
              n += this[t + o] * i;
            return n;
          }),
          (f.prototype.readUIntBE = function (t, r, e) {
            (t |= 0), (r |= 0), e || M(t, r, this.length);
            for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);)
              n += this[t + --r] * i;
            return n;
          }),
          (f.prototype.readUInt8 = function (t, r) {
            return r || M(t, 1, this.length), this[t];
          }),
          (f.prototype.readUInt16LE = function (t, r) {
            return r || M(t, 2, this.length), this[t] | (this[t + 1] << 8);
          }),
          (f.prototype.readUInt16BE = function (t, r) {
            return r || M(t, 2, this.length), (this[t] << 8) | this[t + 1];
          }),
          (f.prototype.readUInt32LE = function (t, r) {
            return (
              r || M(t, 4, this.length),
              (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
            );
          }),
          (f.prototype.readUInt32BE = function (t, r) {
            return (
              r || M(t, 4, this.length),
              16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
            );
          }),
          (f.prototype.readIntLE = function (t, r, e) {
            (t |= 0), (r |= 0), e || M(t, r, this.length);
            for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
              n += this[t + o] * i;
            return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n;
          }),
          (f.prototype.readIntBE = function (t, r, e) {
            (t |= 0), (r |= 0), e || M(t, r, this.length);
            for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)
              o += this[t + --n] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o;
          }),
          (f.prototype.readInt8 = function (t, r) {
            return (
              r || M(t, 1, this.length),
              128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
            );
          }),
          (f.prototype.readInt16LE = function (t, r) {
            r || M(t, 2, this.length);
            var e = this[t] | (this[t + 1] << 8);
            return 32768 & e ? 4294901760 | e : e;
          }),
          (f.prototype.readInt16BE = function (t, r) {
            r || M(t, 2, this.length);
            var e = this[t + 1] | (this[t] << 8);
            return 32768 & e ? 4294901760 | e : e;
          }),
          (f.prototype.readInt32LE = function (t, r) {
            return (
              r || M(t, 4, this.length),
              this[t] |
              (this[t + 1] << 8) |
              (this[t + 2] << 16) |
              (this[t + 3] << 24)
            );
          }),
          (f.prototype.readInt32BE = function (t, r) {
            return (
              r || M(t, 4, this.length),
              (this[t] << 24) |
              (this[t + 1] << 16) |
              (this[t + 2] << 8) |
              this[t + 3]
            );
          }),
          (f.prototype.readFloatLE = function (t, r) {
            return r || M(t, 4, this.length), e.read(this, t, !0, 23, 4);
          }),
          (f.prototype.readFloatBE = function (t, r) {
            return r || M(t, 4, this.length), e.read(this, t, !1, 23, 4);
          }),
          (f.prototype.readDoubleLE = function (t, r) {
            return r || M(t, 8, this.length), e.read(this, t, !0, 52, 8);
          }),
          (f.prototype.readDoubleBE = function (t, r) {
            return r || M(t, 8, this.length), e.read(this, t, !1, 52, 8);
          }),
          (f.prototype.writeUIntLE = function (t, r, e, n) {
            ((t = +t), (r |= 0), (e |= 0), n) ||
              k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
            var i = 1,
              o = 0;
            for (this[r] = 255 & t; ++o < e && (i *= 256);)
              this[r + o] = (t / i) & 255;
            return r + e;
          }),
          (f.prototype.writeUIntBE = function (t, r, e, n) {
            ((t = +t), (r |= 0), (e |= 0), n) ||
              k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
            var i = e - 1,
              o = 1;
            for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);)
              this[r + i] = (t / o) & 255;
            return r + e;
          }),
          (f.prototype.writeUInt8 = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 1, 255, 0),
              f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
              (this[r] = 255 & t),
              r + 1
            );
          }),
          (f.prototype.writeUInt16LE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 2, 65535, 0),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = 255 & t), (this[r + 1] = t >>> 8))
                : N(this, t, r, !0),
              r + 2
            );
          }),
          (f.prototype.writeUInt16BE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 2, 65535, 0),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = t >>> 8), (this[r + 1] = 255 & t))
                : N(this, t, r, !1),
              r + 2
            );
          }),
          (f.prototype.writeUInt32LE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 4, 4294967295, 0),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r + 3] = t >>> 24),
                  (this[r + 2] = t >>> 16),
                  (this[r + 1] = t >>> 8),
                  (this[r] = 255 & t))
                : z(this, t, r, !0),
              r + 4
            );
          }),
          (f.prototype.writeUInt32BE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 4, 4294967295, 0),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = t >>> 24),
                  (this[r + 1] = t >>> 16),
                  (this[r + 2] = t >>> 8),
                  (this[r + 3] = 255 & t))
                : z(this, t, r, !1),
              r + 4
            );
          }),
          (f.prototype.writeIntLE = function (t, r, e, n) {
            if (((t = +t), (r |= 0), !n)) {
              var i = Math.pow(2, 8 * e - 1);
              k(this, t, r, e, i - 1, -i);
            }
            var o = 0,
              u = 1,
              f = 0;
            for (this[r] = 255 & t; ++o < e && (u *= 256);)
              t < 0 && 0 === f && 0 !== this[r + o - 1] && (f = 1),
                (this[r + o] = (((t / u) >> 0) - f) & 255);
            return r + e;
          }),
          (f.prototype.writeIntBE = function (t, r, e, n) {
            if (((t = +t), (r |= 0), !n)) {
              var i = Math.pow(2, 8 * e - 1);
              k(this, t, r, e, i - 1, -i);
            }
            var o = e - 1,
              u = 1,
              f = 0;
            for (this[r + o] = 255 & t; --o >= 0 && (u *= 256);)
              t < 0 && 0 === f && 0 !== this[r + o + 1] && (f = 1),
                (this[r + o] = (((t / u) >> 0) - f) & 255);
            return r + e;
          }),
          (f.prototype.writeInt8 = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 1, 127, -128),
              f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
              t < 0 && (t = 255 + t + 1),
              (this[r] = 255 & t),
              r + 1
            );
          }),
          (f.prototype.writeInt16LE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 2, 32767, -32768),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = 255 & t), (this[r + 1] = t >>> 8))
                : N(this, t, r, !0),
              r + 2
            );
          }),
          (f.prototype.writeInt16BE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 2, 32767, -32768),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = t >>> 8), (this[r + 1] = 255 & t))
                : N(this, t, r, !1),
              r + 2
            );
          }),
          (f.prototype.writeInt32LE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 4, 2147483647, -2147483648),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = 255 & t),
                  (this[r + 1] = t >>> 8),
                  (this[r + 2] = t >>> 16),
                  (this[r + 3] = t >>> 24))
                : z(this, t, r, !0),
              r + 4
            );
          }),
          (f.prototype.writeInt32BE = function (t, r, e) {
            return (
              (t = +t),
              (r |= 0),
              e || k(this, t, r, 4, 2147483647, -2147483648),
              t < 0 && (t = 4294967295 + t + 1),
              f.TYPED_ARRAY_SUPPORT
                ? ((this[r] = t >>> 24),
                  (this[r + 1] = t >>> 16),
                  (this[r + 2] = t >>> 8),
                  (this[r + 3] = 255 & t))
                : z(this, t, r, !1),
              r + 4
            );
          }),
          (f.prototype.writeFloatLE = function (t, r, e) {
            return j(this, t, r, !0, e);
          }),
          (f.prototype.writeFloatBE = function (t, r, e) {
            return j(this, t, r, !1, e);
          }),
          (f.prototype.writeDoubleLE = function (t, r, e) {
            return q(this, t, r, !0, e);
          }),
          (f.prototype.writeDoubleBE = function (t, r, e) {
            return q(this, t, r, !1, e);
          }),
          (f.prototype.copy = function (t, r, e, n) {
            if (
              (e || (e = 0),
                n || 0 === n || (n = this.length),
                r >= t.length && (r = t.length),
                r || (r = 0),
                n > 0 && n < e && (n = e),
                n === e)
            )
              return 0;
            if (0 === t.length || 0 === this.length) return 0;
            if (r < 0) throw new RangeError("targetStart out of bounds");
            if (e < 0 || e >= this.length)
              throw new RangeError("sourceStart out of bounds");
            if (n < 0) throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length),
              t.length - r < n - e && (n = t.length - r + e);
            var i,
              o = n - e;
            if (this === t && e < r && r < n)
              for (i = o - 1; i >= 0; --i) t[i + r] = this[i + e];
            else if (o < 1e3 || !f.TYPED_ARRAY_SUPPORT)
              for (i = 0; i < o; ++i) t[i + r] = this[i + e];
            else Uint8Array.prototype.set.call(t, this.subarray(e, e + o), r);
            return o;
          }),
          (f.prototype.fill = function (t, r, e, n) {
            if ("string" == typeof t) {
              if (
                ("string" == typeof r
                  ? ((n = r), (r = 0), (e = this.length))
                  : "string" == typeof e && ((n = e), (e = this.length)),
                  1 === t.length)
              ) {
                var i = t.charCodeAt(0);
                i < 256 && (t = i);
              }
              if (void 0 !== n && "string" != typeof n)
                throw new TypeError("encoding must be a string");
              if ("string" == typeof n && !f.isEncoding(n))
                throw new TypeError("Unknown encoding: " + n);
            } else "number" == typeof t && (t &= 255);
            if (r < 0 || this.length < r || this.length < e)
              throw new RangeError("Out of range index");
            if (e <= r) return this;
            var o;
            if (
              ((r >>>= 0),
                (e = void 0 === e ? this.length : e >>> 0),
                t || (t = 0),
                "number" == typeof t)
            )
              for (o = r; o < e; ++o) this[o] = t;
            else {
              var u = f.isBuffer(t) ? t : $(new f(t, n).toString()),
                s = u.length;
              for (o = 0; o < e - r; ++o) this[o + r] = u[o % s];
            }
            return this;
          });
        var V = /[^+\/0-9A-Za-z-_]/g;
        function X(t) {
          if ((t = J(t).replace(V, "")).length < 2) return "";
          for (; t.length % 4 != 0;) t += "=";
          return t;
        }
        function J(t) {
          return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
        }
        function Z(t) {
          return t < 16 ? "0" + t.toString(16) : t.toString(16);
        }
        function $(t, r) {
          var e;
          r = r || 1 / 0;
          for (var n = t.length, i = null, o = [], u = 0; u < n; ++u) {
            if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
              if (!i) {
                if (e > 56319) {
                  (r -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                if (u + 1 === n) {
                  (r -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                i = e;
                continue;
              }
              if (e < 56320) {
                (r -= 3) > -1 && o.push(239, 191, 189), (i = e);
                continue;
              }
              e = 65536 + (((i - 55296) << 10) | (e - 56320));
            } else i && (r -= 3) > -1 && o.push(239, 191, 189);
            if (((i = null), e < 128)) {
              if ((r -= 1) < 0) break;
              o.push(e);
            } else if (e < 2048) {
              if ((r -= 2) < 0) break;
              o.push((e >> 6) | 192, (63 & e) | 128);
            } else if (e < 65536) {
              if ((r -= 3) < 0) break;
              o.push((e >> 12) | 224, ((e >> 6) & 63) | 128, (63 & e) | 128);
            } else {
              if (!(e < 1114112)) throw new Error("Invalid code point");
              if ((r -= 4) < 0) break;
              o.push(
                (e >> 18) | 240,
                ((e >> 12) & 63) | 128,
                ((e >> 6) & 63) | 128,
                (63 & e) | 128
              );
            }
          }
          return o;
        }
        function G(t) {
          for (var r = [], e = 0; e < t.length; ++e)
            r.push(255 & t.charCodeAt(e));
          return r;
        }
        function H(t, r) {
          for (var e, n, i, o = [], u = 0; u < t.length && !((r -= 2) < 0); ++u)
            (n = (e = t.charCodeAt(u)) >> 8),
              (i = e % 256),
              o.push(i),
              o.push(n);
          return o;
        }
        function K(t) {
          return r.toByteArray(X(t));
        }
        function Q(t, r, e, n) {
          for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)
            r[i + e] = t[i];
          return i;
        }
        function W(t) {
          return t != t;
        }
      },
      { "base64-js": "FRly", ieee754: "Quj6", isarray: "aqZJ", buffer: "aMB2" },
    ],
    GX3I: [
      function (require, module, exports) {
        var Buffer = require("buffer").Buffer;
        var t = require("buffer").Buffer;
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.KTX2Transfer =
            exports.KTX2SupercompressionScheme =
            exports.KTX2Primaries =
            exports.KTX2Model =
            exports.KTX2Flags =
            exports.KTX2DescriptorType =
            exports.KTX2Container =
            exports.KTX2ChannelUASTC =
            exports.KTX2ChannelETC1S =
            void 0),
          (exports.read = g),
          (exports.write = D);
        const e = new Uint8Array([0]),
          n = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
        var i, s, r, o, a, l, f, U;
        (exports.KTX2ChannelUASTC = U),
          (exports.KTX2ChannelETC1S = f),
          (exports.KTX2Flags = l),
          (exports.KTX2Transfer = a),
          (exports.KTX2Primaries = o),
          (exports.KTX2Model = r),
          (exports.KTX2DescriptorType = s),
          (exports.KTX2SupercompressionScheme = i),
          (function (t) {
            (t[(t.NONE = 0)] = "NONE"),
              (t[(t.BASISLZ = 1)] = "BASISLZ"),
              (t[(t.ZSTD = 2)] = "ZSTD"),
              (t[(t.ZLIB = 3)] = "ZLIB");
          })(i || (exports.KTX2SupercompressionScheme = i = {})),
          (function (t) {
            t[(t.BASICFORMAT = 0)] = "BASICFORMAT";
          })(s || (exports.KTX2DescriptorType = s = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"),
              (t[(t.ETC1S = 163)] = "ETC1S"),
              (t[(t.UASTC = 166)] = "UASTC");
          })(r || (exports.KTX2Model = r = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"),
              (t[(t.SRGB = 1)] = "SRGB");
          })(o || (exports.KTX2Primaries = o = {})),
          (function (t) {
            (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"),
              (t[(t.LINEAR = 1)] = "LINEAR"),
              (t[(t.SRGB = 2)] = "SRGB"),
              (t[(t.ITU = 3)] = "ITU"),
              (t[(t.NTSC = 4)] = "NTSC"),
              (t[(t.SLOG = 5)] = "SLOG"),
              (t[(t.SLOG2 = 6)] = "SLOG2");
          })(a || (exports.KTX2Transfer = a = {})),
          (function (t) {
            (t[(t.ALPHA_STRAIGHT = 0)] = "ALPHA_STRAIGHT"),
              (t[(t.ALPHA_PREMULTIPLIED = 1)] = "ALPHA_PREMULTIPLIED");
          })(l || (exports.KTX2Flags = l = {})),
          (function (t) {
            (t[(t.RGB = 0)] = "RGB"),
              (t[(t.RRR = 3)] = "RRR"),
              (t[(t.GGG = 4)] = "GGG"),
              (t[(t.AAA = 15)] = "AAA");
          })(f || (exports.KTX2ChannelETC1S = f = {})),
          (function (t) {
            (t[(t.RGB = 0)] = "RGB"),
              (t[(t.RGBA = 3)] = "RGBA"),
              (t[(t.RRR = 4)] = "RRR"),
              (t[(t.RRRG = 5)] = "RRRG");
          })(U || (exports.KTX2ChannelUASTC = U = {}));
        class c {
          constructor() {
            (this.vkFormat = 0),
              (this.typeSize = 1),
              (this.pixelWidth = 0),
              (this.pixelHeight = 0),
              (this.pixelDepth = 0),
              (this.layerCount = 0),
              (this.faceCount = 1),
              (this.supercompressionScheme = i.NONE),
              (this.levels = []),
              (this.dataFormatDescriptor = [
                {
                  vendorId: 0,
                  descriptorType: s.BASICFORMAT,
                  versionNumber: 2,
                  descriptorBlockSize: 40,
                  colorModel: r.UNSPECIFIED,
                  colorPrimaries: o.SRGB,
                  transferFunction: o.SRGB,
                  flags: l.ALPHA_STRAIGHT,
                  texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 },
                  bytesPlane: [],
                  samples: [],
                },
              ]),
              (this.keyValue = {}),
              (this.globalData = null);
          }
        }
        exports.KTX2Container = c;
        class p {
          constructor(t, e, n, i) {
            (this._dataView = new DataView(t.buffer, t.byteOffset + e, n)),
              (this._littleEndian = i),
              (this._offset = 0);
          }
          _nextUint8() {
            const t = this._dataView.getUint8(this._offset);
            return (this._offset += 1), t;
          }
          _nextUint16() {
            const t = this._dataView.getUint16(
              this._offset,
              this._littleEndian
            );
            return (this._offset += 2), t;
          }
          _nextUint32() {
            const t = this._dataView.getUint32(
              this._offset,
              this._littleEndian
            );
            return (this._offset += 4), t;
          }
          _nextUint64() {
            const t =
              this._dataView.getUint32(this._offset, this._littleEndian) +
              2 ** 32 *
              this._dataView.getUint32(this._offset + 4, this._littleEndian);
            return (this._offset += 8), t;
          }
          _skip(t) {
            return (this._offset += t), this;
          }
          _scan(t, e = 0) {
            const n = this._offset;
            let i = 0;
            for (; this._dataView.getUint8(this._offset) !== e && i < t;)
              i++, this._offset++;
            return (
              i < t && this._offset++,
              new Uint8Array(
                this._dataView.buffer,
                this._dataView.byteOffset + n,
                i
              )
            );
          }
        }
        function h(e) {
          return "undefined" != typeof TextEncoder
            ? new TextEncoder().encode(e)
            : t.from(e);
        }
        function x(e) {
          return "undefined" != typeof TextDecoder
            ? new TextDecoder().decode(e)
            : t.from(e).toString("utf8");
        }
        function _(t) {
          let e = 0;
          for (const s of t) e += s.byteLength;
          const n = new Uint8Array(e);
          let i = 0;
          for (const s of t) n.set(new Uint8Array(s), i), (i += s.byteLength);
          return n;
        }
        function g(t) {
          const e = new Uint8Array(t.buffer, t.byteOffset, n.length);
          if (
            e[0] !== n[0] ||
            e[1] !== n[1] ||
            e[2] !== n[2] ||
            e[3] !== n[3] ||
            e[4] !== n[4] ||
            e[5] !== n[5] ||
            e[6] !== n[6] ||
            e[7] !== n[7] ||
            e[8] !== n[8] ||
            e[9] !== n[9] ||
            e[10] !== n[10] ||
            e[11] !== n[11]
          )
            throw new Error("Missing KTX 2.0 identifier.");
          const i = new c(),
            s = 17 * Uint32Array.BYTES_PER_ELEMENT,
            r = new p(t, n.length, s, !0);
          (i.vkFormat = r._nextUint32()),
            (i.typeSize = r._nextUint32()),
            (i.pixelWidth = r._nextUint32()),
            (i.pixelHeight = r._nextUint32()),
            (i.pixelDepth = r._nextUint32()),
            (i.layerCount = r._nextUint32()),
            (i.faceCount = r._nextUint32());
          const o = r._nextUint32();
          i.supercompressionScheme = r._nextUint32();
          const a = r._nextUint32(),
            l = r._nextUint32(),
            f = r._nextUint32(),
            U = r._nextUint32(),
            h = r._nextUint64(),
            _ = r._nextUint64(),
            g = new p(t, n.length + s, 3 * o * 8, !0);
          for (let n = 0; n < o; n++)
            i.levels.push({
              levelData: new Uint8Array(
                t.buffer,
                t.byteOffset + g._nextUint64(),
                g._nextUint64()
              ),
              uncompressedByteLength: g._nextUint64(),
            });
          const u = new p(t, a, l, !0),
            y = {
              vendorId: u._skip(4)._nextUint16(),
              descriptorType: u._nextUint16(),
              versionNumber: u._nextUint16(),
              descriptorBlockSize: u._nextUint16(),
              colorModel: u._nextUint8(),
              colorPrimaries: u._nextUint8(),
              transferFunction: u._nextUint8(),
              flags: u._nextUint8(),
              texelBlockDimension: {
                x: u._nextUint8() + 1,
                y: u._nextUint8() + 1,
                z: u._nextUint8() + 1,
                w: u._nextUint8() + 1,
              },
              bytesPlane: [
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
              ],
              samples: [],
            },
            D = (y.descriptorBlockSize / 4 - 6) / 4;
          for (let n = 0; n < D; n++)
            y.samples[n] = {
              bitOffset: u._nextUint16(),
              bitLength: u._nextUint8(),
              channelID: u._nextUint8(),
              samplePosition: [
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
                u._nextUint8(),
              ],
              sampleLower: u._nextUint32(),
              sampleUpper: u._nextUint32(),
            };
          (i.dataFormatDescriptor.length = 0), i.dataFormatDescriptor.push(y);
          const T = new p(t, f, U, !0);
          for (; T._offset < U;) {
            const t = T._nextUint32(),
              e = T._scan(t),
              n = x(e),
              s = T._scan(t - e.byteLength);
            (i.keyValue[n] = n.match(/^ktx/i) ? x(s) : s),
              T._offset % 4 && T._skip(4 - (T._offset % 4));
          }
          if (_ <= 0) return i;
          const b = new p(t, h, _, !0),
            d = b._nextUint16(),
            S = b._nextUint16(),
            m = b._nextUint32(),
            A = b._nextUint32(),
            w = b._nextUint32(),
            B = b._nextUint32(),
            L = [];
          for (let n = 0; n < o; n++)
            L.push({
              imageFlags: b._nextUint32(),
              rgbSliceByteOffset: b._nextUint32(),
              rgbSliceByteLength: b._nextUint32(),
              alphaSliceByteOffset: b._nextUint32(),
              alphaSliceByteLength: b._nextUint32(),
            });
          const I = h + b._offset,
            R = I + m,
            C = R + A,
            E = C + w,
            P = new Uint8Array(t.buffer, t.byteOffset + I, m),
            O = new Uint8Array(t.buffer, t.byteOffset + R, A),
            F = new Uint8Array(t.buffer, t.byteOffset + C, w),
            K = new Uint8Array(t.buffer, t.byteOffset + E, B);
          return (
            (i.globalData = {
              endpointCount: d,
              selectorCount: S,
              imageDescs: L,
              endpointsData: P,
              selectorsData: O,
              tablesData: F,
              extendedData: K,
            }),
            i
          );
        }
        function u() {
          return (u =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var i in n)
                  Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
              }
              return t;
            }).apply(this, arguments);
        }
        const y = { keepWriter: !1 };
        function D(t, i = {}) {
          i = u({}, y, i);
          let r = new ArrayBuffer(0);
          if (t.globalData) {
            const e = new ArrayBuffer(
              20 + 5 * t.globalData.imageDescs.length * 4
            ),
              n = new DataView(e);
            n.setUint16(0, t.globalData.endpointCount, !0),
              n.setUint16(2, t.globalData.selectorCount, !0),
              n.setUint32(4, t.globalData.endpointsData.byteLength, !0),
              n.setUint32(8, t.globalData.selectorsData.byteLength, !0),
              n.setUint32(12, t.globalData.tablesData.byteLength, !0),
              n.setUint32(16, t.globalData.extendedData.byteLength, !0);
            for (let i = 0; i < t.globalData.imageDescs.length; i++) {
              const e = t.globalData.imageDescs[i];
              n.setUint32(20 + 5 * i * 4 + 0, e.imageFlags, !0),
                n.setUint32(20 + 5 * i * 4 + 4, e.rgbSliceByteOffset, !0),
                n.setUint32(20 + 5 * i * 4 + 8, e.rgbSliceByteLength, !0),
                n.setUint32(20 + 5 * i * 4 + 12, e.alphaSliceByteOffset, !0),
                n.setUint32(20 + 5 * i * 4 + 16, e.alphaSliceByteLength, !0);
            }
            r = _([
              e,
              t.globalData.endpointsData,
              t.globalData.selectorsData,
              t.globalData.tablesData,
              t.globalData.extendedData,
            ]);
          }
          const o = [];
          let a = t.keyValue;
          i.keepWriter ||
            (a = u({}, t.keyValue, { KTXwriter: "KTX-Parse v0.2.1" }));
          for (const n in a) {
            const t = a[n],
              i = h(n),
              s = "string" == typeof t ? h(t) : t,
              r = i.byteLength + 1 + s.byteLength + 1,
              l = r % 4 ? 4 - (r % 4) : 0;
            o.push(
              _([new Uint32Array([r]), i, e, s, e, new Uint8Array(l).fill(0)])
            );
          }
          const l = _(o),
            f = new ArrayBuffer(44),
            U = new DataView(f);
          if (
            1 !== t.dataFormatDescriptor.length ||
            t.dataFormatDescriptor[0].descriptorType !== s.BASICFORMAT
          )
            throw new Error(
              "Only BASICFORMAT Data Format Descriptor output supported."
            );
          const c = t.dataFormatDescriptor[0];
          U.setUint32(0, 44, !0),
            U.setUint16(4, c.vendorId, !0),
            U.setUint16(6, c.descriptorType, !0),
            U.setUint16(8, c.versionNumber, !0),
            U.setUint16(10, c.descriptorBlockSize, !0),
            U.setUint8(12, c.colorModel),
            U.setUint8(13, c.colorPrimaries),
            U.setUint8(14, c.transferFunction),
            U.setUint8(15, c.flags),
            U.setUint8(16, c.texelBlockDimension.x - 1),
            U.setUint8(17, c.texelBlockDimension.y - 1),
            U.setUint8(18, c.texelBlockDimension.z - 1),
            U.setUint8(19, c.texelBlockDimension.w - 1);
          for (let e = 0; e < 8; e++) U.setUint8(20 + e, c.bytesPlane[e]);
          for (let e = 0; e < c.samples.length; e++) {
            const t = c.samples[e],
              n = 28 + 16 * e;
            U.setUint16(n + 0, t.bitOffset, !0),
              U.setUint8(n + 2, t.bitLength),
              U.setUint8(n + 3, t.channelID),
              U.setUint8(n + 4, t.samplePosition[0]),
              U.setUint8(n + 5, t.samplePosition[1]),
              U.setUint8(n + 6, t.samplePosition[2]),
              U.setUint8(n + 7, t.samplePosition[3]),
              U.setUint32(n + 8, t.sampleLower, !0),
              U.setUint32(n + 12, t.sampleUpper, !0);
          }
          const p = n.length + 68 + 3 * t.levels.length * 8,
            x = p + f.byteLength;
          let g = x + l.byteLength;
          g % 8 && (g += 8 - (g % 8));
          const D = [],
            T = new DataView(new ArrayBuffer(3 * t.levels.length * 8));
          let b = g + r.byteLength;
          for (let e = 0; e < t.levels.length; e++) {
            const n = t.levels[e];
            D.push(n.levelData),
              T.setBigUint64(24 * e + 0, BigInt(b), !0),
              T.setBigUint64(24 * e + 8, BigInt(n.levelData.byteLength), !0),
              T.setBigUint64(24 * e + 16, BigInt(n.uncompressedByteLength), !0),
              (b += n.levelData.byteLength);
          }
          const d = new ArrayBuffer(68),
            S = new DataView(d);
          return (
            S.setUint32(0, t.vkFormat, !0),
            S.setUint32(4, t.typeSize, !0),
            S.setUint32(8, t.pixelWidth, !0),
            S.setUint32(12, t.pixelHeight, !0),
            S.setUint32(16, t.pixelDepth, !0),
            S.setUint32(20, t.layerCount, !0),
            S.setUint32(24, t.faceCount, !0),
            S.setUint32(28, t.levels.length, !0),
            S.setUint32(32, t.supercompressionScheme, !0),
            S.setUint32(36, p, !0),
            S.setUint32(40, f.byteLength, !0),
            S.setUint32(44, x, !0),
            S.setUint32(48, l.byteLength, !0),
            S.setBigUint64(52, BigInt(g), !0),
            S.setBigUint64(60, BigInt(r.byteLength), !0),
            new Uint8Array(
              _([
                new Uint8Array(n).buffer,
                d,
                T.buffer,
                f,
                l,
                new ArrayBuffer(g - (x + l.byteLength)),
                r,
                ...D,
              ])
            )
          );
        }
      },
      { buffer: "aMB2" },
    ],
    A5uo: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.BasisTextureLoader = void 0);
        var e = require("three");
        const t = new WeakMap();
        class r extends e.Loader {
          constructor(e) {
            super(e),
              (this.transcoderPath = ""),
              (this.transcoderBinary = null),
              (this.transcoderPending = null),
              (this.workerLimit = 4),
              (this.workerPool = []),
              (this.workerNextTaskID = 1),
              (this.workerSourceURL = ""),
              (this.workerConfig = null);
          }
          setTranscoderPath(e) {
            return (this.transcoderPath = e), this;
          }
          setWorkerLimit(e) {
            return (this.workerLimit = e), this;
          }
          detectSupport(e) {
            return (
              (this.workerConfig = {
                astcSupported: e.extensions.has(
                  "WEBGL_compressed_texture_astc"
                ),
                etc1Supported: e.extensions.has(
                  "WEBGL_compressed_texture_etc1"
                ),
                etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                pvrtcSupported:
                  e.extensions.has("WEBGL_compressed_texture_pvrtc") ||
                  e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc"),
              }),
              this
            );
          }
          load(r, o, s, a) {
            const i = new e.FileLoader(this.manager);
            i.setResponseType("arraybuffer"),
              i.setWithCredentials(this.withCredentials);
            const n = new e.CompressedTexture();
            return (
              i.load(
                r,
                (e) => {
                  if (t.has(e)) {
                    return t.get(e).promise.then(o).catch(a);
                  }
                  this._createTexture([e])
                    .then(function (e) {
                      n.copy(e), (n.needsUpdate = !0), o && o(n);
                    })
                    .catch(a);
                },
                s,
                a
              ),
              n
            );
          }
          parseInternalAsync(e) {
            const { levels: t } = e,
              r = new Set();
            for (let o = 0; o < t.length; o++) r.add(t[o].data.buffer);
            return this._createTexture(Array.from(r), { ...e, lowLevel: !0 });
          }
          _createTexture(r, o = {}) {
            let s, a;
            const i = o;
            let n = 0;
            for (let e = 0; e < r.length; e++) n += r[e].byteLength;
            const d = this._allocateWorker(n)
              .then(
                (e) => (
                  (s = e),
                  (a = this.workerNextTaskID++),
                  new Promise((e, t) => {
                    (s._callbacks[a] = { resolve: e, reject: t }),
                      s.postMessage(
                        { type: "transcode", id: a, buffers: r, taskConfig: i },
                        r
                      );
                  })
                )
              )
              .then((t) => {
                const { mipmaps: r, width: o, height: s, format: a } = t,
                  i = new e.CompressedTexture(r, o, s, a, e.UnsignedByteType);
                return (
                  (i.minFilter =
                    1 === r.length
                      ? e.LinearFilter
                      : e.LinearMipmapLinearFilter),
                  (i.magFilter = e.LinearFilter),
                  (i.generateMipmaps = !1),
                  (i.needsUpdate = !0),
                  i
                );
              });
            return (
              d
                .catch(() => !0)
                .then(() => {
                  s && a && ((s._taskLoad -= n), delete s._callbacks[a]);
                }),
              t.set(r[0], { promise: d }),
              d
            );
          }
          _initTranscoder() {
            if (!this.transcoderPending) {
              const t = new e.FileLoader(this.manager);
              t.setPath(this.transcoderPath),
                t.setWithCredentials(this.withCredentials);
              const o = new Promise((e, r) => {
                t.load("basis_transcoder.js", e, void 0, r);
              }),
                s = new e.FileLoader(this.manager);
              s.setPath(this.transcoderPath),
                s.setResponseType("arraybuffer"),
                s.setWithCredentials(this.withCredentials);
              const a = new Promise((e, t) => {
                s.load("basis_transcoder.wasm", e, void 0, t);
              });
              this.transcoderPending = Promise.all([o, a]).then(([e, t]) => {
                const o = r.BasisWorker.toString(),
                  s = [
                    "/* constants */",
                    "let _EngineFormat = " + JSON.stringify(r.EngineFormat),
                    "let _TranscoderFormat = " +
                    JSON.stringify(r.TranscoderFormat),
                    "let _BasisFormat = " + JSON.stringify(r.BasisFormat),
                    "/* basis_transcoder.js */",
                    e,
                    "/* worker */",
                    o.substring(o.indexOf("{") + 1, o.lastIndexOf("}")),
                  ].join("\n");
                (this.workerSourceURL = URL.createObjectURL(new Blob([s]))),
                  (this.transcoderBinary = t);
              });
            }
            return this.transcoderPending;
          }
          _allocateWorker(e) {
            return this._initTranscoder().then(() => {
              if (this.workerPool.length < this.workerLimit) {
                const e = new Worker(this.workerSourceURL);
                (e._callbacks = {}),
                  (e._taskLoad = 0),
                  e.postMessage({
                    type: "init",
                    config: this.workerConfig,
                    transcoderBinary: this.transcoderBinary,
                  }),
                  (e.onmessage = function (t) {
                    const r = t.data;
                    switch (r.type) {
                      case "transcode":
                        e._callbacks[r.id].resolve(r);
                        break;
                      case "error":
                        e._callbacks[r.id].reject(r);
                        break;
                      default:
                        console.error(
                          'THREE.BasisTextureLoader: Unexpected message, "' +
                          r.type +
                          '"'
                        );
                    }
                  }),
                  this.workerPool.push(e);
              } else
                this.workerPool.sort(function (e, t) {
                  return e._taskLoad > t._taskLoad ? -1 : 1;
                });
              const t = this.workerPool[this.workerPool.length - 1];
              return (t._taskLoad += e), t;
            });
          }
          dispose() {
            for (let e = 0; e < this.workerPool.length; e++)
              this.workerPool[e].terminate();
            return (this.workerPool.length = 0), this;
          }
        }
        (exports.BasisTextureLoader = r),
          (r.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }),
          (r.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16,
          }),
          (r.EngineFormat = {
            RGBAFormat: e.RGBAFormat,
            RGBA_ASTC_4x4_Format: e.RGBA_ASTC_4x4_Format,
            RGBA_BPTC_Format: e.RGBA_BPTC_Format,
            RGBA_ETC2_EAC_Format: e.RGBA_ETC2_EAC_Format,
            RGBA_PVRTC_4BPPV1_Format: e.RGBA_PVRTC_4BPPV1_Format,
            RGBA_S3TC_DXT5_Format: e.RGBA_S3TC_DXT5_Format,
            RGB_ETC1_Format: e.RGB_ETC1_Format,
            RGB_ETC2_Format: e.RGB_ETC2_Format,
            RGB_PVRTC_4BPPV1_Format: e.RGB_PVRTC_4BPPV1_Format,
            RGB_S3TC_DXT1_Format: e.RGB_S3TC_DXT1_Format,
          }),
          (r.BasisWorker = function () {
            let e, t, r;
            const o = _EngineFormat,
              s = _TranscoderFormat,
              a = _BasisFormat;
            onmessage = function (o) {
              const s = o.data;
              switch (s.type) {
                case "init":
                  (e = s.config),
                    (i = s.transcoderBinary),
                    (t = new Promise((e) => {
                      (r = { wasmBinary: i, onRuntimeInitialized: e }),
                        BASIS(r);
                    }).then(() => {
                      r.initializeBasis();
                    }));
                  break;
                case "transcode":
                  t.then(() => {
                    try {
                      const {
                        width: t,
                        height: o,
                        hasAlpha: i,
                        mipmaps: n,
                        format: d,
                      } = s.taskConfig.lowLevel
                          ? (function (e) {
                            const {
                              basisFormat: t,
                              width: o,
                              height: s,
                              hasAlpha: i,
                            } = e,
                              { transcoderFormat: n, engineFormat: d } = c(
                                t,
                                o,
                                s,
                                i
                              ),
                              T = r.getBytesPerBlockOrPixel(n);
                            h(
                              r.isFormatSupported(n),
                              "THREE.BasisTextureLoader: Unsupported format."
                            );
                            const p = [];
                            if (t === a.ETC1S) {
                              const t = new r.LowLevelETC1SImageTranscoder(),
                                {
                                  endpointCount: o,
                                  endpointsData: s,
                                  selectorCount: a,
                                  selectorsData: d,
                                  tablesData: c,
                                } = e.globalData;
                              try {
                                let r;
                                h(
                                  (r = t.decodePalettes(o, s, a, d)),
                                  "THREE.BasisTextureLoader: decodePalettes() failed."
                                ),
                                  h(
                                    (r = t.decodeTables(c)),
                                    "THREE.BasisTextureLoader: decodeTables() failed."
                                  );
                                for (let o = 0; o < e.levels.length; o++) {
                                  const s = e.levels[o],
                                    a = e.globalData.imageDescs[o],
                                    d = m(n, s.width, s.height),
                                    c = new Uint8Array(d);
                                  h(
                                    (r = t.transcodeImage(
                                      n,
                                      c,
                                      d / T,
                                      s.data,
                                      l(n, s.width),
                                      _(n, s.height),
                                      s.width,
                                      s.height,
                                      s.index,
                                      a.rgbSliceByteOffset,
                                      a.rgbSliceByteLength,
                                      a.alphaSliceByteOffset,
                                      a.alphaSliceByteLength,
                                      a.imageFlags,
                                      i,
                                      !1,
                                      0,
                                      0
                                    )),
                                    "THREE.BasisTextureLoader: transcodeImage() failed for level " +
                                    s.index +
                                    "."
                                  ),
                                    p.push({
                                      data: c,
                                      width: s.width,
                                      height: s.height,
                                    });
                                }
                              } finally {
                                t.delete();
                              }
                            } else
                              for (let a = 0; a < e.levels.length; a++) {
                                const t = e.levels[a],
                                  o = m(n, t.width, t.height),
                                  s = new Uint8Array(o),
                                  d = r.transcodeUASTCImage(
                                    n,
                                    s,
                                    o / T,
                                    t.data,
                                    l(n, t.width),
                                    _(n, t.height),
                                    t.width,
                                    t.height,
                                    t.index,
                                    0,
                                    t.data.byteLength,
                                    0,
                                    i,
                                    !1,
                                    0,
                                    0,
                                    -1,
                                    -1
                                  );
                                h(
                                  d,
                                  "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " +
                                  t.index +
                                  "."
                                ),
                                  p.push({
                                    data: s,
                                    width: t.width,
                                    height: t.height,
                                  });
                              }
                            return {
                              width: o,
                              height: s,
                              hasAlpha: i,
                              mipmaps: p,
                              format: d,
                            };
                          })(s.taskConfig)
                          : (function (e) {
                            const t = new r.BasisFile(new Uint8Array(e)),
                              o = t.isUASTC() ? a.UASTC_4x4 : a.ETC1S,
                              s = t.getImageWidth(0, 0),
                              i = t.getImageHeight(0, 0),
                              n = t.getNumLevels(0),
                              d = t.getHasAlpha();
                            function h() {
                              t.close(), t.delete();
                            }
                            const { transcoderFormat: l, engineFormat: _ } =
                              c(o, s, i, d);
                            if (!s || !i || !n)
                              throw (
                                (h(),
                                  new Error(
                                    "THREE.BasisTextureLoader:\tInvalid texture"
                                  ))
                              );
                            if (!t.startTranscoding())
                              throw (
                                (h(),
                                  new Error(
                                    "THREE.BasisTextureLoader: .startTranscoding failed"
                                  ))
                              );
                            const m = [];
                            for (let r = 0; r < n; r++) {
                              const e = t.getImageWidth(0, r),
                                o = t.getImageHeight(0, r),
                                s = new Uint8Array(
                                  t.getImageTranscodedSizeInBytes(0, r, l)
                                ),
                                a = t.transcodeImage(s, 0, r, l, 0, d);
                              if (!a)
                                throw (
                                  (h(),
                                    new Error(
                                      "THREE.BasisTextureLoader: .transcodeImage failed."
                                    ))
                                );
                              m.push({ data: s, width: e, height: o });
                            }
                            return (
                              h(),
                              {
                                width: s,
                                height: i,
                                hasAlpha: d,
                                mipmaps: m,
                                format: _,
                              }
                            );
                          })(s.buffers[0]),
                        T = [];
                      for (let e = 0; e < n.length; ++e)
                        T.push(n[e].data.buffer);
                      self.postMessage(
                        {
                          type: "transcode",
                          id: s.id,
                          width: t,
                          height: o,
                          hasAlpha: i,
                          mipmaps: n,
                          format: d,
                        },
                        T
                      );
                    } catch (e) {
                      console.error(e),
                        self.postMessage({
                          type: "error",
                          id: s.id,
                          error: e.message,
                        });
                    }
                  });
              }
              var i;
            };
            const i = [
              {
                if: "astcSupported",
                basisFormat: [a.UASTC_4x4],
                transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                engineFormat: [
                  o.RGBA_ASTC_4x4_Format,
                  o.RGBA_ASTC_4x4_Format,
                ],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1,
              },
              {
                if: "bptcSupported",
                basisFormat: [a.ETC1S, a.UASTC_4x4],
                transcoderFormat: [s.BC7_M5, s.BC7_M5],
                engineFormat: [o.RGBA_BPTC_Format, o.RGBA_BPTC_Format],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1,
              },
              {
                if: "dxtSupported",
                basisFormat: [a.ETC1S, a.UASTC_4x4],
                transcoderFormat: [s.BC1, s.BC3],
                engineFormat: [
                  o.RGB_S3TC_DXT1_Format,
                  o.RGBA_S3TC_DXT5_Format,
                ],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc2Supported",
                basisFormat: [a.ETC1S, a.UASTC_4x4],
                transcoderFormat: [s.ETC1, s.ETC2],
                engineFormat: [o.RGB_ETC2_Format, o.RGBA_ETC2_EAC_Format],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc1Supported",
                basisFormat: [a.ETC1S, a.UASTC_4x4],
                transcoderFormat: [s.ETC1, s.ETC1],
                engineFormat: [o.RGB_ETC1_Format, o.RGB_ETC1_Format],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1,
              },
              {
                if: "pvrtcSupported",
                basisFormat: [a.ETC1S, a.UASTC_4x4],
                transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                engineFormat: [
                  o.RGB_PVRTC_4BPPV1_Format,
                  o.RGBA_PVRTC_4BPPV1_Format,
                ],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0,
              },
            ],
              n = i.sort(function (e, t) {
                return e.priorityETC1S - t.priorityETC1S;
              }),
              d = i.sort(function (e, t) {
                return e.priorityUASTC - t.priorityUASTC;
              });
            function c(t, r, i, c) {
              let h, l;
              const _ = t === a.ETC1S ? n : d;
              for (let o = 0; o < _.length; o++) {
                const s = _[o];
                if (
                  e[s.if] &&
                  s.basisFormat.includes(t) &&
                  (!s.needsPowerOfTwo || (T(r) && T(i)))
                )
                  return {
                    transcoderFormat: (h = s.transcoderFormat[c ? 1 : 0]),
                    engineFormat: (l = s.engineFormat[c ? 1 : 0]),
                  };
              }
              return (
                console.warn(
                  "THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32."
                ),
                {
                  transcoderFormat: (h = s.RGBA32),
                  engineFormat: (l = o.RGBAFormat),
                }
              );
            }
            function h(e, t) {
              if (!e) throw new Error(t);
            }
            function l(e, t) {
              return Math.ceil(t / r.getFormatBlockWidth(e));
            }
            function _(e, t) {
              return Math.ceil(t / r.getFormatBlockHeight(e));
            }
            function m(e, t, o) {
              const a = r.getBytesPerBlockOrPixel(e);
              if (r.formatIsUncompressed(e)) return t * o * a;
              if (e === s.PVRTC1_4_RGB || e === s.PVRTC1_4_RGBA) {
                const e = (t + 3) & -4,
                  r = (o + 3) & -4;
                return (Math.max(8, e) * Math.max(8, r) * 4 + 7) / 8;
              }
              return l(e, t) * _(e, o) * a;
            }
            function T(e) {
              return e <= 2 || (0 == (e & (e - 1)) && 0 !== e);
            }
          });
      },
      { three: "gBK8" },
    ],
    vQ2u: [
      function (require, module, exports) {
        "use strict";
        let A, I, B;
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.ZSTDDecoder = void 0);
        const g = {
          env: {
            emscripten_notify_memory_growth: function (A) {
              B = new Uint8Array(I.exports.memory.buffer);
            },
          },
        };
        class Q {
          init() {
            return (
              A ||
              (A = fetch("data:application/wasm;base64," + C)
                .then((A) => A.arrayBuffer())
                .then((A) => WebAssembly.instantiate(A, g))
                .then((A) => {
                  (I = A.instance), g.env.emscripten_notify_memory_growth(0);
                })),
              A
            );
          }
          decode(A, g = 0) {
            const Q = A.byteLength,
              C = I.exports.malloc(Q);
            B.set(A, C),
              (g = g || Number(I.exports.ZSTD_findDecompressedSize(C, Q)));
            const E = I.exports.malloc(g),
              i = I.exports.ZSTD_decompress(E, g, C, Q),
              D = B.slice(E, E + i);
            return I.exports.free(C), I.exports.free(E), D;
          }
        }
        exports.ZSTDDecoder = Q;
        const C =
          "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
      },
      {},
    ],
    phQK: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.KTX2Loader = void 0);
        var e = require("three"),
          r = require("../libs/ktx-parse.module.js"),
          t = require("./BasisTextureLoader.js"),
          s = require("../libs/zstddec.module.js");
        class a extends e.CompressedTextureLoader {
          constructor(e) {
            super(e),
              (this.basisLoader = new t.BasisTextureLoader(e)),
              (this.zstd = new s.ZSTDDecoder()),
              this.zstd.init(),
              "undefined" != typeof MSC_TRANSCODER &&
              console.warn(
                'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
              );
          }
          setTranscoderPath(e) {
            return this.basisLoader.setTranscoderPath(e), this;
          }
          setWorkerLimit(e) {
            return this.basisLoader.setWorkerLimit(e), this;
          }
          detectSupport(e) {
            return this.basisLoader.detectSupport(e), this;
          }
          dispose() {
            return this.basisLoader.dispose(), this;
          }
          load(r, t, s, a) {
            var o = this,
              i = new e.CompressedTexture();
            return (
              new Promise(function (t, a) {
                new e.FileLoader(o.manager)
                  .setPath(o.path)
                  .setResponseType("arraybuffer")
                  .load(r, t, s, a);
              })
                .then(function (e) {
                  o.parse(
                    e,
                    function (e) {
                      i.copy(e), (i.needsUpdate = !0), t && t(i);
                    },
                    a
                  );
                })
                .catch(a),
              i
            );
          }
          parse(s, a, i) {
            var n = this,
              l = (0, r.read)(new Uint8Array(s));
            if (l.pixelDepth > 0)
              throw new Error(
                "THREE.KTX2Loader: Only 2D textures are currently supported."
              );
            if (l.layerCount > 1)
              throw new Error(
                "THREE.KTX2Loader: Array textures are not currently supported."
              );
            if (l.faceCount > 1)
              throw new Error(
                "THREE.KTX2Loader: Cube textures are not currently supported."
              );
            var d = o.getBasicDFD(l);
            return (
              o
                .createLevels(l, this.zstd)
                .then(function (e) {
                  var s =
                    d.colorModel === r.KTX2Model.UASTC
                      ? t.BasisTextureLoader.BasisFormat.UASTC_4x4
                      : t.BasisTextureLoader.BasisFormat.ETC1S,
                    a = {
                      levels: e,
                      width: l.pixelWidth,
                      height: l.pixelHeight,
                      basisFormat: s,
                      hasAlpha: o.getAlpha(l),
                    };
                  return (
                    s === t.BasisTextureLoader.BasisFormat.ETC1S &&
                    (a.globalData = l.globalData),
                    n.basisLoader.parseInternalAsync(a)
                  );
                })
                .then(function (t) {
                  (t.encoding =
                    d.transferFunction === r.KTX2Transfer.SRGB
                      ? e.sRGBEncoding
                      : e.LinearEncoding),
                    (t.premultiplyAlpha = o.getPremultiplyAlpha(l)),
                    a(t);
                })
                .catch(i),
              this
            );
          }
        }
        exports.KTX2Loader = a;
        var o = {
          createLevels: async function (e, t) {
            e.supercompressionScheme === r.KTX2SupercompressionScheme.ZSTD &&
              (await t.init());
            for (
              var s = [], a = e.pixelWidth, o = e.pixelHeight, i = 0;
              i < e.levels.length;
              i++
            ) {
              var n = Math.max(1, Math.floor(a / Math.pow(2, i))),
                l = Math.max(1, Math.floor(o / Math.pow(2, i))),
                d = e.levels[i].levelData;
              e.supercompressionScheme === r.KTX2SupercompressionScheme.ZSTD &&
                (d = t.decode(d, e.levels[i].uncompressedByteLength)),
                s.push({ index: i, width: n, height: l, data: d });
            }
            return s;
          },
          getBasicDFD: function (e) {
            return e.dataFormatDescriptor[0];
          },
          getAlpha: function (e) {
            var t = this.getBasicDFD(e);
            return t.colorModel === r.KTX2Model.UASTC
              ? (15 & t.samples[0].channelID) === r.KTX2ChannelUASTC.RGBA
              : 2 === t.samples.length &&
              (15 & t.samples[1].channelID) === r.KTX2ChannelETC1S.AAA;
          },
          getPremultiplyAlpha: function (e) {
            return !!(
              this.getBasicDFD(e).flags & r.KTX2Flags.ALPHA_PREMULTIPLIED
            );
          },
        };
      },
      {
        three: "gBK8",
        "../libs/ktx-parse.module.js": "GX3I",
        "./BasisTextureLoader.js": "A5uo",
        "../libs/zstddec.module.js": "vQ2u",
      },
    ],
    FYxH: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.DRACOLoader = void 0);
        var e = require("three");
        const t = new WeakMap();
        class r extends e.Loader {
          constructor(e) {
            super(e),
              (this.decoderPath = ""),
              (this.decoderConfig = {}),
              (this.decoderBinary = null),
              (this.decoderPending = null),
              (this.workerLimit = 4),
              (this.workerPool = []),
              (this.workerNextTaskID = 1),
              (this.workerSourceURL = ""),
              (this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD",
              }),
              (this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array",
              });
          }
          setDecoderPath(e) {
            return (this.decoderPath = e), this;
          }
          setDecoderConfig(e) {
            return (this.decoderConfig = e), this;
          }
          setWorkerLimit(e) {
            return (this.workerLimit = e), this;
          }
          load(t, r, o, s) {
            const i = new e.FileLoader(this.manager);
            i.setPath(this.path),
              i.setResponseType("arraybuffer"),
              i.setRequestHeader(this.requestHeader),
              i.setWithCredentials(this.withCredentials),
              i.load(
                t,
                (e) => {
                  const t = {
                    attributeIDs: this.defaultAttributeIDs,
                    attributeTypes: this.defaultAttributeTypes,
                    useUniqueIDs: !1,
                  };
                  this.decodeGeometry(e, t).then(r).catch(s);
                },
                o,
                s
              );
          }
          decodeDracoFile(e, t, r, o) {
            const s = {
              attributeIDs: r || this.defaultAttributeIDs,
              attributeTypes: o || this.defaultAttributeTypes,
              useUniqueIDs: !!r,
            };
            this.decodeGeometry(e, s).then(t);
          }
          decodeGeometry(e, r) {
            for (const t in r.attributeTypes) {
              const e = r.attributeTypes[t];
              void 0 !== e.BYTES_PER_ELEMENT && (r.attributeTypes[t] = e.name);
            }
            const o = JSON.stringify(r);
            if (t.has(e)) {
              const r = t.get(e);
              if (r.key === o) return r.promise;
              if (0 === e.byteLength)
                throw new Error(
                  "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
                );
            }
            let s;
            const i = this.workerNextTaskID++,
              n = e.byteLength,
              a = this._getWorker(i, n)
                .then(
                  (t) => (
                    (s = t),
                    new Promise((t, o) => {
                      (s._callbacks[i] = { resolve: t, reject: o }),
                        s.postMessage(
                          { type: "decode", id: i, taskConfig: r, buffer: e },
                          [e]
                        );
                    })
                  )
                )
                .then((e) => this._createGeometry(e.geometry));
            return (
              a
                .catch(() => !0)
                .then(() => {
                  s && i && this._releaseTask(s, i);
                }),
              t.set(e, { key: o, promise: a }),
              a
            );
          }
          _createGeometry(t) {
            const r = new e.BufferGeometry();
            t.index && r.setIndex(new e.BufferAttribute(t.index.array, 1));
            for (let o = 0; o < t.attributes.length; o++) {
              const s = t.attributes[o],
                i = s.name,
                n = s.array,
                a = s.itemSize;
              r.setAttribute(i, new e.BufferAttribute(n, a));
            }
            return r;
          }
          _loadLibrary(t, r) {
            const o = new e.FileLoader(this.manager);
            return (
              o.setPath(this.decoderPath),
              o.setResponseType(r),
              o.setWithCredentials(this.withCredentials),
              new Promise((e, r) => {
                o.load(t, e, void 0, r);
              })
            );
          }
          preload() {
            return this._initDecoder(), this;
          }
          _initDecoder() {
            if (this.decoderPending) return this.decoderPending;
            const e =
              "object" != typeof WebAssembly ||
              "js" === this.decoderConfig.type,
              t = [];
            return (
              e
                ? t.push(this._loadLibrary("draco_decoder.js", "text"))
                : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                  t.push(
                    this._loadLibrary("draco_decoder.wasm", "arraybuffer")
                  )),
              (this.decoderPending = Promise.all(t).then((t) => {
                const r = t[0];
                e || (this.decoderConfig.wasmBinary = t[1]);
                const s = o.toString(),
                  i = [
                    "/* draco decoder */",
                    r,
                    "",
                    "/* worker */",
                    s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
                  ].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([i]));
              })),
              this.decoderPending
            );
          }
          _getWorker(e, t) {
            return this._initDecoder().then(() => {
              if (this.workerPool.length < this.workerLimit) {
                const e = new Worker(this.workerSourceURL);
                (e._callbacks = {}),
                  (e._taskCosts = {}),
                  (e._taskLoad = 0),
                  e.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig,
                  }),
                  (e.onmessage = function (t) {
                    const r = t.data;
                    switch (r.type) {
                      case "decode":
                        e._callbacks[r.id].resolve(r);
                        break;
                      case "error":
                        e._callbacks[r.id].reject(r);
                        break;
                      default:
                        console.error(
                          'THREE.DRACOLoader: Unexpected message, "' +
                          r.type +
                          '"'
                        );
                    }
                  }),
                  this.workerPool.push(e);
              } else
                this.workerPool.sort(function (e, t) {
                  return e._taskLoad > t._taskLoad ? -1 : 1;
                });
              const r = this.workerPool[this.workerPool.length - 1];
              return (r._taskCosts[e] = t), (r._taskLoad += t), r;
            });
          }
          _releaseTask(e, t) {
            (e._taskLoad -= e._taskCosts[t]),
              delete e._callbacks[t],
              delete e._taskCosts[t];
          }
          debug() {
            console.log(
              "Task load: ",
              this.workerPool.map((e) => e._taskLoad)
            );
          }
          dispose() {
            for (let e = 0; e < this.workerPool.length; ++e)
              this.workerPool[e].terminate();
            return (this.workerPool.length = 0), this;
          }
        }
        function o() {
          let e, t;
          function r(e, t, r, o, s, i) {
            const n = i.num_components(),
              a = r.num_points() * n,
              d = a * s.BYTES_PER_ELEMENT,
              c = (function (e, t) {
                switch (t) {
                  case Float32Array:
                    return e.DT_FLOAT32;
                  case Int8Array:
                    return e.DT_INT8;
                  case Int16Array:
                    return e.DT_INT16;
                  case Int32Array:
                    return e.DT_INT32;
                  case Uint8Array:
                    return e.DT_UINT8;
                  case Uint16Array:
                    return e.DT_UINT16;
                  case Uint32Array:
                    return e.DT_UINT32;
                }
              })(e, s),
              u = e._malloc(d);
            t.GetAttributeDataArrayForAllPoints(r, i, c, d, u);
            const l = new s(e.HEAPF32.buffer, u, a).slice();
            return e._free(u), { name: o, array: l, itemSize: n };
          }
          onmessage = function (o) {
            const s = o.data;
            switch (s.type) {
              case "init":
                (e = s.decoderConfig),
                  (t = new Promise(function (t) {
                    (e.onModuleLoaded = function (e) {
                      t({ draco: e });
                    }),
                      DracoDecoderModule(e);
                  }));
                break;
              case "decode":
                const o = s.buffer,
                  i = s.taskConfig;
                t.then((e) => {
                  const t = e.draco,
                    n = new t.Decoder(),
                    a = new t.DecoderBuffer();
                  a.Init(new Int8Array(o), o.byteLength);
                  try {
                    const e = (function (e, t, o, s) {
                      const i = s.attributeIDs,
                        n = s.attributeTypes;
                      let a, d;
                      const c = t.GetEncodedGeometryType(o);
                      if (c === e.TRIANGULAR_MESH)
                        (a = new e.Mesh()), (d = t.DecodeBufferToMesh(o, a));
                      else {
                        if (c !== e.POINT_CLOUD)
                          throw new Error(
                            "THREE.DRACOLoader: Unexpected geometry type."
                          );
                        (a = new e.PointCloud()),
                          (d = t.DecodeBufferToPointCloud(o, a));
                      }
                      if (!d.ok() || 0 === a.ptr)
                        throw new Error(
                          "THREE.DRACOLoader: Decoding failed: " +
                          d.error_msg()
                        );
                      const u = { index: null, attributes: [] };
                      for (const l in i) {
                        const o = self[n[l]];
                        let d, c;
                        if (s.useUniqueIDs)
                          (c = i[l]), (d = t.GetAttributeByUniqueId(a, c));
                        else {
                          if (-1 === (c = t.GetAttributeId(a, e[i[l]])))
                            continue;
                          d = t.GetAttribute(a, c);
                        }
                        u.attributes.push(r(e, t, a, l, o, d));
                      }
                      c === e.TRIANGULAR_MESH &&
                        (u.index = (function (e, t, r) {
                          const o = 3 * r.num_faces(),
                            s = 4 * o,
                            i = e._malloc(s);
                          t.GetTrianglesUInt32Array(r, s, i);
                          const n = new Uint32Array(
                            e.HEAPF32.buffer,
                            i,
                            o
                          ).slice();
                          return e._free(i), { array: n, itemSize: 1 };
                        })(e, t, a));
                      return e.destroy(a), u;
                    })(t, n, a, i),
                      o = e.attributes.map((e) => e.array.buffer);
                    e.index && o.push(e.index.array.buffer),
                      self.postMessage(
                        { type: "decode", id: s.id, geometry: e },
                        o
                      );
                  } catch (d) {
                    console.error(d),
                      self.postMessage({
                        type: "error",
                        id: s.id,
                        error: d.message,
                      });
                  } finally {
                    t.destroy(a), t.destroy(n);
                  }
                });
            }
          };
        }
        exports.DRACOLoader = r;
      },
      { three: "gBK8" },
    ],
    FK1n: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.MeshoptDecoder = void 0);
        var A = (function () {
          var A = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5,
            3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252,
            10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11,
          ]),
            B = new Uint8Array([
              32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33,
              12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255,
              66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101,
              130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167,
            ]);
          if ("object" != typeof WebAssembly) return { supported: !1 };
          var C,
            G =
              "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
          WebAssembly.validate(A) &&
            ((G =
              "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB"),
              console.log(
                "Warning: meshopt_decoder is using experimental SIMD support"
              ));
          var F = WebAssembly.instantiate(
            (function (A) {
              for (var C = new Uint8Array(A.length), G = 0; G < A.length; ++G) {
                var F = A.charCodeAt(G);
                C[G] =
                  F > 96
                    ? F - 71
                    : F > 64
                      ? F - 65
                      : F > 47
                        ? F + 4
                        : F > 46
                          ? 63
                          : 62;
              }
              for (var J = 0, G = 0; G < A.length; ++G)
                C[J++] = C[G] < 60 ? B[C[G]] : 64 * (C[G] - 60) + C[++G];
              return C.buffer.slice(0, J);
            })(G),
            {}
          ).then(function (A) {
            (C = A.instance).exports.__wasm_call_ctors();
          });
          function J(A, B, G, F, J, D) {
            var H = C.exports.sbrk,
              M = (G + 3) & -4,
              I = H(M * F),
              E = H(J.length),
              R = new Uint8Array(C.exports.memory.buffer);
            R.set(J, E);
            var K = A(I, G, F, E, J.length);
            if (
              (0 == K && D && D(I, M, F),
                B.set(R.subarray(I, I + G * F)),
                H(I - H(0)),
                0 != K)
            )
              throw new Error("Malformed buffer data: " + K);
          }
          var D = {
            0: "",
            1: "meshopt_decodeFilterOct",
            2: "meshopt_decodeFilterQuat",
            3: "meshopt_decodeFilterExp",
            NONE: "",
            OCTAHEDRAL: "meshopt_decodeFilterOct",
            QUATERNION: "meshopt_decodeFilterQuat",
            EXPONENTIAL: "meshopt_decodeFilterExp",
          },
            H = {
              0: "meshopt_decodeVertexBuffer",
              1: "meshopt_decodeIndexBuffer",
              2: "meshopt_decodeIndexSequence",
              ATTRIBUTES: "meshopt_decodeVertexBuffer",
              TRIANGLES: "meshopt_decodeIndexBuffer",
              INDICES: "meshopt_decodeIndexSequence",
            };
          return {
            ready: F,
            supported: !0,
            decodeVertexBuffer: function (A, B, G, F, H) {
              J(
                C.exports.meshopt_decodeVertexBuffer,
                A,
                B,
                G,
                F,
                C.exports[D[H]]
              );
            },
            decodeIndexBuffer: function (A, B, G, F) {
              J(C.exports.meshopt_decodeIndexBuffer, A, B, G, F);
            },
            decodeIndexSequence: function (A, B, G, F) {
              J(C.exports.meshopt_decodeIndexSequence, A, B, G, F);
            },
            decodeGltfBuffer: function (A, B, G, F, M, I) {
              J(C.exports[H[M]], A, B, G, F, C.exports[D[I]]);
            },
          };
        })();
        exports.MeshoptDecoder = A;
      },
      {},
    ],
    x87H: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.OrbitControls = exports.MapControls = void 0);
        var e = require("three");
        const t = { type: "change" },
          n = { type: "start" },
          o = { type: "end" };
        class a extends e.EventDispatcher {
          constructor(a, i) {
            super(),
              void 0 === i &&
              console.warn(
                'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
              ),
              i === document &&
              console.error(
                'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
              ),
              (this.object = a),
              (this.domElement = i),
              (this.enabled = !0),
              (this.target = new e.Vector3()),
              (this.minDistance = 0),
              (this.maxDistance = 1 / 0),
              (this.minZoom = 0),
              (this.maxZoom = 1 / 0),
              (this.minPolarAngle = 0),
              (this.maxPolarAngle = Math.PI),
              (this.minAzimuthAngle = -1 / 0),
              (this.maxAzimuthAngle = 1 / 0),
              (this.enableDamping = !1),
              (this.dampingFactor = 0.05),
              (this.enableZoom = !0),
              (this.zoomSpeed = 1),
              (this.enableRotate = !0),
              (this.rotateSpeed = 1),
              (this.enablePan = !0),
              (this.panSpeed = 1),
              (this.screenSpacePanning = !0),
              (this.keyPanSpeed = 7),
              (this.autoRotate = !1),
              (this.autoRotateSpeed = 2),
              (this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown",
              }),
              (this.mouseButtons = {
                LEFT: e.MOUSE.ROTATE,
                MIDDLE: e.MOUSE.DOLLY,
                RIGHT: e.MOUSE.PAN,
              }),
              (this.touches = { ONE: e.TOUCH.ROTATE, TWO: e.TOUCH.DOLLY_PAN }),
              (this.target0 = this.target.clone()),
              (this.position0 = this.object.position.clone()),
              (this.zoom0 = this.object.zoom),
              (this._domElementKeyEvents = null),
              (this.getPolarAngle = function () {
                return l.phi;
              }),
              (this.getAzimuthalAngle = function () {
                return l.theta;
              }),
              (this.listenToKeyEvents = function (e) {
                e.addEventListener("keydown", F),
                  (this._domElementKeyEvents = e);
              }),
              (this.saveState = function () {
                s.target0.copy(s.target),
                  s.position0.copy(s.object.position),
                  (s.zoom0 = s.object.zoom);
              }),
              (this.reset = function () {
                s.target.copy(s.target0),
                  s.object.position.copy(s.position0),
                  (s.object.zoom = s.zoom0),
                  s.object.updateProjectionMatrix(),
                  s.dispatchEvent(t),
                  s.update(),
                  (r = c.NONE);
              }),
              (this.update = (function () {
                const n = new e.Vector3(),
                  o = new e.Quaternion().setFromUnitVectors(
                    a.up,
                    new e.Vector3(0, 1, 0)
                  ),
                  i = o.clone().invert(),
                  b = new e.Vector3(),
                  E = new e.Quaternion(),
                  f = 2 * Math.PI;
                return function () {
                  const e = s.object.position;
                  n.copy(e).sub(s.target),
                    n.applyQuaternion(o),
                    l.setFromVector3(n),
                    s.autoRotate &&
                    r === c.NONE &&
                    A(((2 * Math.PI) / 60 / 60) * s.autoRotateSpeed),
                    s.enableDamping
                      ? ((l.theta += m.theta * s.dampingFactor),
                        (l.phi += m.phi * s.dampingFactor))
                      : ((l.theta += m.theta), (l.phi += m.phi));
                  let a = s.minAzimuthAngle,
                    O = s.maxAzimuthAngle;
                  return (
                    isFinite(a) &&
                    isFinite(O) &&
                    (a < -Math.PI ? (a += f) : a > Math.PI && (a -= f),
                      O < -Math.PI ? (O += f) : O > Math.PI && (O -= f),
                      (l.theta =
                        a <= O
                          ? Math.max(a, Math.min(O, l.theta))
                          : l.theta > (a + O) / 2
                            ? Math.max(a, l.theta)
                            : Math.min(O, l.theta))),
                    (l.phi = Math.max(
                      s.minPolarAngle,
                      Math.min(s.maxPolarAngle, l.phi)
                    )),
                    l.makeSafe(),
                    (l.radius *= h),
                    (l.radius = Math.max(
                      s.minDistance,
                      Math.min(s.maxDistance, l.radius)
                    )),
                    !0 === s.enableDamping
                      ? s.target.addScaledVector(p, s.dampingFactor)
                      : s.target.add(p),
                    n.setFromSpherical(l),
                    n.applyQuaternion(i),
                    e.copy(s.target).add(n),
                    s.object.lookAt(s.target),
                    !0 === s.enableDamping
                      ? ((m.theta *= 1 - s.dampingFactor),
                        (m.phi *= 1 - s.dampingFactor),
                        p.multiplyScalar(1 - s.dampingFactor))
                      : (m.set(0, 0, 0), p.set(0, 0, 0)),
                    (h = 1),
                    !!(
                      d ||
                      b.distanceToSquared(s.object.position) > u ||
                      8 * (1 - E.dot(s.object.quaternion)) > u
                    ) &&
                    (s.dispatchEvent(t),
                      b.copy(s.object.position),
                      E.copy(s.object.quaternion),
                      (d = !1),
                      !0)
                  );
                };
              })()),
              (this.dispose = function () {
                s.domElement.removeEventListener("contextmenu", G),
                  s.domElement.removeEventListener("pointerdown", V),
                  s.domElement.removeEventListener("wheel", X),
                  s.domElement.removeEventListener("touchstart", Z),
                  s.domElement.removeEventListener("touchend", B),
                  s.domElement.removeEventListener("touchmove", K),
                  s.domElement.ownerDocument.removeEventListener(
                    "pointermove",
                    z
                  ),
                  s.domElement.ownerDocument.removeEventListener(
                    "pointerup",
                    I
                  ),
                  null !== s._domElementKeyEvents &&
                  s._domElementKeyEvents.removeEventListener("keydown", F);
              });
            const s = this,
              c = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_PAN: 4,
                TOUCH_DOLLY_PAN: 5,
                TOUCH_DOLLY_ROTATE: 6,
              };
            let r = c.NONE;
            const u = 1e-6,
              l = new e.Spherical(),
              m = new e.Spherical();
            let h = 1;
            const p = new e.Vector3();
            let d = !1;
            const b = new e.Vector2(),
              E = new e.Vector2(),
              f = new e.Vector2(),
              O = new e.Vector2(),
              g = new e.Vector2(),
              T = new e.Vector2(),
              v = new e.Vector2(),
              y = new e.Vector2(),
              P = new e.Vector2();
            function w() {
              return Math.pow(0.95, s.zoomSpeed);
            }
            function A(e) {
              m.theta -= e;
            }
            function L(e) {
              m.phi -= e;
            }
            const N = (function () {
              const t = new e.Vector3();
              return function (e, n) {
                t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), p.add(t);
              };
            })(),
              M = (function () {
                const t = new e.Vector3();
                return function (e, n) {
                  !0 === s.screenSpacePanning
                    ? t.setFromMatrixColumn(n, 1)
                    : (t.setFromMatrixColumn(n, 0),
                      t.crossVectors(s.object.up, t)),
                    t.multiplyScalar(e),
                    p.add(t);
                };
              })(),
              j = (function () {
                const t = new e.Vector3();
                return function (e, n) {
                  const o = s.domElement;
                  if (s.object.isPerspectiveCamera) {
                    const a = s.object.position;
                    t.copy(a).sub(s.target);
                    let i = t.length();
                    (i *= Math.tan(((s.object.fov / 2) * Math.PI) / 180)),
                      N((2 * e * i) / o.clientHeight, s.object.matrix),
                      M((2 * n * i) / o.clientHeight, s.object.matrix);
                  } else
                    s.object.isOrthographicCamera
                      ? (N(
                        (e * (s.object.right - s.object.left)) /
                        s.object.zoom /
                        o.clientWidth,
                        s.object.matrix
                      ),
                        M(
                          (n * (s.object.top - s.object.bottom)) /
                          s.object.zoom /
                          o.clientHeight,
                          s.object.matrix
                        ))
                      : (console.warn(
                        "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                      ),
                        (s.enablePan = !1));
                };
              })();
            function R(e) {
              s.object.isPerspectiveCamera
                ? (h /= e)
                : s.object.isOrthographicCamera
                  ? ((s.object.zoom = Math.max(
                    s.minZoom,
                    Math.min(s.maxZoom, s.object.zoom * e)
                  )),
                    s.object.updateProjectionMatrix(),
                    (d = !0))
                  : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                    (s.enableZoom = !1));
            }
            function D(e) {
              s.object.isPerspectiveCamera
                ? (h *= e)
                : s.object.isOrthographicCamera
                  ? ((s.object.zoom = Math.max(
                    s.minZoom,
                    Math.min(s.maxZoom, s.object.zoom / e)
                  )),
                    s.object.updateProjectionMatrix(),
                    (d = !0))
                  : (console.warn(
                    "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
                  ),
                    (s.enableZoom = !1));
            }
            function S(e) {
              b.set(e.clientX, e.clientY);
            }
            function Y(e) {
              O.set(e.clientX, e.clientY);
            }
            function k(e) {
              if (1 == e.touches.length)
                b.set(e.touches[0].pageX, e.touches[0].pageY);
              else {
                const t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                  n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
                b.set(t, n);
              }
            }
            function x(e) {
              if (1 == e.touches.length)
                O.set(e.touches[0].pageX, e.touches[0].pageY);
              else {
                const t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                  n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
                O.set(t, n);
              }
            }
            function C(e) {
              const t = e.touches[0].pageX - e.touches[1].pageX,
                n = e.touches[0].pageY - e.touches[1].pageY,
                o = Math.sqrt(t * t + n * n);
              v.set(0, o);
            }
            function H(e) {
              if (1 == e.touches.length)
                E.set(e.touches[0].pageX, e.touches[0].pageY);
              else {
                const t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                  n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
                E.set(t, n);
              }
              f.subVectors(E, b).multiplyScalar(s.rotateSpeed);
              const t = s.domElement;
              A((2 * Math.PI * f.x) / t.clientHeight),
                L((2 * Math.PI * f.y) / t.clientHeight),
                b.copy(E);
            }
            function U(e) {
              if (1 == e.touches.length)
                g.set(e.touches[0].pageX, e.touches[0].pageY);
              else {
                const t = 0.5 * (e.touches[0].pageX + e.touches[1].pageX),
                  n = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);
                g.set(t, n);
              }
              T.subVectors(g, O).multiplyScalar(s.panSpeed),
                j(T.x, T.y),
                O.copy(g);
            }
            function _(e) {
              const t = e.touches[0].pageX - e.touches[1].pageX,
                n = e.touches[0].pageY - e.touches[1].pageY,
                o = Math.sqrt(t * t + n * n);
              y.set(0, o),
                P.set(0, Math.pow(y.y / v.y, s.zoomSpeed)),
                R(P.y),
                v.copy(y);
            }
            function V(t) {
              if (!1 !== s.enabled)
                switch (t.pointerType) {
                  case "mouse":
                  case "pen":
                    !(function (t) {
                      let o;
                      switch (
                      (t.preventDefault(),
                        s.domElement.focus
                          ? s.domElement.focus()
                          : window.focus(),
                        t.button)
                      ) {
                        case 0:
                          o = s.mouseButtons.LEFT;
                          break;
                        case 1:
                          o = s.mouseButtons.MIDDLE;
                          break;
                        case 2:
                          o = s.mouseButtons.RIGHT;
                          break;
                        default:
                          o = -1;
                      }
                      switch (o) {
                        case e.MOUSE.DOLLY:
                          if (!1 === s.enableZoom) return;
                          !(function (e) {
                            v.set(e.clientX, e.clientY);
                          })(t),
                            (r = c.DOLLY);
                          break;
                        case e.MOUSE.ROTATE:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === s.enablePan) return;
                            Y(t), (r = c.PAN);
                          } else {
                            if (!1 === s.enableRotate) return;
                            S(t), (r = c.ROTATE);
                          }
                          break;
                        case e.MOUSE.PAN:
                          if (t.ctrlKey || t.metaKey || t.shiftKey) {
                            if (!1 === s.enableRotate) return;
                            S(t), (r = c.ROTATE);
                          } else {
                            if (!1 === s.enablePan) return;
                            Y(t), (r = c.PAN);
                          }
                          break;
                        default:
                          r = c.NONE;
                      }
                      r !== c.NONE &&
                        (s.domElement.ownerDocument.addEventListener(
                          "pointermove",
                          z
                        ),
                          s.domElement.ownerDocument.addEventListener(
                            "pointerup",
                            I
                          ),
                          s.dispatchEvent(n));
                    })(t);
                }
            }
            function z(e) {
              if (!1 !== s.enabled)
                switch (e.pointerType) {
                  case "mouse":
                  case "pen":
                    !(function (e) {
                      if (!1 === s.enabled) return;
                      switch ((e.preventDefault(), r)) {
                        case c.ROTATE:
                          if (!1 === s.enableRotate) return;
                          !(function (e) {
                            E.set(e.clientX, e.clientY),
                              f.subVectors(E, b).multiplyScalar(s.rotateSpeed);
                            const t = s.domElement;
                            A((2 * Math.PI * f.x) / t.clientHeight),
                              L((2 * Math.PI * f.y) / t.clientHeight),
                              b.copy(E),
                              s.update();
                          })(e);
                          break;
                        case c.DOLLY:
                          if (!1 === s.enableZoom) return;
                          !(function (e) {
                            y.set(e.clientX, e.clientY),
                              P.subVectors(y, v),
                              P.y > 0 ? R(w()) : P.y < 0 && D(w()),
                              v.copy(y),
                              s.update();
                          })(e);
                          break;
                        case c.PAN:
                          if (!1 === s.enablePan) return;
                          !(function (e) {
                            g.set(e.clientX, e.clientY),
                              T.subVectors(g, O).multiplyScalar(s.panSpeed),
                              j(T.x, T.y),
                              O.copy(g),
                              s.update();
                          })(e);
                      }
                    })(e);
                }
            }
            function I(e) {
              switch (e.pointerType) {
                case "mouse":
                case "pen":
                  !(function (e) {
                    if (
                      (s.domElement.ownerDocument.removeEventListener(
                        "pointermove",
                        z
                      ),
                        s.domElement.ownerDocument.removeEventListener(
                          "pointerup",
                          I
                        ),
                        !1 === s.enabled)
                    )
                      return;
                    s.dispatchEvent(o), (r = c.NONE);
                  })();
              }
            }
            function X(e) {
              !1 === s.enabled ||
                !1 === s.enableZoom ||
                (r !== c.NONE && r !== c.ROTATE) ||
                (e.preventDefault(),
                  s.dispatchEvent(n),
                  (function (e) {
                    e.deltaY < 0 ? D(w()) : e.deltaY > 0 && R(w()), s.update();
                  })(e),
                  s.dispatchEvent(o));
            }
            function F(e) {
              !1 !== s.enabled &&
                !1 !== s.enablePan &&
                (function (e) {
                  let t = !1;
                  switch (e.code) {
                    case s.keys.UP:
                      j(0, s.keyPanSpeed), (t = !0);
                      break;
                    case s.keys.BOTTOM:
                      j(0, -s.keyPanSpeed), (t = !0);
                      break;
                    case s.keys.LEFT:
                      j(s.keyPanSpeed, 0), (t = !0);
                      break;
                    case s.keys.RIGHT:
                      j(-s.keyPanSpeed, 0), (t = !0);
                  }
                  t && (e.preventDefault(), s.update());
                })(e);
            }
            function Z(t) {
              if (!1 !== s.enabled) {
                switch ((t.preventDefault(), t.touches.length)) {
                  case 1:
                    switch (s.touches.ONE) {
                      case e.TOUCH.ROTATE:
                        if (!1 === s.enableRotate) return;
                        k(t), (r = c.TOUCH_ROTATE);
                        break;
                      case e.TOUCH.PAN:
                        if (!1 === s.enablePan) return;
                        x(t), (r = c.TOUCH_PAN);
                        break;
                      default:
                        r = c.NONE;
                    }
                    break;
                  case 2:
                    switch (s.touches.TWO) {
                      case e.TOUCH.DOLLY_PAN:
                        if (!1 === s.enableZoom && !1 === s.enablePan) return;
                        !(function (e) {
                          s.enableZoom && C(e), s.enablePan && x(e);
                        })(t),
                          (r = c.TOUCH_DOLLY_PAN);
                        break;
                      case e.TOUCH.DOLLY_ROTATE:
                        if (!1 === s.enableZoom && !1 === s.enableRotate)
                          return;
                        !(function (e) {
                          s.enableZoom && C(e), s.enableRotate && k(e);
                        })(t),
                          (r = c.TOUCH_DOLLY_ROTATE);
                        break;
                      default:
                        r = c.NONE;
                    }
                    break;
                  default:
                    r = c.NONE;
                }
                r !== c.NONE && s.dispatchEvent(n);
              }
            }
            function K(e) {
              if (!1 !== s.enabled)
                switch ((e.preventDefault(), r)) {
                  case c.TOUCH_ROTATE:
                    if (!1 === s.enableRotate) return;
                    H(e), s.update();
                    break;
                  case c.TOUCH_PAN:
                    if (!1 === s.enablePan) return;
                    U(e), s.update();
                    break;
                  case c.TOUCH_DOLLY_PAN:
                    if (!1 === s.enableZoom && !1 === s.enablePan) return;
                    !(function (e) {
                      s.enableZoom && _(e), s.enablePan && U(e);
                    })(e),
                      s.update();
                    break;
                  case c.TOUCH_DOLLY_ROTATE:
                    if (!1 === s.enableZoom && !1 === s.enableRotate) return;
                    !(function (e) {
                      s.enableZoom && _(e), s.enableRotate && H(e);
                    })(e),
                      s.update();
                    break;
                  default:
                    r = c.NONE;
                }
            }
            function B(e) {
              !1 !== s.enabled && (s.dispatchEvent(o), (r = c.NONE));
            }
            function G(e) {
              !1 !== s.enabled && e.preventDefault();
            }
            s.domElement.addEventListener("contextmenu", G),
              s.domElement.addEventListener("pointerdown", V),
              s.domElement.addEventListener("wheel", X, { passive: !1 }),
              s.domElement.addEventListener("touchstart", Z, { passive: !1 }),
              s.domElement.addEventListener("touchend", B),
              s.domElement.addEventListener("touchmove", K, { passive: !1 }),
              this.update();
          }
        }
        exports.OrbitControls = a;
        class i extends a {
          constructor(t, n) {
            super(t, n),
              (this.screenSpacePanning = !1),
              (this.mouseButtons.LEFT = e.MOUSE.PAN),
              (this.mouseButtons.RIGHT = e.MOUSE.ROTATE),
              (this.touches.ONE = e.TOUCH.PAN),
              (this.touches.TWO = e.TOUCH.DOLLY_ROTATE);
          }
        }
        exports.MapControls = i;
      },
      { three: "gBK8" },
    ],
    WoxW: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.RGBELoader = void 0);
        var e = require("three");
        class t extends e.DataTextureLoader {
          constructor(t) {
            super(t), (this.type = e.UnsignedByteType);
          }
          parse(t) {
            const r = function (e, t) {
              switch (e) {
                case 1:
                  console.error("THREE.RGBELoader Read Error: " + (t || ""));
                  break;
                case 2:
                  console.error("THREE.RGBELoader Write Error: " + (t || ""));
                  break;
                case 3:
                  console.error(
                    "THREE.RGBELoader Bad File Format: " + (t || "")
                  );
                  break;
                default:
                case 4:
                  console.error("THREE.RGBELoader: Error: " + (t || ""));
              }
              return -1;
            },
              a = function (e, t, r) {
                t = t || 1024;
                let a = e.pos,
                  n = -1,
                  o = 0,
                  s = "",
                  i = String.fromCharCode.apply(
                    null,
                    new Uint16Array(e.subarray(a, a + 128))
                  );
                for (; 0 > (n = i.indexOf("\n")) && o < t && a < e.byteLength;)
                  (s += i),
                    (o += i.length),
                    (a += 128),
                    (i += String.fromCharCode.apply(
                      null,
                      new Uint16Array(e.subarray(a, a + 128))
                    ));
                return (
                  -1 < n &&
                  (!1 !== r && (e.pos += o + n + 1), s + i.slice(0, n))
                );
              },
              n = function (e, t, r, a) {
                const n = e[t + 3],
                  o = Math.pow(2, n - 128) / 255;
                (r[a + 0] = e[t + 0] * o),
                  (r[a + 1] = e[t + 1] * o),
                  (r[a + 2] = e[t + 2] * o);
              },
              o = function (t, r, a, n) {
                const o = t[r + 3],
                  s = Math.pow(2, o - 128) / 255;
                (a[n + 0] = e.DataUtils.toHalfFloat(t[r + 0] * s)),
                  (a[n + 1] = e.DataUtils.toHalfFloat(t[r + 1] * s)),
                  (a[n + 2] = e.DataUtils.toHalfFloat(t[r + 2] * s));
              },
              s = new Uint8Array(t);
            s.pos = 0;
            const i = (function (e) {
              const t = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                n = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                o = /^\s*FORMAT=(\S+)\s*$/,
                s = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                i = {
                  valid: 0,
                  string: "",
                  comments: "",
                  programtype: "RGBE",
                  format: "",
                  gamma: 1,
                  exposure: 1,
                  width: 0,
                  height: 0,
                };
              let l, c;
              if (e.pos >= e.byteLength || !(l = a(e)))
                return r(1, "no header found");
              if (!(c = l.match(/^#\?(\S+)/))) return r(3, "bad initial token");
              for (
                i.valid |= 1, i.programtype = c[1], i.string += l + "\n";
                !1 !== (l = a(e));

              )
                if (((i.string += l + "\n"), "#" !== l.charAt(0))) {
                  if (
                    ((c = l.match(t)) && (i.gamma = parseFloat(c[1], 10)),
                      (c = l.match(n)) && (i.exposure = parseFloat(c[1], 10)),
                      (c = l.match(o)) && ((i.valid |= 2), (i.format = c[1])),
                      (c = l.match(s)) &&
                      ((i.valid |= 4),
                        (i.height = parseInt(c[1], 10)),
                        (i.width = parseInt(c[2], 10))),
                      2 & i.valid && 4 & i.valid)
                  )
                    break;
                } else i.comments += l + "\n";
              return 2 & i.valid
                ? 4 & i.valid
                  ? i
                  : r(3, "missing image size specifier")
                : r(3, "missing format specifier");
            })(s);
            if (-1 !== i) {
              const t = i.width,
                a = i.height,
                l = (function (e, t, a) {
                  const n = t;
                  if (
                    n < 8 ||
                    n > 32767 ||
                    2 !== e[0] ||
                    2 !== e[1] ||
                    128 & e[2]
                  )
                    return new Uint8Array(e);
                  if (n !== ((e[2] << 8) | e[3]))
                    return r(3, "wrong scanline width");
                  const o = new Uint8Array(4 * t * a);
                  if (!o.length) return r(4, "unable to allocate buffer space");
                  let s = 0,
                    i = 0;
                  const l = 4 * n,
                    c = new Uint8Array(4),
                    p = new Uint8Array(l);
                  let d = a;
                  for (; d > 0 && i < e.byteLength;) {
                    if (i + 4 > e.byteLength) return r(1);
                    if (
                      ((c[0] = e[i++]),
                        (c[1] = e[i++]),
                        (c[2] = e[i++]),
                        (c[3] = e[i++]),
                        2 != c[0] || 2 != c[1] || ((c[2] << 8) | c[3]) != n)
                    )
                      return r(3, "bad rgbe scanline format");
                    let t,
                      a = 0;
                    for (; a < l && i < e.byteLength;) {
                      const n = (t = e[i++]) > 128;
                      if ((n && (t -= 128), 0 === t || a + t > l))
                        return r(3, "bad scanline data");
                      if (n) {
                        const r = e[i++];
                        for (let e = 0; e < t; e++) p[a++] = r;
                      } else p.set(e.subarray(i, i + t), a), (a += t), (i += t);
                    }
                    const f = n;
                    for (let e = 0; e < f; e++) {
                      let t = 0;
                      (o[s] = p[e + t]),
                        (t += n),
                        (o[s + 1] = p[e + t]),
                        (t += n),
                        (o[s + 2] = p[e + t]),
                        (t += n),
                        (o[s + 3] = p[e + t]),
                        (s += 4);
                    }
                    d--;
                  }
                  return o;
                })(s.subarray(s.pos), t, a);
              if (-1 !== l) {
                let r, s, c, p;
                switch (this.type) {
                  case e.UnsignedByteType:
                    (r = l), (s = e.RGBEFormat), (c = e.UnsignedByteType);
                    break;
                  case e.FloatType:
                    p = (l.length / 4) * 3;
                    const t = new Float32Array(p);
                    for (let e = 0; e < p; e++) n(l, 4 * e, t, 3 * e);
                    (r = t), (s = e.RGBFormat), (c = e.FloatType);
                    break;
                  case e.HalfFloatType:
                    p = (l.length / 4) * 3;
                    const a = new Uint16Array(p);
                    for (let e = 0; e < p; e++) o(l, 4 * e, a, 3 * e);
                    (r = a), (s = e.RGBFormat), (c = e.HalfFloatType);
                    break;
                  default:
                    console.error(
                      "THREE.RGBELoader: unsupported type: ",
                      this.type
                    );
                }
                return {
                  width: t,
                  height: a,
                  data: r,
                  header: i.string,
                  gamma: i.gamma,
                  exposure: i.exposure,
                  format: s,
                  type: c,
                };
              }
            }
            return null;
          }
          setDataType(e) {
            return (this.type = e), this;
          }
          load(t, r, a, n) {
            return super.load(
              t,
              function (t, a) {
                switch (t.type) {
                  case e.UnsignedByteType:
                    (t.encoding = e.RGBEEncoding),
                      (t.minFilter = e.NearestFilter),
                      (t.magFilter = e.NearestFilter),
                      (t.generateMipmaps = !1),
                      (t.flipY = !0);
                    break;
                  case e.FloatType:
                  case e.HalfFloatType:
                    (t.encoding = e.LinearEncoding),
                      (t.minFilter = e.LinearFilter),
                      (t.magFilter = e.LinearFilter),
                      (t.generateMipmaps = !1),
                      (t.flipY = !0);
                }
                r && r(t, a);
              },
              a,
              n
            );
          }
        }
        exports.RGBELoader = t;
      },
      { three: "gBK8" },
    ],
    tgmD: [
      function (require, module, exports) {
        "use strict";
        module.exports = (e) =>
          encodeURIComponent(e).replace(/[!'()*]/g, (e) =>
            "%".concat(e.charCodeAt(0).toString(16).toUpperCase())
          );
      },
      {},
    ],
    YtoU: [
      function (require, module, exports) {
        "use strict";
        var e = "%[a-f0-9]{2}",
          t = new RegExp(e, "gi"),
          r = new RegExp("(" + e + ")+", "gi");
        function n(e, t) {
          try {
            return decodeURIComponent(e.join(""));
          } catch (c) { }
          if (1 === e.length) return e;
          t = t || 1;
          var r = e.slice(0, t),
            o = e.slice(t);
          return Array.prototype.concat.call([], n(r), n(o));
        }
        function o(e) {
          try {
            return decodeURIComponent(e);
          } catch (c) {
            for (var r = e.match(t), o = 1; o < r.length; o++)
              r = (e = n(r, o).join("")).match(t);
            return e;
          }
        }
        function c(e) {
          for (
            var t = { "%FE%FF": "ï¿½ï¿½", "%FF%FE": "ï¿½ï¿½" }, n = r.exec(e);
            n;

          ) {
            try {
              t[n[0]] = decodeURIComponent(n[0]);
            } catch (u) {
              var c = o(n[0]);
              c !== n[0] && (t[n[0]] = c);
            }
            n = r.exec(e);
          }
          t["%C2"] = "ï¿½";
          for (var a = Object.keys(t), p = 0; p < a.length; p++) {
            var i = a[p];
            e = e.replace(new RegExp(i, "g"), t[i]);
          }
          return e;
        }
        module.exports = function (e) {
          if ("string" != typeof e)
            throw new TypeError(
              "Expected `encodedURI` to be of type `string`, got `" +
              typeof e +
              "`"
            );
          try {
            return (e = e.replace(/\+/g, " ")), decodeURIComponent(e);
          } catch (t) {
            return c(e);
          }
        };
      },
      {},
    ],
    SVkH: [
      function (require, module, exports) {
        "use strict";
        module.exports = function (e, t) {
          if ("string" != typeof e || "string" != typeof t)
            throw new TypeError(
              "Expected the arguments to be of type `string`"
            );
          if ("" === t) return [e];
          var r = e.indexOf(t);
          return -1 === r ? [e] : [e.slice(0, r), e.slice(r + t.length)];
        };
      },
      {},
    ],
    EONo: [
      function (require, module, exports) {
        "use strict";
        module.exports = function (r, e) {
          for (
            var t = {}, n = Object.keys(r), s = Array.isArray(e), a = 0;
            a < n.length;
            a++
          ) {
            var i = n[a],
              o = r[i];
            (s ? -1 !== e.indexOf(i) : e(i, o, r)) && (t[i] = o);
          }
          return t;
        };
      },
      {},
    ],
    TuMS: [
      function (require, module, exports) {
        "use strict";
        function r(r, t, e) {
          return (
            t in r
              ? Object.defineProperty(r, t, {
                value: e,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
              : (r[t] = e),
            r
          );
        }
        function t(r) {
          return (t =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (r) {
                return typeof r;
              }
              : function (r) {
                return r &&
                  "function" == typeof Symbol &&
                  r.constructor === Symbol &&
                  r !== Symbol.prototype
                  ? "symbol"
                  : typeof r;
              })(r);
        }
        function e(r) {
          return i(r) || a(r) || o(r) || n();
        }
        function n() {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }
        function o(r, t) {
          if (r) {
            if ("string" == typeof r) return u(r, t);
            var e = Object.prototype.toString.call(r).slice(8, -1);
            return (
              "Object" === e && r.constructor && (e = r.constructor.name),
              "Map" === e || "Set" === e
                ? Array.from(r)
                : "Arguments" === e ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)
                  ? u(r, t)
                  : void 0
            );
          }
        }
        function a(r) {
          if (
            ("undefined" != typeof Symbol && null != r[Symbol.iterator]) ||
            null != r["@@iterator"]
          )
            return Array.from(r);
        }
        function i(r) {
          if (Array.isArray(r)) return u(r);
        }
        function u(r, t) {
          (null == t || t > r.length) && (t = r.length);
          for (var e = 0, n = new Array(t); e < t; e++) n[e] = r[e];
          return n;
        }
        var c = require("strict-uri-encode"),
          s = require("decode-uri-component"),
          l = require("split-on-first"),
          f = require("filter-obj"),
          p = function (r) {
            return null == r;
          },
          y = Symbol("encodeFragmentIdentifier");
        function m(r) {
          switch (r.arrayFormat) {
            case "index":
              return function (t) {
                return function (n, o) {
                  var a = n.length;
                  return void 0 === o ||
                    (r.skipNull && null === o) ||
                    (r.skipEmptyString && "" === o)
                    ? n
                    : [].concat(
                      e(n),
                      null === o
                        ? [[g(t, r), "[", a, "]"].join("")]
                        : [[g(t, r), "[", g(a, r), "]=", g(o, r)].join("")]
                    );
                };
              };
            case "bracket":
              return function (t) {
                return function (n, o) {
                  return void 0 === o ||
                    (r.skipNull && null === o) ||
                    (r.skipEmptyString && "" === o)
                    ? n
                    : [].concat(
                      e(n),
                      null === o
                        ? [[g(t, r), "[]"].join("")]
                        : [[g(t, r), "[]=", g(o, r)].join("")]
                    );
                };
              };
            case "colon-list-separator":
              return function (t) {
                return function (n, o) {
                  return void 0 === o ||
                    (r.skipNull && null === o) ||
                    (r.skipEmptyString && "" === o)
                    ? n
                    : [].concat(
                      e(n),
                      null === o
                        ? [[g(t, r), ":list="].join("")]
                        : [[g(t, r), ":list=", g(o, r)].join("")]
                    );
                };
              };
            case "comma":
            case "separator":
            case "bracket-separator":
              var t = "bracket-separator" === r.arrayFormat ? "[]=" : "=";
              return function (e) {
                return function (n, o) {
                  return void 0 === o ||
                    (r.skipNull && null === o) ||
                    (r.skipEmptyString && "" === o)
                    ? n
                    : ((o = null === o ? "" : o),
                      0 === n.length
                        ? [[g(e, r), t, g(o, r)].join("")]
                        : [[n, g(o, r)].join(r.arrayFormatSeparator)]);
                };
              };
            default:
              return function (t) {
                return function (n, o) {
                  return void 0 === o ||
                    (r.skipNull && null === o) ||
                    (r.skipEmptyString && "" === o)
                    ? n
                    : [].concat(
                      e(n),
                      null === o
                        ? [g(t, r)]
                        : [[g(t, r), "=", g(o, r)].join("")]
                    );
                };
              };
          }
        }
        function d(r) {
          var t;
          switch (r.arrayFormat) {
            case "index":
              return function (r, e, n) {
                (t = /\[(\d*)\]$/.exec(r)),
                  (r = r.replace(/\[\d*\]$/, "")),
                  t
                    ? (void 0 === n[r] && (n[r] = {}), (n[r][t[1]] = e))
                    : (n[r] = e);
              };
            case "bracket":
              return function (r, e, n) {
                (t = /(\[\])$/.exec(r)),
                  (r = r.replace(/\[\]$/, "")),
                  t
                    ? void 0 !== n[r]
                      ? (n[r] = [].concat(n[r], e))
                      : (n[r] = [e])
                    : (n[r] = e);
              };
            case "colon-list-separator":
              return function (r, e, n) {
                (t = /(:list)$/.exec(r)),
                  (r = r.replace(/:list$/, "")),
                  t
                    ? void 0 !== n[r]
                      ? (n[r] = [].concat(n[r], e))
                      : (n[r] = [e])
                    : (n[r] = e);
              };
            case "comma":
            case "separator":
              return function (t, e, n) {
                var o =
                  "string" == typeof e && e.includes(r.arrayFormatSeparator),
                  a =
                    "string" == typeof e &&
                    !o &&
                    v(e, r).includes(r.arrayFormatSeparator);
                e = a ? v(e, r) : e;
                var i =
                  o || a
                    ? e.split(r.arrayFormatSeparator).map(function (t) {
                      return v(t, r);
                    })
                    : null === e
                      ? e
                      : v(e, r);
                n[t] = i;
              };
            case "bracket-separator":
              return function (t, e, n) {
                var o = /(\[\])$/.test(t);
                if (((t = t.replace(/\[\]$/, "")), o)) {
                  var a =
                    null === e
                      ? []
                      : e.split(r.arrayFormatSeparator).map(function (t) {
                        return v(t, r);
                      });
                  void 0 !== n[t] ? (n[t] = [].concat(n[t], a)) : (n[t] = a);
                } else n[t] = e ? v(e, r) : e;
              };
            default:
              return function (r, t, e) {
                void 0 !== e[r] ? (e[r] = [].concat(e[r], t)) : (e[r] = t);
              };
          }
        }
        function b(r) {
          if ("string" != typeof r || 1 !== r.length)
            throw new TypeError(
              "arrayFormatSeparator must be single character string"
            );
        }
        function g(r, t) {
          return t.encode ? (t.strict ? c(r) : encodeURIComponent(r)) : r;
        }
        function v(r, t) {
          return t.decode ? s(r) : r;
        }
        function j(r) {
          return Array.isArray(r)
            ? r.sort()
            : "object" === t(r)
              ? j(Object.keys(r))
                .sort(function (r, t) {
                  return Number(r) - Number(t);
                })
                .map(function (t) {
                  return r[t];
                })
              : r;
        }
        function k(r) {
          var t = r.indexOf("#");
          return -1 !== t && (r = r.slice(0, t)), r;
        }
        function S(r) {
          var t = "",
            e = r.indexOf("#");
          return -1 !== e && (t = r.slice(e)), t;
        }
        function x(r) {
          var t = (r = k(r)).indexOf("?");
          return -1 === t ? "" : r.slice(t + 1);
        }
        function O(r, t) {
          return (
            t.parseNumbers &&
              !Number.isNaN(Number(r)) &&
              "string" == typeof r &&
              "" !== r.trim()
              ? (r = Number(r))
              : !t.parseBooleans ||
              null === r ||
              ("true" !== r.toLowerCase() && "false" !== r.toLowerCase()) ||
              (r = "true" === r.toLowerCase()),
            r
          );
        }
        function F(r, e) {
          b(
            (e = Object.assign(
              {
                decode: !0,
                sort: !0,
                arrayFormat: "none",
                arrayFormatSeparator: ",",
                parseNumbers: !1,
                parseBooleans: !1,
              },
              e
            )).arrayFormatSeparator
          );
          var n = d(e),
            o = Object.create(null);
          if ("string" != typeof r) return o;
          if (!(r = r.trim().replace(/^[?#&]/, ""))) return o;
          for (var a of r.split("&"))
            if ("" !== a) {
              var [i, u] = l(e.decode ? a.replace(/\+/g, " ") : a, "=");
              (u =
                void 0 === u
                  ? null
                  : ["comma", "separator", "bracket-separator"].includes(
                    e.arrayFormat
                  )
                    ? u
                    : v(u, e)),
                n(v(i, e), u, o);
            }
          for (var c of Object.keys(o)) {
            var s = o[c];
            if ("object" === t(s) && null !== s)
              for (var f of Object.keys(s)) s[f] = O(s[f], e);
            else o[c] = O(s, e);
          }
          return !1 === e.sort
            ? o
            : (!0 === e.sort
              ? Object.keys(o).sort()
              : Object.keys(o).sort(e.sort)
            ).reduce(function (r, e) {
              var n = o[e];
              return (
                Boolean(n) && "object" === t(n) && !Array.isArray(n)
                  ? (r[e] = j(n))
                  : (r[e] = n),
                r
              );
            }, Object.create(null));
        }
        (exports.extract = x),
          (exports.parse = F),
          (exports.stringify = function (r, t) {
            if (!r) return "";
            b(
              (t = Object.assign(
                {
                  encode: !0,
                  strict: !0,
                  arrayFormat: "none",
                  arrayFormatSeparator: ",",
                },
                t
              )).arrayFormatSeparator
            );
            var e = function (e) {
              return (
                (t.skipNull && p(r[e])) || (t.skipEmptyString && "" === r[e])
              );
            },
              n = m(t),
              o = {};
            for (var a of Object.keys(r)) e(a) || (o[a] = r[a]);
            var i = Object.keys(o);
            return (
              !1 !== t.sort && i.sort(t.sort),
              i
                .map(function (e) {
                  var o = r[e];
                  return void 0 === o
                    ? ""
                    : null === o
                      ? g(e, t)
                      : Array.isArray(o)
                        ? 0 === o.length && "bracket-separator" === t.arrayFormat
                          ? g(e, t) + "[]"
                          : o.reduce(n(e), []).join("&")
                        : g(e, t) + "=" + g(o, t);
                })
                .filter(function (r) {
                  return r.length > 0;
                })
                .join("&")
            );
          }),
          (exports.parseUrl = function (r, t) {
            t = Object.assign({ decode: !0 }, t);
            var [e, n] = l(r, "#");
            return Object.assign(
              { url: e.split("?")[0] || "", query: F(x(r), t) },
              t && t.parseFragmentIdentifier && n
                ? { fragmentIdentifier: v(n, t) }
                : {}
            );
          }),
          (exports.stringifyUrl = function (t, e) {
            e = Object.assign(r({ encode: !0, strict: !0 }, y, !0), e);
            var n = k(t.url).split("?")[0] || "",
              o = exports.extract(t.url),
              a = exports.parse(o, { sort: !1 }),
              i = Object.assign(a, t.query),
              u = exports.stringify(i, e);
            u && (u = "?".concat(u));
            var c = S(t.url);
            return (
              t.fragmentIdentifier &&
              (c = "#".concat(
                e[y] ? g(t.fragmentIdentifier, e) : t.fragmentIdentifier
              )),
              "".concat(n).concat(u).concat(c)
            );
          }),
          (exports.pick = function (t, e, n) {
            n = Object.assign(r({ parseFragmentIdentifier: !0 }, y, !1), n);
            var {
              url: o,
              query: a,
              fragmentIdentifier: i,
            } = exports.parseUrl(t, n);
            return exports.stringifyUrl(
              { url: o, query: f(a, e), fragmentIdentifier: i },
              n
            );
          }),
          (exports.exclude = function (r, t, e) {
            var n = Array.isArray(t)
              ? function (r) {
                return !t.includes(r);
              }
              : function (r, e) {
                return !t(r, e);
              };
            return exports.pick(r, n, e);
          });
      },
      {
        "strict-uri-encode": "tgmD",
        "decode-uri-component": "YtoU",
        "split-on-first": "SVkH",
        "filter-obj": "EONo",
      },
    ],
    ArXC: [
      function (require, module, exports) {
        "use strict";
        function e(e) {
          if (e && "undefined" != typeof window) {
            var t = document.createElement("style");
            return (
              t.setAttribute("type", "text/css"),
              (t.innerHTML = e),
              document.head.appendChild(t),
              e
            );
          }
        }
        function t(e, t) {
          var n = e.__state.conversionName.toString(),
            o = Math.round(e.r),
            i = Math.round(e.g),
            r = Math.round(e.b),
            s = e.a,
            a = Math.round(e.h),
            l = e.s.toFixed(1),
            d = e.v.toFixed(1);
          if (t || "THREE_CHAR_HEX" === n || "SIX_CHAR_HEX" === n) {
            for (var c = e.hex.toString(16); c.length < 6;) c = "0" + c;
            return "#" + c;
          }
          return "CSS_RGB" === n
            ? "rgb(" + o + "," + i + "," + r + ")"
            : "CSS_RGBA" === n
              ? "rgba(" + o + "," + i + "," + r + "," + s + ")"
              : "HEX" === n
                ? "0x" + e.hex.toString(16)
                : "RGB_ARRAY" === n
                  ? "[" + o + "," + i + "," + r + "]"
                  : "RGBA_ARRAY" === n
                    ? "[" + o + "," + i + "," + r + "," + s + "]"
                    : "RGB_OBJ" === n
                      ? "{r:" + o + ",g:" + i + ",b:" + r + "}"
                      : "RGBA_OBJ" === n
                        ? "{r:" + o + ",g:" + i + ",b:" + r + ",a:" + s + "}"
                        : "HSV_OBJ" === n
                          ? "{h:" + a + ",s:" + l + ",v:" + d + "}"
                          : "HSVA_OBJ" === n
                            ? "{h:" + a + ",s:" + l + ",v:" + d + ",a:" + s + "}"
                            : "unknown format";
        }
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.gui =
            exports.dom =
            exports.default =
            exports.controllers =
            exports.color =
            exports.GUI =
            void 0);
        var n = Array.prototype.forEach,
          o = Array.prototype.slice,
          i = {
            BREAK: {},
            extend: function (e) {
              return (
                this.each(
                  o.call(arguments, 1),
                  function (t) {
                    (this.isObject(t) ? Object.keys(t) : []).forEach(
                      function (n) {
                        this.isUndefined(t[n]) || (e[n] = t[n]);
                      }.bind(this)
                    );
                  },
                  this
                ),
                e
              );
            },
            defaults: function (e) {
              return (
                this.each(
                  o.call(arguments, 1),
                  function (t) {
                    (this.isObject(t) ? Object.keys(t) : []).forEach(
                      function (n) {
                        this.isUndefined(e[n]) && (e[n] = t[n]);
                      }.bind(this)
                    );
                  },
                  this
                ),
                e
              );
            },
            compose: function () {
              var e = o.call(arguments);
              return function () {
                for (var t = o.call(arguments), n = e.length - 1; n >= 0; n--)
                  t = [e[n].apply(this, t)];
                return t[0];
              };
            },
            each: function (e, t, o) {
              if (e)
                if (n && e.forEach && e.forEach === n) e.forEach(t, o);
                else if (e.length === e.length + 0) {
                  var i,
                    r = void 0;
                  for (r = 0, i = e.length; r < i; r++)
                    if (r in e && t.call(o, e[r], r) === this.BREAK) return;
                } else
                  for (var s in e)
                    if (t.call(o, e[s], s) === this.BREAK) return;
            },
            defer: function (e) {
              setTimeout(e, 0);
            },
            debounce: function (e, t, n) {
              var o = void 0;
              return function () {
                var i = this,
                  r = arguments;
                var s = n || !o;
                clearTimeout(o),
                  (o = setTimeout(function () {
                    (o = null), n || e.apply(i, r);
                  }, t)),
                  s && e.apply(i, r);
              };
            },
            toArray: function (e) {
              return e.toArray ? e.toArray() : o.call(e);
            },
            isUndefined: function (e) {
              return void 0 === e;
            },
            isNull: function (e) {
              return null === e;
            },
            isNaN: (function (e) {
              function t(t) {
                return e.apply(this, arguments);
              }
              return (
                (t.toString = function () {
                  return e.toString();
                }),
                t
              );
            })(function (e) {
              return isNaN(e);
            }),
            isArray:
              Array.isArray ||
              function (e) {
                return e.constructor === Array;
              },
            isObject: function (e) {
              return e === Object(e);
            },
            isNumber: function (e) {
              return e === e + 0;
            },
            isString: function (e) {
              return e === e + "";
            },
            isBoolean: function (e) {
              return !1 === e || !0 === e;
            },
            isFunction: function (e) {
              return e instanceof Function;
            },
          },
          r = [
            {
              litmus: i.isString,
              conversions: {
                THREE_CHAR_HEX: {
                  read: function (e) {
                    var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                    return (
                      null !== t && {
                        space: "HEX",
                        hex: parseInt(
                          "0x" +
                          t[1].toString() +
                          t[1].toString() +
                          t[2].toString() +
                          t[2].toString() +
                          t[3].toString() +
                          t[3].toString(),
                          0
                        ),
                      }
                    );
                  },
                  write: t,
                },
                SIX_CHAR_HEX: {
                  read: function (e) {
                    var t = e.match(/^#([A-F0-9]{6})$/i);
                    return (
                      null !== t && {
                        space: "HEX",
                        hex: parseInt("0x" + t[1].toString(), 0),
                      }
                    );
                  },
                  write: t,
                },
                CSS_RGB: {
                  read: function (e) {
                    var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                    return (
                      null !== t && {
                        space: "RGB",
                        r: parseFloat(t[1]),
                        g: parseFloat(t[2]),
                        b: parseFloat(t[3]),
                      }
                    );
                  },
                  write: t,
                },
                CSS_RGBA: {
                  read: function (e) {
                    var t = e.match(
                      /^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/
                    );
                    return (
                      null !== t && {
                        space: "RGB",
                        r: parseFloat(t[1]),
                        g: parseFloat(t[2]),
                        b: parseFloat(t[3]),
                        a: parseFloat(t[4]),
                      }
                    );
                  },
                  write: t,
                },
              },
            },
            {
              litmus: i.isNumber,
              conversions: {
                HEX: {
                  read: function (e) {
                    return { space: "HEX", hex: e, conversionName: "HEX" };
                  },
                  write: function (e) {
                    return e.hex;
                  },
                },
              },
            },
            {
              litmus: i.isArray,
              conversions: {
                RGB_ARRAY: {
                  read: function (e) {
                    return (
                      3 === e.length && {
                        space: "RGB",
                        r: e[0],
                        g: e[1],
                        b: e[2],
                      }
                    );
                  },
                  write: function (e) {
                    return [e.r, e.g, e.b];
                  },
                },
                RGBA_ARRAY: {
                  read: function (e) {
                    return (
                      4 === e.length && {
                        space: "RGB",
                        r: e[0],
                        g: e[1],
                        b: e[2],
                        a: e[3],
                      }
                    );
                  },
                  write: function (e) {
                    return [e.r, e.g, e.b, e.a];
                  },
                },
              },
            },
            {
              litmus: i.isObject,
              conversions: {
                RGBA_OBJ: {
                  read: function (e) {
                    return (
                      !!(
                        i.isNumber(e.r) &&
                        i.isNumber(e.g) &&
                        i.isNumber(e.b) &&
                        i.isNumber(e.a)
                      ) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a }
                    );
                  },
                  write: function (e) {
                    return { r: e.r, g: e.g, b: e.b, a: e.a };
                  },
                },
                RGB_OBJ: {
                  read: function (e) {
                    return (
                      !!(
                        i.isNumber(e.r) &&
                        i.isNumber(e.g) &&
                        i.isNumber(e.b)
                      ) && { space: "RGB", r: e.r, g: e.g, b: e.b }
                    );
                  },
                  write: function (e) {
                    return { r: e.r, g: e.g, b: e.b };
                  },
                },
                HSVA_OBJ: {
                  read: function (e) {
                    return (
                      !!(
                        i.isNumber(e.h) &&
                        i.isNumber(e.s) &&
                        i.isNumber(e.v) &&
                        i.isNumber(e.a)
                      ) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a }
                    );
                  },
                  write: function (e) {
                    return { h: e.h, s: e.s, v: e.v, a: e.a };
                  },
                },
                HSV_OBJ: {
                  read: function (e) {
                    return (
                      !!(
                        i.isNumber(e.h) &&
                        i.isNumber(e.s) &&
                        i.isNumber(e.v)
                      ) && { space: "HSV", h: e.h, s: e.s, v: e.v }
                    );
                  },
                  write: function (e) {
                    return { h: e.h, s: e.s, v: e.v };
                  },
                },
              },
            },
          ],
          s = void 0,
          a = void 0,
          l = function () {
            a = !1;
            var e = arguments.length > 1 ? i.toArray(arguments) : arguments[0];
            return (
              i.each(r, function (t) {
                if (t.litmus(e))
                  return (
                    i.each(t.conversions, function (t, n) {
                      if (((s = t.read(e)), !1 === a && !1 !== s))
                        return (
                          (a = s),
                          (s.conversionName = n),
                          (s.conversion = t),
                          i.BREAK
                        );
                    }),
                    i.BREAK
                  );
              }),
              a
            );
          },
          d = void 0,
          c = {
            hsv_to_rgb: function (e, t, n) {
              var o = Math.floor(e / 60) % 6,
                i = e / 60 - Math.floor(e / 60),
                r = n * (1 - t),
                s = n * (1 - i * t),
                a = n * (1 - (1 - i) * t),
                l = [
                  [n, a, r],
                  [s, n, r],
                  [r, n, a],
                  [r, s, n],
                  [a, r, n],
                  [n, r, s],
                ][o];
              return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] };
            },
            rgb_to_hsv: function (e, t, n) {
              var o = Math.min(e, t, n),
                i = Math.max(e, t, n),
                r = i - o,
                s = void 0;
              return 0 === i
                ? { h: NaN, s: 0, v: 0 }
                : ((s =
                  e === i
                    ? (t - n) / r
                    : t === i
                      ? 2 + (n - e) / r
                      : 4 + (e - t) / r),
                  (s /= 6) < 0 && (s += 1),
                  { h: 360 * s, s: r / i, v: i / 255 });
            },
            rgb_to_hex: function (e, t, n) {
              var o = this.hex_with_component(0, 2, e);
              return (
                (o = this.hex_with_component(o, 1, t)),
                (o = this.hex_with_component(o, 0, n))
              );
            },
            component_from_hex: function (e, t) {
              return (e >> (8 * t)) & 255;
            },
            hex_with_component: function (e, t, n) {
              return (n << (d = 8 * t)) | (e & ~(255 << d));
            },
          },
          u =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                return typeof e;
              }
              : function (e) {
                return e &&
                  "function" == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? "symbol"
                  : typeof e;
              },
          _ = function (e, t) {
            if (!(e instanceof t))
              throw new TypeError("Cannot call a class as a function");
          },
          h = (function () {
            function e(e, t) {
              for (var n = 0; n < t.length; n++) {
                var o = t[n];
                (o.enumerable = o.enumerable || !1),
                  (o.configurable = !0),
                  "value" in o && (o.writable = !0),
                  Object.defineProperty(e, o.key, o);
              }
            }
            return function (t, n, o) {
              return n && e(t.prototype, n), o && e(t, o), t;
            };
          })(),
          p = function e(t, n, o) {
            null === t && (t = Function.prototype);
            var i = Object.getOwnPropertyDescriptor(t, n);
            if (void 0 === i) {
              var r = Object.getPrototypeOf(t);
              return null === r ? void 0 : e(r, n, o);
            }
            if ("value" in i) return i.value;
            var s = i.get;
            return void 0 !== s ? s.call(o) : void 0;
          },
          f = function (e, t) {
            if ("function" != typeof t && null !== t)
              throw new TypeError(
                "Super expression must either be null or a function, not " +
                typeof t
              );
            (e.prototype = Object.create(t && t.prototype, {
              constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
              t &&
              (Object.setPrototypeOf
                ? Object.setPrototypeOf(e, t)
                : (e.__proto__ = t));
          },
          m = function (e, t) {
            if (!e)
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            return !t || ("object" != typeof t && "function" != typeof t)
              ? e
              : t;
          },
          g = (function () {
            function e() {
              if (
                (_(this, e),
                  (this.__state = l.apply(this, arguments)),
                  !1 === this.__state)
              )
                throw new Error("Failed to interpret color arguments");
              this.__state.a = this.__state.a || 1;
            }
            return (
              h(e, [
                {
                  key: "toString",
                  value: function () {
                    return t(this);
                  },
                },
                {
                  key: "toHexString",
                  value: function () {
                    return t(this, !0);
                  },
                },
                {
                  key: "toOriginal",
                  value: function () {
                    return this.__state.conversion.write(this);
                  },
                },
              ]),
              e
            );
          })();
        function b(e, t, n) {
          Object.defineProperty(e, t, {
            get: function () {
              return "RGB" === this.__state.space
                ? this.__state[t]
                : (g.recalculateRGB(this, t, n), this.__state[t]);
            },
            set: function (e) {
              "RGB" !== this.__state.space &&
                (g.recalculateRGB(this, t, n), (this.__state.space = "RGB")),
                (this.__state[t] = e);
            },
          });
        }
        function v(e, t) {
          Object.defineProperty(e, t, {
            get: function () {
              return "HSV" === this.__state.space
                ? this.__state[t]
                : (g.recalculateHSV(this), this.__state[t]);
            },
            set: function (e) {
              "HSV" !== this.__state.space &&
                (g.recalculateHSV(this), (this.__state.space = "HSV")),
                (this.__state[t] = e);
            },
          });
        }
        (g.recalculateRGB = function (e, t, n) {
          if ("HEX" === e.__state.space)
            e.__state[t] = c.component_from_hex(e.__state.hex, n);
          else {
            if ("HSV" !== e.__state.space)
              throw new Error("Corrupted color state");
            i.extend(
              e.__state,
              c.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)
            );
          }
        }),
          (g.recalculateHSV = function (e) {
            var t = c.rgb_to_hsv(e.r, e.g, e.b);
            i.extend(e.__state, { s: t.s, v: t.v }),
              i.isNaN(t.h)
                ? i.isUndefined(e.__state.h) && (e.__state.h = 0)
                : (e.__state.h = t.h);
          }),
          (g.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"]),
          b(g.prototype, "r", 2),
          b(g.prototype, "g", 1),
          b(g.prototype, "b", 0),
          v(g.prototype, "h"),
          v(g.prototype, "s"),
          v(g.prototype, "v"),
          Object.defineProperty(g.prototype, "a", {
            get: function () {
              return this.__state.a;
            },
            set: function (e) {
              this.__state.a = e;
            },
          }),
          Object.defineProperty(g.prototype, "hex", {
            get: function () {
              return (
                "HEX" !== this.__state.space &&
                ((this.__state.hex = c.rgb_to_hex(this.r, this.g, this.b)),
                  (this.__state.space = "HEX")),
                this.__state.hex
              );
            },
            set: function (e) {
              (this.__state.space = "HEX"), (this.__state.hex = e);
            },
          });
        var y = (function () {
          function e(t, n) {
            _(this, e),
              (this.initialValue = t[n]),
              (this.domElement = document.createElement("div")),
              (this.object = t),
              (this.property = n),
              (this.__onChange = void 0),
              (this.__onFinishChange = void 0);
          }
          return (
            h(e, [
              {
                key: "onChange",
                value: function (e) {
                  return (this.__onChange = e), this;
                },
              },
              {
                key: "onFinishChange",
                value: function (e) {
                  return (this.__onFinishChange = e), this;
                },
              },
              {
                key: "setValue",
                value: function (e) {
                  return (
                    (this.object[this.property] = e),
                    this.__onChange && this.__onChange.call(this, e),
                    this.updateDisplay(),
                    this
                  );
                },
              },
              {
                key: "getValue",
                value: function () {
                  return this.object[this.property];
                },
              },
              {
                key: "updateDisplay",
                value: function () {
                  return this;
                },
              },
              {
                key: "isModified",
                value: function () {
                  return this.initialValue !== this.getValue();
                },
              },
            ]),
            e
          );
        })(),
          w = {
            HTMLEvents: ["change"],
            MouseEvents: [
              "click",
              "mousemove",
              "mousedown",
              "mouseup",
              "mouseover",
            ],
            KeyboardEvents: ["keydown"],
          },
          x = {};
        i.each(w, function (e, t) {
          i.each(e, function (e) {
            x[e] = t;
          });
        });
        var E = /(\d+(\.\d+)?)px/;
        function C(e) {
          if ("0" === e || i.isUndefined(e)) return 0;
          var t = e.match(E);
          return i.isNull(t) ? 0 : parseFloat(t[1]);
        }
        var A = {
          makeSelectable: function (e, t) {
            void 0 !== e &&
              void 0 !== e.style &&
              ((e.onselectstart = t
                ? function () {
                  return !1;
                }
                : function () { }),
                (e.style.MozUserSelect = t ? "auto" : "none"),
                (e.style.KhtmlUserSelect = t ? "auto" : "none"),
                (e.unselectable = t ? "on" : "off"));
          },
          makeFullscreen: function (e, t, n) {
            var o = n,
              r = t;
            i.isUndefined(r) && (r = !0),
              i.isUndefined(o) && (o = !0),
              (e.style.position = "absolute"),
              r && ((e.style.left = 0), (e.style.right = 0)),
              o && ((e.style.top = 0), (e.style.bottom = 0));
          },
          fakeEvent: function (e, t, n, o) {
            var r = n || {},
              s = x[t];
            if (!s) throw new Error("Event type " + t + " not supported.");
            var a = document.createEvent(s);
            switch (s) {
              case "MouseEvents":
                var l = r.x || r.clientX || 0,
                  d = r.y || r.clientY || 0;
                a.initMouseEvent(
                  t,
                  r.bubbles || !1,
                  r.cancelable || !0,
                  window,
                  r.clickCount || 1,
                  0,
                  0,
                  l,
                  d,
                  !1,
                  !1,
                  !1,
                  !1,
                  0,
                  null
                );
                break;
              case "KeyboardEvents":
                var c = a.initKeyboardEvent || a.initKeyEvent;
                i.defaults(r, {
                  cancelable: !0,
                  ctrlKey: !1,
                  altKey: !1,
                  shiftKey: !1,
                  metaKey: !1,
                  keyCode: void 0,
                  charCode: void 0,
                }),
                  c(
                    t,
                    r.bubbles || !1,
                    r.cancelable,
                    window,
                    r.ctrlKey,
                    r.altKey,
                    r.shiftKey,
                    r.metaKey,
                    r.keyCode,
                    r.charCode
                  );
                break;
              default:
                a.initEvent(t, r.bubbles || !1, r.cancelable || !0);
            }
            i.defaults(a, o), e.dispatchEvent(a);
          },
          bind: function (e, t, n, o) {
            var i = o || !1;
            return (
              e.addEventListener
                ? e.addEventListener(t, n, i)
                : e.attachEvent && e.attachEvent("on" + t, n),
              A
            );
          },
          unbind: function (e, t, n, o) {
            var i = o || !1;
            return (
              e.removeEventListener
                ? e.removeEventListener(t, n, i)
                : e.detachEvent && e.detachEvent("on" + t, n),
              A
            );
          },
          addClass: function (e, t) {
            if (void 0 === e.className) e.className = t;
            else if (e.className !== t) {
              var n = e.className.split(/ +/);
              -1 === n.indexOf(t) &&
                (n.push(t),
                  (e.className = n
                    .join(" ")
                    .replace(/^\s+/, "")
                    .replace(/\s+$/, "")));
            }
            return A;
          },
          removeClass: function (e, t) {
            if (t)
              if (e.className === t) e.removeAttribute("class");
              else {
                var n = e.className.split(/ +/),
                  o = n.indexOf(t);
                -1 !== o && (n.splice(o, 1), (e.className = n.join(" ")));
              }
            else e.className = void 0;
            return A;
          },
          hasClass: function (e, t) {
            return (
              new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) ||
              !1
            );
          },
          getWidth: function (e) {
            var t = getComputedStyle(e);
            return (
              C(t["border-left-width"]) +
              C(t["border-right-width"]) +
              C(t["padding-left"]) +
              C(t["padding-right"]) +
              C(t.width)
            );
          },
          getHeight: function (e) {
            var t = getComputedStyle(e);
            return (
              C(t["border-top-width"]) +
              C(t["border-bottom-width"]) +
              C(t["padding-top"]) +
              C(t["padding-bottom"]) +
              C(t.height)
            );
          },
          getOffset: function (e) {
            var t = e,
              n = { left: 0, top: 0 };
            if (t.offsetParent)
              do {
                (n.left += t.offsetLeft),
                  (n.top += t.offsetTop),
                  (t = t.offsetParent);
              } while (t);
            return n;
          },
          isActive: function (e) {
            return e === document.activeElement && (e.type || e.href);
          },
        },
          k = (function (e) {
            function t(e, n) {
              _(this, t);
              var o = m(
                this,
                (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
              ),
                i = o;
              return (
                (o.__prev = o.getValue()),
                (o.__checkbox = document.createElement("input")),
                o.__checkbox.setAttribute("type", "checkbox"),
                A.bind(
                  o.__checkbox,
                  "change",
                  function () {
                    i.setValue(!i.__prev);
                  },
                  !1
                ),
                o.domElement.appendChild(o.__checkbox),
                o.updateDisplay(),
                o
              );
            }
            return (
              f(t, y),
              h(t, [
                {
                  key: "setValue",
                  value: function (e) {
                    var n = p(
                      t.prototype.__proto__ ||
                      Object.getPrototypeOf(t.prototype),
                      "setValue",
                      this
                    ).call(this, e);
                    return (
                      this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                      (this.__prev = this.getValue()),
                      n
                    );
                  },
                },
                {
                  key: "updateDisplay",
                  value: function () {
                    return (
                      !0 === this.getValue()
                        ? (this.__checkbox.setAttribute("checked", "checked"),
                          (this.__checkbox.checked = !0),
                          (this.__prev = !0))
                        : ((this.__checkbox.checked = !1), (this.__prev = !1)),
                      p(
                        t.prototype.__proto__ ||
                        Object.getPrototypeOf(t.prototype),
                        "updateDisplay",
                        this
                      ).call(this)
                    );
                  },
                },
              ]),
              t
            );
          })(),
          S = (function (e) {
            function t(e, n, o) {
              _(this, t);
              var r = m(
                this,
                (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
              ),
                s = o,
                a = r;
              if (
                ((r.__select = document.createElement("select")), i.isArray(s))
              ) {
                var l = {};
                i.each(s, function (e) {
                  l[e] = e;
                }),
                  (s = l);
              }
              return (
                i.each(s, function (e, t) {
                  var n = document.createElement("option");
                  (n.innerHTML = t),
                    n.setAttribute("value", e),
                    a.__select.appendChild(n);
                }),
                r.updateDisplay(),
                A.bind(r.__select, "change", function () {
                  var e = this.options[this.selectedIndex].value;
                  a.setValue(e);
                }),
                r.domElement.appendChild(r.__select),
                r
              );
            }
            return (
              f(t, y),
              h(t, [
                {
                  key: "setValue",
                  value: function (e) {
                    var n = p(
                      t.prototype.__proto__ ||
                      Object.getPrototypeOf(t.prototype),
                      "setValue",
                      this
                    ).call(this, e);
                    return (
                      this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue()),
                      n
                    );
                  },
                },
                {
                  key: "updateDisplay",
                  value: function () {
                    return A.isActive(this.__select)
                      ? this
                      : ((this.__select.value = this.getValue()),
                        p(
                          t.prototype.__proto__ ||
                          Object.getPrototypeOf(t.prototype),
                          "updateDisplay",
                          this
                        ).call(this));
                  },
                },
              ]),
              t
            );
          })(),
          O = (function (e) {
            function t(e, n) {
              _(this, t);
              var o = m(
                this,
                (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
              ),
                i = o;
              function r() {
                i.setValue(i.__input.value);
              }
              return (
                (o.__input = document.createElement("input")),
                o.__input.setAttribute("type", "text"),
                A.bind(o.__input, "keyup", r),
                A.bind(o.__input, "change", r),
                A.bind(o.__input, "blur", function () {
                  i.__onFinishChange &&
                    i.__onFinishChange.call(i, i.getValue());
                }),
                A.bind(o.__input, "keydown", function (e) {
                  13 === e.keyCode && this.blur();
                }),
                o.updateDisplay(),
                o.domElement.appendChild(o.__input),
                o
              );
            }
            return (
              f(t, y),
              h(t, [
                {
                  key: "updateDisplay",
                  value: function () {
                    return (
                      A.isActive(this.__input) ||
                      (this.__input.value = this.getValue()),
                      p(
                        t.prototype.__proto__ ||
                        Object.getPrototypeOf(t.prototype),
                        "updateDisplay",
                        this
                      ).call(this)
                    );
                  },
                },
              ]),
              t
            );
          })();
        function T(e) {
          var t = e.toString();
          return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0;
        }
        var L = (function (e) {
          function t(e, n, o) {
            _(this, t);
            var r = m(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
            ),
              s = o || {};
            return (
              (r.__min = s.min),
              (r.__max = s.max),
              (r.__step = s.step),
              i.isUndefined(r.__step)
                ? 0 === r.initialValue
                  ? (r.__impliedStep = 1)
                  : (r.__impliedStep =
                    Math.pow(
                      10,
                      Math.floor(
                        Math.log(Math.abs(r.initialValue)) / Math.LN10
                      )
                    ) / 10)
                : (r.__impliedStep = r.__step),
              (r.__precision = T(r.__impliedStep)),
              r
            );
          }
          return (
            f(t, y),
            h(t, [
              {
                key: "setValue",
                value: function (e) {
                  var n = e;
                  return (
                    void 0 !== this.__min && n < this.__min
                      ? (n = this.__min)
                      : void 0 !== this.__max &&
                      n > this.__max &&
                      (n = this.__max),
                    void 0 !== this.__step &&
                    n % this.__step != 0 &&
                    (n = Math.round(n / this.__step) * this.__step),
                    p(
                      t.prototype.__proto__ ||
                      Object.getPrototypeOf(t.prototype),
                      "setValue",
                      this
                    ).call(this, n)
                  );
                },
              },
              {
                key: "min",
                value: function (e) {
                  return (this.__min = e), this;
                },
              },
              {
                key: "max",
                value: function (e) {
                  return (this.__max = e), this;
                },
              },
              {
                key: "step",
                value: function (e) {
                  return (
                    (this.__step = e),
                    (this.__impliedStep = e),
                    (this.__precision = T(e)),
                    this
                  );
                },
              },
            ]),
            t
          );
        })();
        function R(e, t) {
          var n = Math.pow(10, t);
          return Math.round(e * n) / n;
        }
        var B = (function (e) {
          function t(e, n, o) {
            _(this, t);
            var r = m(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, o)
            );
            r.__truncationSuspended = !1;
            var s = r,
              a = void 0;
            function l() {
              s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
            }
            function d(e) {
              var t = a - e.clientY;
              s.setValue(s.getValue() + t * s.__impliedStep), (a = e.clientY);
            }
            function c() {
              A.unbind(window, "mousemove", d),
                A.unbind(window, "mouseup", c),
                l();
            }
            return (
              (r.__input = document.createElement("input")),
              r.__input.setAttribute("type", "text"),
              A.bind(r.__input, "change", function () {
                var e = parseFloat(s.__input.value);
                i.isNaN(e) || s.setValue(e);
              }),
              A.bind(r.__input, "blur", function () {
                l();
              }),
              A.bind(r.__input, "mousedown", function (e) {
                A.bind(window, "mousemove", d),
                  A.bind(window, "mouseup", c),
                  (a = e.clientY);
              }),
              A.bind(r.__input, "keydown", function (e) {
                13 === e.keyCode &&
                  ((s.__truncationSuspended = !0),
                    this.blur(),
                    (s.__truncationSuspended = !1),
                    l());
              }),
              r.updateDisplay(),
              r.domElement.appendChild(r.__input),
              r
            );
          }
          return (
            f(t, L),
            h(t, [
              {
                key: "updateDisplay",
                value: function () {
                  return (
                    (this.__input.value = this.__truncationSuspended
                      ? this.getValue()
                      : R(this.getValue(), this.__precision)),
                    p(
                      t.prototype.__proto__ ||
                      Object.getPrototypeOf(t.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            t
          );
        })();
        function N(e, t, n, o, i) {
          return o + ((e - t) / (n - t)) * (i - o);
        }
        var H = (function (e) {
          function t(e, n, o, i, r) {
            _(this, t);
            var s = m(
              this,
              (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n, {
                min: o,
                max: i,
                step: r,
              })
            ),
              a = s;
            function l(e) {
              e.preventDefault();
              var t = a.__background.getBoundingClientRect();
              return (
                a.setValue(N(e.clientX, t.left, t.right, a.__min, a.__max)),
                !1
              );
            }
            function d() {
              A.unbind(window, "mousemove", l),
                A.unbind(window, "mouseup", d),
                a.__onFinishChange &&
                a.__onFinishChange.call(a, a.getValue());
            }
            function c(e) {
              var t = e.touches[0].clientX,
                n = a.__background.getBoundingClientRect();
              a.setValue(N(t, n.left, n.right, a.__min, a.__max));
            }
            function u() {
              A.unbind(window, "touchmove", c),
                A.unbind(window, "touchend", u),
                a.__onFinishChange &&
                a.__onFinishChange.call(a, a.getValue());
            }
            return (
              (s.__background = document.createElement("div")),
              (s.__foreground = document.createElement("div")),
              A.bind(s.__background, "mousedown", function (e) {
                document.activeElement.blur(),
                  A.bind(window, "mousemove", l),
                  A.bind(window, "mouseup", d),
                  l(e);
              }),
              A.bind(s.__background, "touchstart", function (e) {
                if (1 !== e.touches.length) return;
                A.bind(window, "touchmove", c),
                  A.bind(window, "touchend", u),
                  c(e);
              }),
              A.addClass(s.__background, "slider"),
              A.addClass(s.__foreground, "slider-fg"),
              s.updateDisplay(),
              s.__background.appendChild(s.__foreground),
              s.domElement.appendChild(s.__background),
              s
            );
          }
          return (
            f(t, L),
            h(t, [
              {
                key: "updateDisplay",
                value: function () {
                  var e =
                    (this.getValue() - this.__min) /
                    (this.__max - this.__min);
                  return (
                    (this.__foreground.style.width = 100 * e + "%"),
                    p(
                      t.prototype.__proto__ ||
                      Object.getPrototypeOf(t.prototype),
                      "updateDisplay",
                      this
                    ).call(this)
                  );
                },
              },
            ]),
            t
          );
        })(),
          F = (function (e) {
            function t(e, n, o) {
              _(this, t);
              var i = m(
                this,
                (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
              ),
                r = i;
              return (
                (i.__button = document.createElement("div")),
                (i.__button.innerHTML = void 0 === o ? "Fire" : o),
                A.bind(i.__button, "click", function (e) {
                  return e.preventDefault(), r.fire(), !1;
                }),
                A.addClass(i.__button, "button"),
                i.domElement.appendChild(i.__button),
                i
              );
            }
            return (
              f(t, y),
              h(t, [
                {
                  key: "fire",
                  value: function () {
                    this.__onChange && this.__onChange.call(this),
                      this.getValue().call(this.object),
                      this.__onFinishChange &&
                      this.__onFinishChange.call(this, this.getValue());
                  },
                },
              ]),
              t
            );
          })(),
          P = (function (e) {
            function t(e, n) {
              _(this, t);
              var o = m(
                this,
                (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, n)
              );
              (o.__color = new g(o.getValue())), (o.__temp = new g(0));
              var r = o;
              (o.domElement = document.createElement("div")),
                A.makeSelectable(o.domElement, !1),
                (o.__selector = document.createElement("div")),
                (o.__selector.className = "selector"),
                (o.__saturation_field = document.createElement("div")),
                (o.__saturation_field.className = "saturation-field"),
                (o.__field_knob = document.createElement("div")),
                (o.__field_knob.className = "field-knob"),
                (o.__field_knob_border = "2px solid "),
                (o.__hue_knob = document.createElement("div")),
                (o.__hue_knob.className = "hue-knob"),
                (o.__hue_field = document.createElement("div")),
                (o.__hue_field.className = "hue-field"),
                (o.__input = document.createElement("input")),
                (o.__input.type = "text"),
                (o.__input_textShadow = "0 1px 1px "),
                A.bind(o.__input, "keydown", function (e) {
                  13 === e.keyCode && h.call(this);
                }),
                A.bind(o.__input, "blur", h),
                A.bind(o.__selector, "mousedown", function () {
                  A.addClass(this, "drag").bind(window, "mouseup", function () {
                    A.removeClass(r.__selector, "drag");
                  });
                }),
                A.bind(o.__selector, "touchstart", function () {
                  A.addClass(this, "drag").bind(
                    window,
                    "touchend",
                    function () {
                      A.removeClass(r.__selector, "drag");
                    }
                  );
                });
              var s = document.createElement("div");
              function a(e) {
                f(e),
                  A.bind(window, "mousemove", f),
                  A.bind(window, "touchmove", f),
                  A.bind(window, "mouseup", c),
                  A.bind(window, "touchend", c);
              }
              function d(e) {
                b(e),
                  A.bind(window, "mousemove", b),
                  A.bind(window, "touchmove", b),
                  A.bind(window, "mouseup", u),
                  A.bind(window, "touchend", u);
              }
              function c() {
                A.unbind(window, "mousemove", f),
                  A.unbind(window, "touchmove", f),
                  A.unbind(window, "mouseup", c),
                  A.unbind(window, "touchend", c),
                  p();
              }
              function u() {
                A.unbind(window, "mousemove", b),
                  A.unbind(window, "touchmove", b),
                  A.unbind(window, "mouseup", u),
                  A.unbind(window, "touchend", u),
                  p();
              }
              function h() {
                var e = l(this.value);
                !1 !== e
                  ? ((r.__color.__state = e),
                    r.setValue(r.__color.toOriginal()))
                  : (this.value = r.__color.toString());
              }
              function p() {
                r.__onFinishChange &&
                  r.__onFinishChange.call(r, r.__color.toOriginal());
              }
              function f(e) {
                -1 === e.type.indexOf("touch") && e.preventDefault();
                var t = r.__saturation_field.getBoundingClientRect(),
                  n = (e.touches && e.touches[0]) || e,
                  o = n.clientX,
                  i = n.clientY,
                  s = (o - t.left) / (t.right - t.left),
                  a = 1 - (i - t.top) / (t.bottom - t.top);
                return (
                  a > 1 ? (a = 1) : a < 0 && (a = 0),
                  s > 1 ? (s = 1) : s < 0 && (s = 0),
                  (r.__color.v = a),
                  (r.__color.s = s),
                  r.setValue(r.__color.toOriginal()),
                  !1
                );
              }
              function b(e) {
                -1 === e.type.indexOf("touch") && e.preventDefault();
                var t = r.__hue_field.getBoundingClientRect(),
                  n =
                    1 -
                    (((e.touches && e.touches[0]) || e).clientY - t.top) /
                    (t.bottom - t.top);
                return (
                  n > 1 ? (n = 1) : n < 0 && (n = 0),
                  (r.__color.h = 360 * n),
                  r.setValue(r.__color.toOriginal()),
                  !1
                );
              }
              return (
                i.extend(o.__selector.style, {
                  width: "122px",
                  height: "102px",
                  padding: "3px",
                  backgroundColor: "#222",
                  boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
                }),
                i.extend(o.__field_knob.style, {
                  position: "absolute",
                  width: "12px",
                  height: "12px",
                  border:
                    o.__field_knob_border +
                    (o.__color.v < 0.5 ? "#fff" : "#000"),
                  boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                  borderRadius: "12px",
                  zIndex: 1,
                }),
                i.extend(o.__hue_knob.style, {
                  position: "absolute",
                  width: "15px",
                  height: "2px",
                  borderRight: "4px solid #fff",
                  zIndex: 1,
                }),
                i.extend(o.__saturation_field.style, {
                  width: "100px",
                  height: "100px",
                  border: "1px solid #555",
                  marginRight: "3px",
                  display: "inline-block",
                  cursor: "pointer",
                }),
                i.extend(s.style, {
                  width: "100%",
                  height: "100%",
                  background: "none",
                }),
                j(s, "top", "rgba(0,0,0,0)", "#000"),
                i.extend(o.__hue_field.style, {
                  width: "15px",
                  height: "100px",
                  border: "1px solid #555",
                  cursor: "ns-resize",
                  position: "absolute",
                  top: "3px",
                  right: "3px",
                }),
                V(o.__hue_field),
                i.extend(o.__input.style, {
                  outline: "none",
                  textAlign: "center",
                  color: "#fff",
                  border: 0,
                  fontWeight: "bold",
                  textShadow: o.__input_textShadow + "rgba(0,0,0,0.7)",
                }),
                A.bind(o.__saturation_field, "mousedown", a),
                A.bind(o.__saturation_field, "touchstart", a),
                A.bind(o.__field_knob, "mousedown", a),
                A.bind(o.__field_knob, "touchstart", a),
                A.bind(o.__hue_field, "mousedown", d),
                A.bind(o.__hue_field, "touchstart", d),
                o.__saturation_field.appendChild(s),
                o.__selector.appendChild(o.__field_knob),
                o.__selector.appendChild(o.__saturation_field),
                o.__selector.appendChild(o.__hue_field),
                o.__hue_field.appendChild(o.__hue_knob),
                o.domElement.appendChild(o.__input),
                o.domElement.appendChild(o.__selector),
                o.updateDisplay(),
                o
              );
            }
            return (
              f(t, y),
              h(t, [
                {
                  key: "updateDisplay",
                  value: function () {
                    var e = l(this.getValue());
                    if (!1 !== e) {
                      var t = !1;
                      i.each(
                        g.COMPONENTS,
                        function (n) {
                          if (
                            !i.isUndefined(e[n]) &&
                            !i.isUndefined(this.__color.__state[n]) &&
                            e[n] !== this.__color.__state[n]
                          )
                            return (t = !0), {};
                        },
                        this
                      ),
                        t && i.extend(this.__color.__state, e);
                    }
                    i.extend(this.__temp.__state, this.__color.__state),
                      (this.__temp.a = 1);
                    var n =
                      this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
                      o = 255 - n;
                    i.extend(this.__field_knob.style, {
                      marginLeft: 100 * this.__color.s - 7 + "px",
                      marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                      backgroundColor: this.__temp.toHexString(),
                      border:
                        this.__field_knob_border +
                        "rgb(" +
                        n +
                        "," +
                        n +
                        "," +
                        n +
                        ")",
                    }),
                      (this.__hue_knob.style.marginTop =
                        100 * (1 - this.__color.h / 360) + "px"),
                      (this.__temp.s = 1),
                      (this.__temp.v = 1),
                      j(
                        this.__saturation_field,
                        "left",
                        "#fff",
                        this.__temp.toHexString()
                      ),
                      (this.__input.value = this.__color.toString()),
                      i.extend(this.__input.style, {
                        backgroundColor: this.__color.toHexString(),
                        color: "rgb(" + n + "," + n + "," + n + ")",
                        textShadow:
                          this.__input_textShadow +
                          "rgba(" +
                          o +
                          "," +
                          o +
                          "," +
                          o +
                          ",.7)",
                      });
                  },
                },
              ]),
              t
            );
          })(),
          D = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
        function j(e, t, n, o) {
          (e.style.background = ""),
            i.each(D, function (i) {
              e.style.cssText +=
                "background: " +
                i +
                "linear-gradient(" +
                t +
                ", " +
                n +
                " 0%, " +
                o +
                " 100%); ";
            });
        }
        function V(e) {
          (e.style.background = ""),
            (e.style.cssText +=
              "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
            (e.style.cssText +=
              "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (e.style.cssText +=
              "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (e.style.cssText +=
              "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
            (e.style.cssText +=
              "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);");
        }
        var I = {
          load: function (e, t) {
            var n = t || document,
              o = n.createElement("link");
            (o.type = "text/css"),
              (o.rel = "stylesheet"),
              (o.href = e),
              n.getElementsByTagName("head")[0].appendChild(o);
          },
          inject: function (e, t) {
            var n = t || document,
              o = document.createElement("style");
            (o.type = "text/css"), (o.innerHTML = e);
            var i = n.getElementsByTagName("head")[0];
            try {
              i.appendChild(o);
            } catch (r) { }
          },
        },
          z =
            '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>',
          M = function (e, t) {
            var n = e[t];
            return i.isArray(arguments[2]) || i.isObject(arguments[2])
              ? new S(e, t, arguments[2])
              : i.isNumber(n)
                ? i.isNumber(arguments[2]) && i.isNumber(arguments[3])
                  ? i.isNumber(arguments[4])
                    ? new H(e, t, arguments[2], arguments[3], arguments[4])
                    : new H(e, t, arguments[2], arguments[3])
                  : i.isNumber(arguments[4])
                    ? new B(e, t, {
                      min: arguments[2],
                      max: arguments[3],
                      step: arguments[4],
                    })
                    : new B(e, t, { min: arguments[2], max: arguments[3] })
                : i.isString(n)
                  ? new O(e, t)
                  : i.isFunction(n)
                    ? new F(e, t, "")
                    : i.isBoolean(n)
                      ? new k(e, t)
                      : null;
          };
        function G(e) {
          setTimeout(e, 1e3 / 60);
        }
        var U =
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.oRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          G,
          X = (function () {
            function e() {
              _(this, e),
                (this.backgroundElement = document.createElement("div")),
                i.extend(this.backgroundElement.style, {
                  backgroundColor: "rgba(0,0,0,0.8)",
                  top: 0,
                  left: 0,
                  display: "none",
                  zIndex: "1000",
                  opacity: 0,
                  WebkitTransition: "opacity 0.2s linear",
                  transition: "opacity 0.2s linear",
                }),
                A.makeFullscreen(this.backgroundElement),
                (this.backgroundElement.style.position = "fixed"),
                (this.domElement = document.createElement("div")),
                i.extend(this.domElement.style, {
                  position: "fixed",
                  display: "none",
                  zIndex: "1001",
                  opacity: 0,
                  WebkitTransition:
                    "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                  transition: "transform 0.2s ease-out, opacity 0.2s linear",
                }),
                document.body.appendChild(this.backgroundElement),
                document.body.appendChild(this.domElement);
              var t = this;
              A.bind(this.backgroundElement, "click", function () {
                t.hide();
              });
            }
            return (
              h(e, [
                {
                  key: "show",
                  value: function () {
                    var e = this;
                    (this.backgroundElement.style.display = "block"),
                      (this.domElement.style.display = "block"),
                      (this.domElement.style.opacity = 0),
                      (this.domElement.style.webkitTransform = "scale(1.1)"),
                      this.layout(),
                      i.defer(function () {
                        (e.backgroundElement.style.opacity = 1),
                          (e.domElement.style.opacity = 1),
                          (e.domElement.style.webkitTransform = "scale(1)");
                      });
                  },
                },
                {
                  key: "hide",
                  value: function () {
                    var e = this,
                      t = function t() {
                        (e.domElement.style.display = "none"),
                          (e.backgroundElement.style.display = "none"),
                          A.unbind(e.domElement, "webkitTransitionEnd", t),
                          A.unbind(e.domElement, "transitionend", t),
                          A.unbind(e.domElement, "oTransitionEnd", t);
                      };
                    A.bind(this.domElement, "webkitTransitionEnd", t),
                      A.bind(this.domElement, "transitionend", t),
                      A.bind(this.domElement, "oTransitionEnd", t),
                      (this.backgroundElement.style.opacity = 0),
                      (this.domElement.style.opacity = 0),
                      (this.domElement.style.webkitTransform = "scale(1.1)");
                  },
                },
                {
                  key: "layout",
                  value: function () {
                    (this.domElement.style.left =
                      window.innerWidth / 2 -
                      A.getWidth(this.domElement) / 2 +
                      "px"),
                      (this.domElement.style.top =
                        window.innerHeight / 2 -
                        A.getHeight(this.domElement) / 2 +
                        "px");
                  },
                },
              ]),
              e
            );
          })(),
          K = e(
            ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"
          );
        I.inject(K);
        var Y = "dg",
          J = 72,
          W = 20,
          Q = "Default",
          q = (function () {
            try {
              return !!window.localStorage;
            } catch (e) {
              return !1;
            }
          })(),
          Z = void 0,
          $ = !0,
          ee = void 0,
          te = !1,
          ne = [],
          oe = function e(t) {
            var n = this,
              o = t || {};
            (this.domElement = document.createElement("div")),
              (this.__ul = document.createElement("ul")),
              this.domElement.appendChild(this.__ul),
              A.addClass(this.domElement, Y),
              (this.__folders = {}),
              (this.__controllers = []),
              (this.__rememberedObjects = []),
              (this.__rememberedObjectIndecesToControllers = []),
              (this.__listening = []),
              (o = i.defaults(o, {
                closeOnTop: !1,
                autoPlace: !0,
                width: e.DEFAULT_WIDTH,
              })),
              (o = i.defaults(o, {
                resizable: o.autoPlace,
                hideable: o.autoPlace,
              })),
              i.isUndefined(o.load)
                ? (o.load = { preset: Q })
                : o.preset && (o.load.preset = o.preset),
              i.isUndefined(o.parent) && o.hideable && ne.push(this),
              (o.resizable = i.isUndefined(o.parent) && o.resizable),
              o.autoPlace && i.isUndefined(o.scrollable) && (o.scrollable = !0);
            var r,
              s = q && "true" === localStorage.getItem(ce(this, "isLocal")),
              a = void 0,
              l = void 0;
            if (
              (Object.defineProperties(this, {
                parent: {
                  get: function () {
                    return o.parent;
                  },
                },
                scrollable: {
                  get: function () {
                    return o.scrollable;
                  },
                },
                autoPlace: {
                  get: function () {
                    return o.autoPlace;
                  },
                },
                closeOnTop: {
                  get: function () {
                    return o.closeOnTop;
                  },
                },
                preset: {
                  get: function () {
                    return n.parent ? n.getRoot().preset : o.load.preset;
                  },
                  set: function (e) {
                    n.parent ? (n.getRoot().preset = e) : (o.load.preset = e),
                      ge(this),
                      n.revert();
                  },
                },
                width: {
                  get: function () {
                    return o.width;
                  },
                  set: function (e) {
                    (o.width = e), fe(n, e);
                  },
                },
                name: {
                  get: function () {
                    return o.name;
                  },
                  set: function (e) {
                    (o.name = e), l && (l.innerHTML = o.name);
                  },
                },
                closed: {
                  get: function () {
                    return o.closed;
                  },
                  set: function (t) {
                    (o.closed = t),
                      o.closed
                        ? A.addClass(n.__ul, e.CLASS_CLOSED)
                        : A.removeClass(n.__ul, e.CLASS_CLOSED),
                      this.onResize(),
                      n.__closeButton &&
                      (n.__closeButton.innerHTML = t
                        ? e.TEXT_OPEN
                        : e.TEXT_CLOSED);
                  },
                },
                load: {
                  get: function () {
                    return o.load;
                  },
                },
                useLocalStorage: {
                  get: function () {
                    return s;
                  },
                  set: function (e) {
                    q &&
                      ((s = e),
                        e
                          ? A.bind(window, "unload", a)
                          : A.unbind(window, "unload", a),
                        localStorage.setItem(ce(n, "isLocal"), e));
                  },
                },
              }),
                i.isUndefined(o.parent))
            ) {
              if (
                ((this.closed = o.closed || !1),
                  A.addClass(this.domElement, e.CLASS_MAIN),
                  A.makeSelectable(this.domElement, !1),
                  q && s)
              ) {
                n.useLocalStorage = !0;
                var d = localStorage.getItem(ce(this, "gui"));
                d && (o.load = JSON.parse(d));
              }
              (this.__closeButton = document.createElement("div")),
                (this.__closeButton.innerHTML = e.TEXT_CLOSED),
                A.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON),
                o.closeOnTop
                  ? (A.addClass(this.__closeButton, e.CLASS_CLOSE_TOP),
                    this.domElement.insertBefore(
                      this.__closeButton,
                      this.domElement.childNodes[0]
                    ))
                  : (A.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM),
                    this.domElement.appendChild(this.__closeButton)),
                A.bind(this.__closeButton, "click", function () {
                  n.closed = !n.closed;
                });
            } else {
              void 0 === o.closed && (o.closed = !0);
              var c = document.createTextNode(o.name);
              A.addClass(c, "controller-name"), (l = ie(n, c));
              A.addClass(this.__ul, e.CLASS_CLOSED),
                A.addClass(l, "title"),
                A.bind(l, "click", function (e) {
                  return e.preventDefault(), (n.closed = !n.closed), !1;
                }),
                o.closed || (this.closed = !1);
            }
            o.autoPlace &&
              (i.isUndefined(o.parent) &&
                ($ &&
                  ((ee = document.createElement("div")),
                    A.addClass(ee, Y),
                    A.addClass(ee, e.CLASS_AUTO_PLACE_CONTAINER),
                    document.body.appendChild(ee),
                    ($ = !1)),
                  ee.appendChild(this.domElement),
                  A.addClass(this.domElement, e.CLASS_AUTO_PLACE)),
                this.parent || fe(n, o.width)),
              (this.__resizeHandler = function () {
                n.onResizeDebounced();
              }),
              A.bind(window, "resize", this.__resizeHandler),
              A.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
              A.bind(this.__ul, "transitionend", this.__resizeHandler),
              A.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
              this.onResize(),
              o.resizable && pe(this),
              (a = function () {
                q &&
                  "true" === localStorage.getItem(ce(n, "isLocal")) &&
                  localStorage.setItem(
                    ce(n, "gui"),
                    JSON.stringify(n.getSaveObject())
                  );
              }),
              (this.saveToLocalStorageIfPossible = a),
              o.parent ||
              (((r = n.getRoot()).width += 1),
                i.defer(function () {
                  r.width -= 1;
                }));
          };
        function ie(e, t, n) {
          var o = document.createElement("li");
          return (
            t && o.appendChild(t),
            n ? e.__ul.insertBefore(o, n) : e.__ul.appendChild(o),
            e.onResize(),
            o
          );
        }
        function re(e) {
          A.unbind(window, "resize", e.__resizeHandler),
            e.saveToLocalStorageIfPossible &&
            A.unbind(window, "unload", e.saveToLocalStorageIfPossible);
        }
        function se(e, t) {
          var n = e.__preset_select[e.__preset_select.selectedIndex];
          n.innerHTML = t ? n.value + "*" : n.value;
        }
        function ae(e, t, n) {
          if (
            ((n.__li = t),
              (n.__gui = e),
              i.extend(n, {
                options: function (t) {
                  if (arguments.length > 1) {
                    var o = n.__li.nextElementSibling;
                    return (
                      n.remove(),
                      de(e, n.object, n.property, {
                        before: o,
                        factoryArgs: [i.toArray(arguments)],
                      })
                    );
                  }
                  if (i.isArray(t) || i.isObject(t)) {
                    var r = n.__li.nextElementSibling;
                    return (
                      n.remove(),
                      de(e, n.object, n.property, { before: r, factoryArgs: [t] })
                    );
                  }
                },
                name: function (e) {
                  return (
                    (n.__li.firstElementChild.firstElementChild.innerHTML = e), n
                  );
                },
                listen: function () {
                  return n.__gui.listen(n), n;
                },
                remove: function () {
                  return n.__gui.remove(n), n;
                },
              }),
              n instanceof H)
          ) {
            var o = new B(n.object, n.property, {
              min: n.__min,
              max: n.__max,
              step: n.__step,
            });
            i.each(
              [
                "updateDisplay",
                "onChange",
                "onFinishChange",
                "step",
                "min",
                "max",
              ],
              function (e) {
                var t = n[e],
                  i = o[e];
                n[e] = o[e] = function () {
                  var e = Array.prototype.slice.call(arguments);
                  return i.apply(o, e), t.apply(n, e);
                };
              }
            ),
              A.addClass(t, "has-slider"),
              n.domElement.insertBefore(
                o.domElement,
                n.domElement.firstElementChild
              );
          } else if (n instanceof B) {
            var r = function (t) {
              if (i.isNumber(n.__min) && i.isNumber(n.__max)) {
                var o = n.__li.firstElementChild.firstElementChild.innerHTML,
                  r = n.__gui.__listening.indexOf(n) > -1;
                n.remove();
                var s = de(e, n.object, n.property, {
                  before: n.__li.nextElementSibling,
                  factoryArgs: [n.__min, n.__max, n.__step],
                });
                return s.name(o), r && s.listen(), s;
              }
              return t;
            };
            (n.min = i.compose(r, n.min)), (n.max = i.compose(r, n.max));
          } else
            n instanceof k
              ? (A.bind(t, "click", function () {
                A.fakeEvent(n.__checkbox, "click");
              }),
                A.bind(n.__checkbox, "click", function (e) {
                  e.stopPropagation();
                }))
              : n instanceof F
                ? (A.bind(t, "click", function () {
                  A.fakeEvent(n.__button, "click");
                }),
                  A.bind(t, "mouseover", function () {
                    A.addClass(n.__button, "hover");
                  }),
                  A.bind(t, "mouseout", function () {
                    A.removeClass(n.__button, "hover");
                  }))
                : n instanceof P &&
                (A.addClass(t, "color"),
                  (n.updateDisplay = i.compose(function (e) {
                    return (t.style.borderLeftColor = n.__color.toString()), e;
                  }, n.updateDisplay)),
                  n.updateDisplay());
          n.setValue = i.compose(function (t) {
            return (
              e.getRoot().__preset_select &&
              n.isModified() &&
              se(e.getRoot(), !0),
              t
            );
          }, n.setValue);
        }
        function le(e, t) {
          var n = e.getRoot(),
            o = n.__rememberedObjects.indexOf(t.object);
          if (-1 !== o) {
            var i = n.__rememberedObjectIndecesToControllers[o];
            if (
              (void 0 === i &&
                ((i = {}), (n.__rememberedObjectIndecesToControllers[o] = i)),
                (i[t.property] = t),
                n.load && n.load.remembered)
            ) {
              var r = n.load.remembered,
                s = void 0;
              if (r[e.preset]) s = r[e.preset];
              else {
                if (!r[Q]) return;
                s = r[Q];
              }
              if (s[o] && void 0 !== s[o][t.property]) {
                var a = s[o][t.property];
                (t.initialValue = a), t.setValue(a);
              }
            }
          }
        }
        function de(e, t, n, o) {
          if (void 0 === t[n])
            throw new Error('Object "' + t + '" has no property "' + n + '"');
          var i = void 0;
          if (o.color) i = new P(t, n);
          else {
            var r = [t, n].concat(o.factoryArgs);
            i = M.apply(e, r);
          }
          o.before instanceof y && (o.before = o.before.__li),
            le(e, i),
            A.addClass(i.domElement, "c");
          var s = document.createElement("span");
          A.addClass(s, "property-name"), (s.innerHTML = i.property);
          var a = document.createElement("div");
          a.appendChild(s), a.appendChild(i.domElement);
          var l = ie(e, a, o.before);
          return (
            A.addClass(l, oe.CLASS_CONTROLLER_ROW),
            i instanceof P
              ? A.addClass(l, "color")
              : A.addClass(l, u(i.getValue())),
            ae(e, l, i),
            e.__controllers.push(i),
            i
          );
        }
        function ce(e, t) {
          return document.location.href + "." + t;
        }
        function ue(e, t, n) {
          var o = document.createElement("option");
          (o.innerHTML = t),
            (o.value = t),
            e.__preset_select.appendChild(o),
            n &&
            (e.__preset_select.selectedIndex = e.__preset_select.length - 1);
        }
        function _e(e, t) {
          t.style.display = e.useLocalStorage ? "block" : "none";
        }
        function he(e) {
          var t = (e.__save_row = document.createElement("li"));
          A.addClass(e.domElement, "has-save"),
            e.__ul.insertBefore(t, e.__ul.firstChild),
            A.addClass(t, "save-row");
          var n = document.createElement("span");
          (n.innerHTML = "&nbsp;"), A.addClass(n, "button gears");
          var o = document.createElement("span");
          (o.innerHTML = "Save"),
            A.addClass(o, "button"),
            A.addClass(o, "save");
          var r = document.createElement("span");
          (r.innerHTML = "New"),
            A.addClass(r, "button"),
            A.addClass(r, "save-as");
          var s = document.createElement("span");
          (s.innerHTML = "Revert"),
            A.addClass(s, "button"),
            A.addClass(s, "revert");
          var a = (e.__preset_select = document.createElement("select"));
          if (
            (e.load && e.load.remembered
              ? i.each(e.load.remembered, function (t, n) {
                ue(e, n, n === e.preset);
              })
              : ue(e, Q, !1),
              A.bind(a, "change", function () {
                for (var t = 0; t < e.__preset_select.length; t++)
                  e.__preset_select[t].innerHTML = e.__preset_select[t].value;
                e.preset = this.value;
              }),
              t.appendChild(a),
              t.appendChild(n),
              t.appendChild(o),
              t.appendChild(r),
              t.appendChild(s),
              q)
          ) {
            var l = document.getElementById("dg-local-explain"),
              d = document.getElementById("dg-local-storage");
            (document.getElementById("dg-save-locally").style.display =
              "block"),
              "true" === localStorage.getItem(ce(e, "isLocal")) &&
              d.setAttribute("checked", "checked"),
              _e(e, l),
              A.bind(d, "change", function () {
                (e.useLocalStorage = !e.useLocalStorage), _e(e, l);
              });
          }
          var c = document.getElementById("dg-new-constructor");
          A.bind(c, "keydown", function (e) {
            !e.metaKey || (67 !== e.which && 67 !== e.keyCode) || Z.hide();
          }),
            A.bind(n, "click", function () {
              (c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2)),
                Z.show(),
                c.focus(),
                c.select();
            }),
            A.bind(o, "click", function () {
              e.save();
            }),
            A.bind(r, "click", function () {
              var t = prompt("Enter a new preset name.");
              t && e.saveAs(t);
            }),
            A.bind(s, "click", function () {
              e.revert();
            });
        }
        function pe(e) {
          var t = void 0;
          function n(n) {
            return (
              n.preventDefault(),
              (e.width += t - n.clientX),
              e.onResize(),
              (t = n.clientX),
              !1
            );
          }
          function o() {
            A.removeClass(e.__closeButton, oe.CLASS_DRAG),
              A.unbind(window, "mousemove", n),
              A.unbind(window, "mouseup", o);
          }
          function r(i) {
            return (
              i.preventDefault(),
              (t = i.clientX),
              A.addClass(e.__closeButton, oe.CLASS_DRAG),
              A.bind(window, "mousemove", n),
              A.bind(window, "mouseup", o),
              !1
            );
          }
          (e.__resize_handle = document.createElement("div")),
            i.extend(e.__resize_handle.style, {
              width: "6px",
              marginLeft: "-3px",
              height: "200px",
              cursor: "ew-resize",
              position: "absolute",
            }),
            A.bind(e.__resize_handle, "mousedown", r),
            A.bind(e.__closeButton, "mousedown", r),
            e.domElement.insertBefore(
              e.__resize_handle,
              e.domElement.firstElementChild
            );
        }
        function fe(e, t) {
          (e.domElement.style.width = t + "px"),
            e.__save_row &&
            e.autoPlace &&
            (e.__save_row.style.width = t + "px"),
            e.__closeButton && (e.__closeButton.style.width = t + "px");
        }
        function me(e, t) {
          var n = {};
          return (
            i.each(e.__rememberedObjects, function (o, r) {
              var s = {},
                a = e.__rememberedObjectIndecesToControllers[r];
              i.each(a, function (e, n) {
                s[n] = t ? e.initialValue : e.getValue();
              }),
                (n[r] = s);
            }),
            n
          );
        }
        function ge(e) {
          for (var t = 0; t < e.__preset_select.length; t++)
            e.__preset_select[t].value === e.preset &&
              (e.__preset_select.selectedIndex = t);
        }
        function be(e) {
          0 !== e.length &&
            U.call(window, function () {
              be(e);
            }),
            i.each(e, function (e) {
              e.updateDisplay();
            });
        }
        (oe.toggleHide = function () {
          (te = !te),
            i.each(ne, function (e) {
              e.domElement.style.display = te ? "none" : "";
            });
        }),
          (oe.CLASS_AUTO_PLACE = "a"),
          (oe.CLASS_AUTO_PLACE_CONTAINER = "ac"),
          (oe.CLASS_MAIN = "main"),
          (oe.CLASS_CONTROLLER_ROW = "cr"),
          (oe.CLASS_TOO_TALL = "taller-than-window"),
          (oe.CLASS_CLOSED = "closed"),
          (oe.CLASS_CLOSE_BUTTON = "close-button"),
          (oe.CLASS_CLOSE_TOP = "close-top"),
          (oe.CLASS_CLOSE_BOTTOM = "close-bottom"),
          (oe.CLASS_DRAG = "drag"),
          (oe.DEFAULT_WIDTH = 245),
          (oe.TEXT_CLOSED = "Close Controls"),
          (oe.TEXT_OPEN = "Open Controls"),
          (oe._keydownHandler = function (e) {
            "text" === document.activeElement.type ||
              (e.which !== J && e.keyCode !== J) ||
              oe.toggleHide();
          }),
          A.bind(window, "keydown", oe._keydownHandler, !1),
          i.extend(oe.prototype, {
            add: function (e, t) {
              return de(this, e, t, {
                factoryArgs: Array.prototype.slice.call(arguments, 2),
              });
            },
            addColor: function (e, t) {
              return de(this, e, t, { color: !0 });
            },
            remove: function (e) {
              this.__ul.removeChild(e.__li),
                this.__controllers.splice(this.__controllers.indexOf(e), 1);
              var t = this;
              i.defer(function () {
                t.onResize();
              });
            },
            destroy: function () {
              if (this.parent)
                throw new Error(
                  "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."
                );
              this.autoPlace && ee.removeChild(this.domElement);
              var e = this;
              i.each(this.__folders, function (t) {
                e.removeFolder(t);
              }),
                A.unbind(window, "keydown", oe._keydownHandler, !1),
                re(this);
            },
            addFolder: function (e) {
              if (void 0 !== this.__folders[e])
                throw new Error(
                  'You already have a folder in this GUI by the name "' +
                  e +
                  '"'
                );
              var t = { name: e, parent: this };
              (t.autoPlace = this.autoPlace),
                this.load &&
                this.load.folders &&
                this.load.folders[e] &&
                ((t.closed = this.load.folders[e].closed),
                  (t.load = this.load.folders[e]));
              var n = new oe(t);
              this.__folders[e] = n;
              var o = ie(this, n.domElement);
              return A.addClass(o, "folder"), n;
            },
            removeFolder: function (e) {
              this.__ul.removeChild(e.domElement.parentElement),
                delete this.__folders[e.name],
                this.load &&
                this.load.folders &&
                this.load.folders[e.name] &&
                delete this.load.folders[e.name],
                re(e);
              var t = this;
              i.each(e.__folders, function (t) {
                e.removeFolder(t);
              }),
                i.defer(function () {
                  t.onResize();
                });
            },
            open: function () {
              this.closed = !1;
            },
            close: function () {
              this.closed = !0;
            },
            hide: function () {
              this.domElement.style.display = "none";
            },
            show: function () {
              this.domElement.style.display = "";
            },
            onResize: function () {
              var e = this.getRoot();
              if (e.scrollable) {
                var t = A.getOffset(e.__ul).top,
                  n = 0;
                i.each(e.__ul.childNodes, function (t) {
                  (e.autoPlace && t === e.__save_row) || (n += A.getHeight(t));
                }),
                  window.innerHeight - t - W < n
                    ? (A.addClass(e.domElement, oe.CLASS_TOO_TALL),
                      (e.__ul.style.height = window.innerHeight - t - W + "px"))
                    : (A.removeClass(e.domElement, oe.CLASS_TOO_TALL),
                      (e.__ul.style.height = "auto"));
              }
              e.__resize_handle &&
                i.defer(function () {
                  e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
                }),
                e.__closeButton &&
                (e.__closeButton.style.width = e.width + "px");
            },
            onResizeDebounced: i.debounce(function () {
              this.onResize();
            }, 50),
            remember: function () {
              if (
                (i.isUndefined(Z) && ((Z = new X()).domElement.innerHTML = z),
                  this.parent)
              )
                throw new Error(
                  "You can only call remember on a top level GUI."
                );
              var e = this;
              i.each(Array.prototype.slice.call(arguments), function (t) {
                0 === e.__rememberedObjects.length && he(e),
                  -1 === e.__rememberedObjects.indexOf(t) &&
                  e.__rememberedObjects.push(t);
              }),
                this.autoPlace && fe(this, this.width);
            },
            getRoot: function () {
              for (var e = this; e.parent;) e = e.parent;
              return e;
            },
            getSaveObject: function () {
              var e = this.load;
              return (
                (e.closed = this.closed),
                this.__rememberedObjects.length > 0 &&
                ((e.preset = this.preset),
                  e.remembered || (e.remembered = {}),
                  (e.remembered[this.preset] = me(this))),
                (e.folders = {}),
                i.each(this.__folders, function (t, n) {
                  e.folders[n] = t.getSaveObject();
                }),
                e
              );
            },
            save: function () {
              this.load.remembered || (this.load.remembered = {}),
                (this.load.remembered[this.preset] = me(this)),
                se(this, !1),
                this.saveToLocalStorageIfPossible();
            },
            saveAs: function (e) {
              this.load.remembered ||
                ((this.load.remembered = {}),
                  (this.load.remembered[Q] = me(this, !0))),
                (this.load.remembered[e] = me(this)),
                (this.preset = e),
                ue(this, e, !0),
                this.saveToLocalStorageIfPossible();
            },
            revert: function (e) {
              i.each(
                this.__controllers,
                function (t) {
                  this.getRoot().load.remembered
                    ? le(e || this.getRoot(), t)
                    : t.setValue(t.initialValue),
                    t.__onFinishChange &&
                    t.__onFinishChange.call(t, t.getValue());
                },
                this
              ),
                i.each(this.__folders, function (e) {
                  e.revert(e);
                }),
                e || se(this.getRoot(), !1);
            },
            listen: function (e) {
              var t = 0 === this.__listening.length;
              this.__listening.push(e), t && be(this.__listening);
            },
            updateDisplay: function () {
              i.each(this.__controllers, function (e) {
                e.updateDisplay();
              }),
                i.each(this.__folders, function (e) {
                  e.updateDisplay();
                });
            },
          });
        var ve = { Color: g, math: c, interpret: l };
        exports.color = ve;
        var ye = {
          Controller: y,
          BooleanController: k,
          OptionController: S,
          StringController: O,
          NumberController: L,
          NumberControllerBox: B,
          NumberControllerSlider: H,
          FunctionController: F,
          ColorController: P,
        };
        exports.controllers = ye;
        var we = { dom: A };
        exports.dom = we;
        var xe = { GUI: oe };
        exports.gui = xe;
        var Ee = oe;
        exports.GUI = Ee;
        var Ce = { color: ve, controllers: ye, dom: we, gui: xe, GUI: Ee },
          Ae = Ce;
        exports.default = Ae;
      },
      {},
    ],
    Xcza: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.environments = void 0);
        var e = [
          { id: "", name: "None", path: null, format: ".hdr" },
          {
            id: "venice-sunset",
            name: "Venice Sunset",
            path: "assets/environment/venice_sunset_1k.hdr",
            format: ".hdr",
          },
          {
            id: "footprint-court",
            name: "Footprint Court (HDR Labs)",
            path: "assets/environment/footprint_court_2k.hdr",
            format: ".hdr",
          },
        ];
        exports.environments = e;
      },
      {},
    ],
    LQgb: [
      function (require, module, exports) {
        module.exports =
          "#define GLSLIFY 1\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec2 vUv;\nvoid main() {\n  gl_Position = vec4(position, 1.0);\n  vUv = vec2(position.x, position.y) * 0.5 + 0.5;\n}\n";
      },
      {},
    ],
    Tyuz: [
      function (require, module, exports) {
        module.exports =
          'precision mediump float;\n#define GLSLIFY 1\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1(vec4 x)\n{\n  return mod289_1(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289_1(Pi0);\n  Pi1 = mod289_1(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1(permute_1(ix) + iy);\n  vec4 ixy0 = permute_1(ixy + iz0);\n  vec4 ixy1 = permute_1(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_0(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_0(vec4 x) {\n     return mod289_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_0(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_0(i);\n  vec4 p = permute_0( permute_0( permute_0(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat grain(vec2 texCoord, vec2 resolution, float frame, float multiplier) {\n    vec2 mult = texCoord * resolution;\n    float offset = snoise(vec3(mult / multiplier, frame));\n    float n1 = pnoise(vec3(mult, offset), vec3(1.0/texCoord * resolution, 1.0));\n    return n1 / 2.0 + 0.5;\n}\n\nfloat grain(vec2 texCoord, vec2 resolution, float frame) {\n    return grain(texCoord, resolution, frame, 2.5);\n}\n\nfloat grain(vec2 texCoord, vec2 resolution) {\n    return grain(texCoord, resolution, 0.0);\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    return mix(\n        sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend), \n        2.0 * base * blend + base * base * (1.0 - 2.0 * blend), \n        step(base, vec3(0.5))\n    );\n}\n\n// Using conditionals\n// vec3 blendSoftLight(vec3 base, vec3 blend) {\n//     return vec3(\n//         ((blend.r < 0.5) ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r)) : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r))),\n//         ((blend.g < 0.5) ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g)) : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g))),\n//         ((blend.b < 0.5) ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b)) : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b)))\n//     );\n// }\n\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float aspect;\nuniform vec2 offset;\nuniform vec2 scale;\nuniform float noiseAlpha;\nuniform bool aspectCorrection;\nuniform float grainScale;\nuniform float grainTime;\nuniform vec2 smooth;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 q = vec2(vUv - 0.5);\n  if (aspectCorrection) {\n    q.x *= aspect;\n  }\n  q /= scale;\n  q -= offset;\n  float dst = length(q);\n  dst = smoothstep(smooth.x, smooth.y, dst);\n  vec3 color = mix(color1, color2, dst);\n\n  if (noiseAlpha > 0.0 && grainScale > 0.0) {\n    float gSize = 1.0 / grainScale;\n    float g = grain(vUv, vec2(gSize * aspect, gSize), grainTime);\n    vec3 noiseColor = blendSoftLight(color, vec3(g));\n    gl_FragColor.rgb = mix(color, noiseColor, noiseAlpha);\n  } else {\n    gl_FragColor.rgb = color;\n  }\n  gl_FragColor.a = 1.0;\n}\n';
      },
      {},
    ],
    aQrt: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.createBackground = a);
        var e = require("three"),
          r = t(require("./three-vignette.vert")),
          o = t(require("./three-vignette.frag"));
        function t(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function a(t) {
          var a = (t = t || {}).geometry || new e.PlaneGeometry(2, 2, 1),
            n = new e.RawShaderMaterial({
              vertexShader: r.default,
              fragmentShader: o.default,
              side: e.DoubleSide,
              uniforms: {
                aspectCorrection: { type: "i", value: !1 },
                aspect: { type: "f", value: 1 },
                grainScale: { type: "f", value: 0.005 },
                grainTime: { type: "f", value: 0 },
                noiseAlpha: { type: "f", value: 0.25 },
                offset: { type: "v2", value: new e.Vector2(0, 0) },
                scale: { type: "v2", value: new e.Vector2(1, 1) },
                smooth: { type: "v2", value: new e.Vector2(0, 1) },
                color1: { type: "c", value: new e.Color("#fff") },
                color2: { type: "c", value: new e.Color("#283844") },
              },
              depthTest: !1,
            }),
            u = new e.Mesh(a, n);
          return (
            (u.frustumCulled = !1),
            (u.style = function (r) {
              if (((r = r || {}), Array.isArray(r.colors))) {
                var o = r.colors.map(function (r) {
                  return "string" == typeof r || "number" == typeof r
                    ? new e.Color(r)
                    : r;
                });
                n.uniforms.color1.value.copy(o[0]),
                  n.uniforms.color2.value.copy(o[1]);
              }
              "number" == typeof r.aspect &&
                (n.uniforms.aspect.value = r.aspect);
              "number" == typeof r.grainScale &&
                (n.uniforms.grainScale.value = r.grainScale);
              "number" == typeof r.grainTime &&
                (n.uniforms.grainTime.value = r.grainTime);
              if (r.smooth) {
                var t = i(r.smooth, e.Vector2);
                n.uniforms.smooth.value.copy(t);
              }
              if (r.offset) {
                var a = i(r.offset, e.Vector2);
                n.uniforms.offset.value.copy(a);
              }
              "number" == typeof r.noiseAlpha &&
                (n.uniforms.noiseAlpha.value = r.noiseAlpha);
              if (void 0 !== r.scale) {
                var u = r.scale;
                "number" == typeof u && (u = [u, u]),
                  (u = i(u, e.Vector2)),
                  n.uniforms.scale.value.copy(u);
              }
              void 0 !== r.aspectCorrection &&
                (n.uniforms.aspectCorrection.value = Boolean(
                  r.aspectCorrection
                ));
            }),
            t && u.style(t),
            u
          );
          function i(e, r) {
            return Array.isArray(e) ? new r().fromArray(e) : e;
          }
        }
      },
      {
        three: "gBK8",
        "./three-vignette.vert": "LQgb",
        "./three-vignette.frag": "Tyuz",
      },
    ],
    mm7A: [
      function (require, module, exports) {
        "use strict";
        function t(t, n) {
          var r =
            ("undefined" != typeof Symbol && t[Symbol.iterator]) ||
            t["@@iterator"];
          if (!r) {
            if (
              Array.isArray(t) ||
              (r = e(t)) ||
              (n && t && "number" == typeof t.length)
            ) {
              r && (t = r);
              var i = 0,
                o = function () { };
              return {
                s: o,
                n: function () {
                  return i >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[i++] };
                },
                e: function (t) {
                  throw t;
                },
                f: o,
              };
            }
            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }
          var a,
            d = !0,
            u = !1;
          return {
            s: function () {
              r = r.call(t);
            },
            n: function () {
              var t = r.next();
              return (d = t.done), t;
            },
            e: function (t) {
              (u = !0), (a = t);
            },
            f: function () {
              try {
                d || null == r.return || r.return();
              } finally {
                if (u) throw a;
              }
            },
          };
        }
        function e(t, e) {
          if (t) {
            if ("string" == typeof t) return n(t, e);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            return (
              "Object" === r && t.constructor && (r = t.constructor.name),
              "Map" === r || "Set" === r
                ? Array.from(t)
                : "Arguments" === r ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                  ? n(t, e)
                  : void 0
            );
          }
        }
        function n(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
          return r;
        }
        function r(t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        }
        function i(t, e) {
          for (var n = 0; n < e.length; n++) {
            var r = e[n];
            (r.enumerable = r.enumerable || !1),
              (r.configurable = !0),
              "value" in r && (r.writable = !0),
              Object.defineProperty(t, r.key, r);
          }
        }
        function o(t, e, n) {
          return (
            e && i(t.prototype, e),
            n && i(t, n),
            Object.defineProperty(t, "prototype", { writable: !1 }),
            t
          );
        }
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.ModelItem = void 0);
        var a = (function () {
          function e(t, n) {
            r(this, e),
              (this._modelTree = t),
              (this._db = t.data.db),
              (this._dbId = n),
              (this._children = void 0);
          }
          return (
            o(e, [
              {
                key: "children",
                get: function () {
                  if (void 0 === this._children) {
                    var e = this._db.childrenIds[this._dbId];
                    if (e) {
                      var n,
                        r = [],
                        i = t(e);
                      try {
                        for (i.s(); !(n = i.n()).done;) {
                          var o = n.value;
                          r.push(this._modelTree.findItemByDbId(o));
                        }
                      } catch (a) {
                        i.e(a);
                      } finally {
                        i.f();
                      }
                      this._children = r;
                    } else this._children = null;
                  }
                  return this._children;
                },
              },
              {
                key: "id",
                get: function () {
                  return this._dbId;
                },
              },
              {
                key: "name",
                get: function () {
                  return this._db.names[this._dbId];
                },
              },
              {
                key: "parent",
                get: function () {
                  return this._modelTree.findItemByDbId(this.parentId);
                },
              },
              {
                key: "parentId",
                get: function () {
                  return this._db.parentIds[this._dbId];
                },
              },
              {
                key: "externalId",
                get: function () {
                  return this._db.externalIds[this._dbId];
                },
              },
              {
                key: "category",
                get: function () {
                  return this._db.categories[this._dbId];
                },
              },
              {
                key: "type",
                get: function () {
                  return this._db.types[this._dbId];
                },
              },
            ]),
            e
          );
        })();
        exports.ModelItem = a;
      },
      {},
    ],
    ilS1: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.ModelTreeBase = void 0);
        var t = require("./ModelItem.js");
        function e(t, e) {
          var n =
            ("undefined" != typeof Symbol && t[Symbol.iterator]) ||
            t["@@iterator"];
          if (!n) {
            if (
              Array.isArray(t) ||
              (n = r(t)) ||
              (e && t && "number" == typeof t.length)
            ) {
              n && (t = n);
              var a = 0,
                o = function () { };
              return {
                s: o,
                n: function () {
                  return a >= t.length
                    ? { done: !0 }
                    : { done: !1, value: t[a++] };
                },
                e: function (t) {
                  throw t;
                },
                f: o,
              };
            }
            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }
          var i,
            u = !0,
            l = !1;
          return {
            s: function () {
              n = n.call(t);
            },
            n: function () {
              var t = n.next();
              return (u = t.done), t;
            },
            e: function (t) {
              (l = !0), (i = t);
            },
            f: function () {
              try {
                u || null == n.return || n.return();
              } finally {
                if (l) throw i;
              }
            },
          };
        }
        function r(t, e) {
          if (t) {
            if ("string" == typeof t) return n(t, e);
            var r = Object.prototype.toString.call(t).slice(8, -1);
            return (
              "Object" === r && t.constructor && (r = t.constructor.name),
              "Map" === r || "Set" === r
                ? Array.from(t)
                : "Arguments" === r ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                  ? n(t, e)
                  : void 0
            );
          }
        }
        function n(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = new Array(e); r < e; r++) n[r] = t[r];
          return n;
        }
        function a(t, e) {
          if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function");
        }
        function o(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(t, n.key, n);
          }
        }
        function i(t, e, r) {
          return (
            e && o(t.prototype, e),
            r && o(t, r),
            Object.defineProperty(t, "prototype", { writable: !1 }),
            t
          );
        }
        var u = (function () {
          function r() {
            a(this, r);
          }
          return (
            i(r, [
              {
                key: "init",
                value: function (e) {
                  var r = e.db;
                  return (
                    (this._data = e),
                    (this._root = new t.ModelItem(this, r.rootDbId)),
                    (this._items = []),
                    (this._maxDbId = r.parentIds.length - 1),
                    (this._partEnabled = null != e.partFileNames),
                    (this._partCount = this._partEnabled
                      ? e.partFileNames.length
                      : 1),
                    (r.childrenIds = this._prepareDataForChildrenIds()),
                    (r.exIdToDbId = null),
                    (this._isReady = !0),
                    this
                  );
                },
              },
              {
                key: "_prepareDataForChildrenIds",
                value: function () {
                  for (
                    var t = this._data.db.parentIds,
                    e = [],
                    r = t.length,
                    n = 0;
                    n < r;
                    n++
                  ) {
                    var a = t[n];
                    a < 0 || (void 0 === e[a] ? (e[a] = [n]) : e[a].push(n));
                  }
                  return e;
                },
              },
              {
                key: "_prepareDataForExIdToDbId",
                value: function () {
                  for (
                    var t = this._data.db.externalIds,
                    e = {},
                    r = t.length,
                    n = 0;
                    n < r;
                    n++
                  ) {
                    var a = t[n];
                    a || (e[a] = n);
                  }
                  return e;
                },
              },
              {
                key: "isReady",
                get: function () {
                  return this._isReady;
                },
              },
              {
                key: "data",
                get: function () {
                  return this._data;
                },
              },
              {
                key: "root",
                get: function () {
                  return this._root;
                },
              },
              {
                key: "rootId",
                get: function () {
                  return this._data.db.rootDbId;
                },
              },
              {
                key: "maxDbId",
                get: function () {
                  return this._maxDbId;
                },
              },
              {
                key: "partEnabled",
                get: function () {
                  return this._partEnabled;
                },
              },
              {
                key: "partCount",
                get: function () {
                  return this._partCount;
                },
              },
              {
                key: "collectDbIds",
                value: function (t) {
                  if (null == t) return null;
                  t = t instanceof Array ? t : [t];
                  var r,
                    n = [],
                    a = e(t);
                  try {
                    for (a.s(); !(r = a.n()).done;) {
                      var o = r.value;
                      n.push(o);
                      var i = this._data.db.childrenIds[o];
                      if (i && i.length > 0) {
                        var u = this.collectDbIds(i);
                        u &&
                          u.length > 0 &&
                          u.forEach(function (t) {
                            return n.push(t);
                          });
                      }
                    }
                  } catch (l) {
                    a.e(l);
                  } finally {
                    a.f();
                  }
                  return n;
                },
              },
              {
                key: "findItemByDbId",
                value: function (e) {
                  if (e < 0 || e > this._maxDbId) return null;
                  var r = this._items[e];
                  return (
                    void 0 === r &&
                    (this._items[e] = r = new t.ModelItem(this, e)),
                    r
                  );
                },
              },
              {
                key: "findItemByExId",
                value: function (e) {
                  if (null == e) return null;
                  var r = this._data.db;
                  null == r.exIdToDbId &&
                    (r.exIdToDbId = this._prepareDataForExIdToDbId());
                  var n = r.exIdToDbId[e];
                  if ("number" != typeof n) return null;
                  var a = this._items[n];
                  return (
                    void 0 === a &&
                    (this._items[n] = a = new t.ModelItem(this, n)),
                    a
                  );
                },
              },
            ]),
            r
          );
        })();
        exports.ModelTreeBase = u;
      },
      { "./ModelItem.js": "mm7A" },
    ],
    kXkO: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.ModelTree = void 0);
        var e = require("../ModelTreeBase.js");
        function t(e) {
          return (t =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                return typeof e;
              }
              : function (e) {
                return e &&
                  "function" == typeof Symbol &&
                  e.constructor === Symbol &&
                  e !== Symbol.prototype
                  ? "symbol"
                  : typeof e;
              })(e);
        }
        function r(e, t) {
          var r =
            ("undefined" != typeof Symbol && e[Symbol.iterator]) ||
            e["@@iterator"];
          if (!r) {
            if (
              Array.isArray(e) ||
              (r = n(e)) ||
              (t && e && "number" == typeof e.length)
            ) {
              r && (e = r);
              var i = 0,
                o = function () { };
              return {
                s: o,
                n: function () {
                  return i >= e.length
                    ? { done: !0 }
                    : { done: !1, value: e[i++] };
                },
                e: function (e) {
                  throw e;
                },
                f: o,
              };
            }
            throw new TypeError(
              "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          }
          var l,
            a = !0,
            s = !1;
          return {
            s: function () {
              r = r.call(e);
            },
            n: function () {
              var e = r.next();
              return (a = e.done), e;
            },
            e: function (e) {
              (s = !0), (l = e);
            },
            f: function () {
              try {
                a || null == r.return || r.return();
              } finally {
                if (s) throw l;
              }
            },
          };
        }
        function n(e, t) {
          if (e) {
            if ("string" == typeof e) return i(e, t);
            var r = Object.prototype.toString.call(e).slice(8, -1);
            return (
              "Object" === r && e.constructor && (r = e.constructor.name),
              "Map" === r || "Set" === r
                ? Array.from(e)
                : "Arguments" === r ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
                  ? i(e, t)
                  : void 0
            );
          }
        }
        function i(e, t) {
          (null == t || t > e.length) && (t = e.length);
          for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
          return n;
        }
        function o(e, t) {
          if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function");
        }
        function l(e, t) {
          for (var r = 0; r < t.length; r++) {
            var n = t[r];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(e, n.key, n);
          }
        }
        function a(e, t, r) {
          return (
            t && l(e.prototype, t),
            r && l(e, r),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            e
          );
        }
        function s() {
          return (s =
            "undefined" != typeof Reflect && Reflect.get
              ? Reflect.get
              : function (e, t, r) {
                var n = c(e, t);
                if (n) {
                  var i = Object.getOwnPropertyDescriptor(n, t);
                  return i.get
                    ? i.get.call(arguments.length < 3 ? e : r)
                    : i.value;
                }
              }).apply(this, arguments);
        }
        function c(e, t) {
          for (
            ;
            !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = p(e));

          );
          return e;
        }
        function u(e, t) {
          if ("function" != typeof t && null !== t)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          (e.prototype = Object.create(t && t.prototype, {
            constructor: { value: e, writable: !0, configurable: !0 },
          })),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            t && f(e, t);
        }
        function f(e, t) {
          return (f =
            Object.setPrototypeOf ||
            function (e, t) {
              return (e.__proto__ = t), e;
            })(e, t);
        }
        function h(e) {
          var t = v();
          return function () {
            var r,
              n = p(e);
            if (t) {
              var i = p(this).constructor;
              r = Reflect.construct(n, arguments, i);
            } else r = n.apply(this, arguments);
            return d(this, r);
          };
        }
        function d(e, r) {
          if (r && ("object" === t(r) || "function" == typeof r)) return r;
          if (void 0 !== r)
            throw new TypeError(
              "Derived constructors may only return object or undefined"
            );
          return y(e);
        }
        function y(e) {
          if (void 0 === e)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            );
          return e;
        }
        function v() {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return (
              Boolean.prototype.valueOf.call(
                Reflect.construct(Boolean, [], function () { })
              ),
              !0
            );
          } catch (e) {
            return !1;
          }
        }
        function p(e) {
          return (p = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function (e) {
              return e.__proto__ || Object.getPrototypeOf(e);
            })(e);
        }
        var g = { Original: 0, Selected: 1, Highlighted: 2 },
          b = (function (t) {
            u(i, e.ModelTreeBase);
            var n = h(i);
            function i() {
              var e;
              return (
                o(this, i),
                ((e = n.call(this))._gltfScenes = []),
                (e._gltfNodes = []),
                (e._isReady = !1),
                e
              );
            }
            return (
              a(
                i,
                [
                  {
                    key: "init",
                    value: function (e) {
                      s(p(i.prototype), "init", this).call(this, e);
                      var t = s(p(i.prototype), "data", this).db;
                      return (
                        (t.visible = []),
                        (t.selected = []),
                        (this._selectedIds = new Map()),
                        (this._highlightIds = new Map()),
                        (this._materials = new Map()),
                        this
                      );
                    },
                  },
                  {
                    key: "printTree",
                    value: function (e) {
                      if (this.isReady) {
                        void 0 === e && (e = !0);
                        var t = this;
                        !(function n(i, o) {
                          console.log(o + i.name + " - {" + i.id + "}");
                          var l = i.children;
                          if (null != l && l.length > 0) {
                            o += "  ";
                            var a,
                              s = r(l);
                            try {
                              for (s.s(); !(a = s.n()).done;) {
                                var c = a.value;
                                (!1 === e || t.hasGeometry(c.id, !0)) &&
                                  n(c, o);
                              }
                            } catch (u) {
                              s.e(u);
                            } finally {
                              s.f();
                            }
                          }
                        })(this.root, "");
                      }
                    },
                  },
                  {
                    key: "isReady",
                    get: function () {
                      return (
                        s(p(i.prototype), "isReady", this) &&
                        this._gltfScenes.length >=
                        s(p(i.prototype), "partCount", this)
                      );
                    },
                  },
                  {
                    key: "bindGltfScene",
                    value: function (e, t) {
                      function n(e, t) {
                        if (
                          (e.material && t.push(e),
                            e.children && e.children.length > 0)
                        )
                          for (var r in e.children) n(e.children[r], t);
                      }
                      if (
                        ((void 0 === t || t < 0) && (t = 0),
                          (this._gltfScenes[t] = e),
                          e.userData && e.userData.InfoFileName)
                      ) {
                        var i,
                          o = this._gltfNodes,
                          l = r(
                            1 == e.children.length &&
                              "_Root" == e.children[0].name
                              ? e.children[0].children
                              : e.children
                          );
                        try {
                          for (l.s(); !(i = l.n()).done;) {
                            var a,
                              s = i.value,
                              c =
                                null === (a = s.userData) || void 0 === a
                                  ? void 0
                                  : a.DbId;
                            if (null != c) {
                              var u = [];
                              if ((n(s, u), u.length))
                                if (void 0 === o[c]) o[c] = u;
                                else for (var f in u) o[c].push(f);
                            }
                          }
                        } catch (h) {
                          l.e(h);
                        } finally {
                          l.f();
                        }
                      }
                    },
                  },
                  {
                    key: "processGltfNodes",
                    value: function (e, t) {
                      if (null == e || "function" != typeof t) return !1;
                      if (e instanceof Array) {
                        if (0 === e.length) return !1;
                      } else e = [e];
                      var n,
                        i = this._gltfNodes,
                        o = r(e);
                      try {
                        for (o.s(); !(n = o.n()).done;) {
                          var l = n.value,
                            a = i[l];
                          if (null != a) {
                            var s,
                              c = r(a);
                            try {
                              for (c.s(); !(s = c.n()).done;) {
                                if (t(s.value, l)) return !0;
                              }
                            } catch (u) {
                              c.e(u);
                            } finally {
                              c.f();
                            }
                          }
                        }
                      } catch (u) {
                        o.e(u);
                      } finally {
                        o.f();
                      }
                      return !1;
                    },
                  },
                  {
                    key: "hasGeometry",
                    value: function (e, t) {
                      var r = this,
                        n = this._gltfNodes[e];
                      if (n && n.length > 0) return !0;
                      if (t) {
                        var i = this._data.db.childrenIds[e];
                        return (
                          null != i &&
                          0 !== i.length &&
                          i.some(function (e) {
                            return r.hasGeometry(e, !0);
                          })
                        );
                      }
                      return !1;
                    },
                  },
                  {
                    key: "isVisible",
                    value: function (e) {
                      return (
                        void 0 === this.db.visible[e] || this.db.visible[e]
                      );
                    },
                  },
                  {
                    key: "isolate",
                    value: function (e) {
                      if (null == e) return null;
                      this.hide(this.rootId), this.show(e);
                    },
                  },
                  {
                    key: "show",
                    value: function (e) {
                      if (null == e) return null;
                      if ((e = this.collectDbIds(e)).length > 0) {
                        var t = this._data.db;
                        e.forEach(function (e) {
                          return (t.visible[e] = !0);
                        }),
                          this.processGltfNodes(e, function (e) {
                            e.visible = !0;
                          });
                      }
                    },
                  },
                  {
                    key: "hide",
                    value: function (e) {
                      if (null == e) return null;
                      if ((e = this.collectDbIds(e)).length > 0) {
                        var t = this._data.db;
                        e.forEach(function (e) {
                          return (t.visible[e] = !1);
                        }),
                          this.processGltfNodes(e, function (e) {
                            e.visible = !1;
                          });
                      }
                    },
                  },
                  {
                    key: "getSelection",
                    value: function () {
                      var e,
                        t = [],
                        n = r(this._selectedIds);
                      try {
                        for (n.s(); !(e = n.n()).done;) {
                          var i = e.value;
                          t.push(i[0]);
                        }
                      } catch (o) {
                        n.e(o);
                      } finally {
                        n.f();
                      }
                      return t;
                    },
                  },
                  {
                    key: "select",
                    value: function (e) {
                      var t = this;
                      e = null == e ? [] : e instanceof Array ? e : [e];
                      var n,
                        i = new Map(),
                        o = r(e);
                      try {
                        for (o.s(); !(n = o.n()).done;) {
                          var l = n.value;
                          i.set(l, 0);
                        }
                      } catch (m) {
                        o.e(m);
                      } finally {
                        o.f();
                      }
                      var a,
                        s = [],
                        c = [],
                        u = r(i);
                      try {
                        for (u.s(); !(a = u.n()).done;) {
                          var f = a.value;
                          !1 === this._selectedIds.has(f[0]) && s.push(f[0]);
                        }
                      } catch (m) {
                        u.e(m);
                      } finally {
                        u.f();
                      }
                      var h,
                        d = r(this._selectedIds);
                      try {
                        for (d.s(); !(h = d.n()).done;) {
                          var y = h.value;
                          !1 === i.has(y[0]) && c.push(y[0]);
                        }
                      } catch (m) {
                        d.e(m);
                      } finally {
                        d.f();
                      }
                      this._selectedIds = i;
                      var v = this;
                      if (s.length > 0) {
                        var p = this.collectDbIds(s);
                        p.forEach(function (e) {
                          return (t._data.db.selected[e] = !0);
                        }),
                          this.processGltfNodes(p, function (e) {
                            e.material = v._getMaterial(e.material, g.Selected);
                          });
                      }
                      if (c.length > 0) {
                        var b = this.collectDbIds(c);
                        c.forEach(function (e) {
                          return (t._data.db.selected[e] = !1);
                        }),
                          this.processGltfNodes(b, function (e, t) {
                            v._highlightIds.has(t)
                              ? (e.material = v._getMaterial(
                                e.material,
                                g.Highlighted
                              ))
                              : (e.material = v._getMaterial(
                                e.material,
                                g.Original
                              ));
                          });
                      }
                    },
                  },
                  {
                    key: "highlight",
                    value: function (e) {
                      e = null == e ? [] : e instanceof Array ? e : [e];
                      var t,
                        n = new Map(),
                        i = r(e);
                      try {
                        for (i.s(); !(t = i.n()).done;) {
                          var o = t.value;
                          n.set(o, 0);
                        }
                      } catch (b) {
                        i.e(b);
                      } finally {
                        i.f();
                      }
                      var l,
                        a = [],
                        s = [],
                        c = r(n);
                      try {
                        for (c.s(); !(l = c.n()).done;) {
                          var u = l.value;
                          !1 === this._highlightIds.has(u[0]) && a.push(u[0]);
                        }
                      } catch (b) {
                        c.e(b);
                      } finally {
                        c.f();
                      }
                      var f,
                        h = r(this._highlightIds);
                      try {
                        for (h.s(); !(f = h.n()).done;) {
                          var d = f.value;
                          !1 === n.has(d[0]) && s.push(d[0]);
                        }
                      } catch (b) {
                        h.e(b);
                      } finally {
                        h.f();
                      }
                      this._highlightIds = n;
                      var y = this;
                      if (a.length > 0) {
                        var v = this.collectDbIds(a);
                        this.processGltfNodes(v, function (e) {
                          e.material = y._getMaterial(
                            e.material,
                            g.Highlighted
                          );
                        });
                      }
                      if (s.length > 0) {
                        var p = this.collectDbIds(s);
                        this.processGltfNodes(p, function (e, t) {
                          y._selectedIds.has(t)
                            ? (e.material = y._getMaterial(
                              e.material,
                              g.Selected
                            ))
                            : (e.material = y._getMaterial(
                              e.material,
                              g.Original
                            ));
                        });
                      }
                    },
                  },
                  {
                    key: "_getMaterial",
                    value: function (e, t) {
                      var r = e.uuid,
                        n = this._materials.get(r);
                      null == n &&
                        (((n = [])[g.Original] = e), this._materials.set(r, n));
                      var i = n[t];
                      if (null == i)
                        switch ((((i = e.clone()).uuid = r), (n[t] = i), t)) {
                          case g.Selected:
                            i.color.set("#00FF00");
                            break;
                          case g.Highlighted:
                            i.color.set("#FFFF00");
                        }
                      return i;
                    },
                  },
                ],
                [
                  {
                    key: "loadFrom",
                    value: function (e) {
                      return fetch(e)
                        .then(function (e) {
                          return e.json();
                        })
                        .then(function (e) {
                          return new i().init(e);
                        });
                    },
                  },
                ]
              ),
              i
            );
          })();
        exports.ModelTree = b;
      },
      { "../ModelTreeBase.js": "ilS1" },
    ],
    ET0b: [
      function (require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: !0 }),
          (exports.Viewer = void 0);
        var e = f(require("three")),
          t = m(require("three/examples/jsm/libs/stats.module.js")),
          i = require("three/examples/jsm/loaders/GLTFLoader.js"),
          n = require("three/examples/jsm/loaders/KTX2Loader.js"),
          a = require("three/examples/jsm/loaders/DRACOLoader.js"),
          r = require("three/examples/jsm/libs/meshopt_decoder.module.js"),
          s = require("three/examples/jsm/controls/OrbitControls.js"),
          o = require("three/examples/jsm/loaders/RGBELoader.js"),
          l = m(require("query-string")),
          h = require("dat.gui"),
          d = require("../assets/environment/index.js"),
          c = require("../lib/three-vignette.js"),
          u = require("./BimAngle/Gltf/ThreeJS/ModelTree.js");
        function m(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function p(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            i = new WeakMap();
          return (p = function (e) {
            return e ? i : t;
          })(e);
        }
        function f(e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var i = p(t);
          if (i && i.has(e)) return i.get(e);
          var n = {},
            a = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var r in e)
            if ("default" !== r && Object.prototype.hasOwnProperty.call(e, r)) {
              var s = a ? Object.getOwnPropertyDescriptor(e, r) : null;
              s && (s.get || s.set)
                ? Object.defineProperty(n, r, s)
                : (n[r] = e[r]);
            }
          return (n.default = e), i && i.set(e, n), n;
        }
        function g(e, t) {
          if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function");
        }
        function v(e, t) {
          for (var i = 0; i < t.length; i++) {
            var n = t[i];
            (n.enumerable = n.enumerable || !1),
              (n.configurable = !0),
              "value" in n && (n.writable = !0),
              Object.defineProperty(e, n.key, n);
          }
        }
        function C(e, t, i) {
          return (
            t && v(e.prototype, t),
            i && v(e, i),
            Object.defineProperty(e, "prototype", { writable: !1 }),
            e
          );
        }
        var y = "[default]",
          x = L(),
          w = new e.LoadingManager(),
          E = new a.DRACOLoader(w).setDecoderPath(x + "assets/draco/"),
          b = new n.KTX2Loader(w).setTranscoderPath(x + "assets/basis/"),
          k = P(),
          M = [
            "map",
            "aoMap",
            "emissiveMap",
            "glossinessMap",
            "metalnessMap",
            "normalMap",
            "roughnessMap",
            "specularMap",
          ],
          S = { ASSET_GENERATOR: "assetgenerator" };
        function D() {
          var e,
            t = window.document,
            i = +new Date(),
            n = -1 === ("" + t.querySelector).indexOf("[native code]");
          if (t.currentScript) return t.currentScript.src;
          try {
            ({}.b());
          } catch (l) {
            e = l.fileName || l.sourceURL || l.stack || l.stacktrace;
          }
          if (e) {
            var a = /((?:http|https|file):\/\/.*?\/[^:]+)(?::\d+)?:\d+/.exec(
              e
            )[1];
            if (a) return a;
          }
          for (var r, s = t.scripts, o = s.length - 1; (r = s[o--]);)
            if (r.className !== i && "interactive" === r.readyState)
              return (r.className = i), n ? r.getAttribute("src", 4) : r.src;
        }
        function L() {
          var e = D();
          return e.substring(0, e.lastIndexOf("/") + 1);
        }
        e.Cache.enabled = !0;
        var R = (function () {
          function n(i, a, r) {
            g(this, n),
              (this.el = i),
              (this.options = a = a || {}),
              (this.enableElementData = r),
              (this.lights = []),
              (this.content = null),
              (this.mixer = null),
              (this.clips = []),
              (this.gui = null),
              (this.state = {
                environment:
                  a.preset === S.ASSET_GENERATOR
                    ? d.environments.find(function (e) {
                      return "footprint-court" === e.id;
                    }).name
                    : d.environments[0].name,
                background: !1,
                playbackSpeed: 1,
                actionStates: {},
                camera: y,
                wireframe: !1,
                skeleton: !1,
                grid: !1,
                addLights: !0,
                exposure: 1,
                textureEncoding: "sRGB",
                ambientIntensity: 0.3,
                ambientColor: 16777215,
                directIntensity: 0.8 * Math.PI,
                directColor: 16777215,
                bgColor1: "#ffffff",
                bgColor2: "#353535",
              }),
              (this.prevTime = 0),
              (this.stats = new t.default()),
              (this.stats.dom.height = "48px"),
              [].forEach.call(this.stats.dom.children, function (e) {
                return (e.style.display = "");
              }),
              (this.scene = new e.Scene());
            var o = a.preset === S.ASSET_GENERATOR ? 144 / Math.PI : 60;
            (this.defaultCamera = new e.PerspectiveCamera(
              o,
              i.clientWidth / i.clientHeight,
              0.01,
              1e3
            )),
              (this.activeCamera = this.defaultCamera),
              this.scene.add(this.defaultCamera),
              (this.renderer = window.renderer =
                new e.WebGLRenderer({ antialias: !0 })),
              (this.renderer.physicallyCorrectLights = !0),
              (this.renderer.outputEncoding = e.sRGBEncoding),
              this.renderer.setClearColor(13421772),
              this.renderer.setPixelRatio(window.devicePixelRatio),
              this.renderer.setSize(i.clientWidth, i.clientHeight),
              (this.pmremGenerator = new e.PMREMGenerator(this.renderer)),
              this.pmremGenerator.compileEquirectangularShader(),
              (this.controls = new s.OrbitControls(
                this.defaultCamera,
                this.renderer.domElement
              )),
              (this.controls.autoRotate = !1),
              (this.controls.autoRotateSpeed = -10),
              (this.controls.screenSpacePanning = !0),
              (this.vignette = (0, c.createBackground)({
                aspect: this.defaultCamera.aspect,
                grainScale: k ? 0 : 0.001,
                colors: [this.state.bgColor1, this.state.bgColor2],
              })),
              (this.vignette.name = "Vignette"),
              (this.vignette.renderOrder = -1),
              this.el.appendChild(this.renderer.domElement),
              (this.cameraCtrl = null),
              (this.cameraFolder = null),
              (this.animFolder = null),
              (this.animCtrls = []),
              (this.morphFolder = null),
              (this.morphCtrls = []),
              (this.skeletonHelpers = []),
              (this.gridHelper = null),
              (this.axesHelper = null),
              (this.center = null),
              (this.model = void 0);
            var l = (this.selectionMaterialBase = new e.MeshPhongMaterial({
              specular: 526344,
              opacity: 1,
              transparent: !1,
            }));
            (l.packedNormals = !0),
              (l.depthWrite = !0),
              (l.depthTest = !0),
              (l._polygonOffsetOn = !0),
              (l._polygonOffsetFactor = 1),
              (l._polygonOffsetUnits = 0.075),
              (l.side = e.DoubleSide);
            var h = (this.selectionMaterialTop = new e.MeshPhongMaterial({
              specular: 526344,
              opacity: 0.15,
              transparent: !0,
            }));
            (h.packedNormals = !0),
              (h.depthWrite = !1),
              (h.depthTest = !1),
              (h.side = e.DoubleSide),
              this.addAxesHelper(),
              this.addGUI(),
              a.kiosk && this.gui.close(),
              (this.animate = this.animate.bind(this)),
              requestAnimationFrame(this.animate),
              window.addEventListener("resize", this.resize.bind(this), !1);
          }
          return (
            C(n, [
              {
                key: "animate",
                value: function (e) {
                  requestAnimationFrame(this.animate);
                  var t = (e - this.prevTime) / 1e3;
                  this.controls.update(),
                    this.stats.update(),
                    this.mixer && this.mixer.update(t),
                    this.render(),
                    (this.prevTime = e);
                },
              },
              {
                key: "render",
                value: function () {
                  this.renderer.render(this.scene, this.activeCamera),
                    this.state.grid &&
                    (this.axesCamera.position.copy(
                      this.defaultCamera.position
                    ),
                      this.axesCamera.lookAt(this.axesScene.position),
                      this.axesRenderer.render(
                        this.axesScene,
                        this.axesCamera
                      ));
                },
              },
              {
                key: "resize",
                value: function () {
                  var e = this.el.parentElement,
                    t = e.clientHeight,
                    i = e.clientWidth;
                  (this.defaultCamera.aspect = i / t),
                    this.defaultCamera.updateProjectionMatrix(),
                    this.vignette.style({ aspect: this.defaultCamera.aspect }),
                    this.renderer.setSize(i, t),
                    (this.axesCamera.aspect =
                      this.axesDiv.clientWidth / this.axesDiv.clientHeight),
                    this.axesCamera.updateProjectionMatrix(),
                    this.axesRenderer.setSize(
                      this.axesDiv.clientWidth,
                      this.axesDiv.clientHeight
                    );
                },
              },
              {
                key: "loadInfo",
                value: function (e) {
                  var t = this;
                  return u.ModelTree.loadFrom(e).then(function (e) {
                    return (t.model = e);
                  });
                },
              },
              {
                key: "load",
                value: function (t) {
                  var n = this,
                    a = e.LoaderUtils.extractUrlBase(t);
                  return new Promise(function (e, s) {
                    w.setURLModifier(function (e, t) {
                      return (t || "") + e;
                    });
                    var o = new i.GLTFLoader(w)
                      .setCrossOrigin("anonymous")
                      .setDRACOLoader(E)
                      .setKTX2Loader(b.detectSupport(n.renderer))
                      .setMeshoptDecoder(r.MeshoptDecoder),
                      l = [];
                    o.load(
                      t,
                      function (t) {
                        var i = t.scene || t.scenes[0],
                          r = t.animations || [];
                        if (!i)
                          throw new Error(
                            "This model contains no scene, and cannot be viewed here. However, it may contain individual 3D resources."
                          );
                        n.setContent(i, r, a),
                          l.forEach(URL.revokeObjectURL),
                          e(t);
                      },
                      void 0,
                      s
                    );
                  });
                },
              },
              {
                key: "hitTest",
                value: function (t, i) {
                  if (null !== this.content && void 0 !== this.content) {
                    var n = this.defaultCamera,
                      a = new e.Vector3(t, i, 0.5).unproject(n);
                    return new e.Raycaster(
                      n.position,
                      a.sub(n.position).normalize()
                    ).intersectObject(this.content, !0);
                  }
                },
              },
              {
                key: "setContent",
                value: function (t, i, n) {
                  var a,
                    r = this,
                    s = t.userData && !0 === t.userData.PartFileEnabled,
                    o = s ? t.userData.PartFileIndex : 0;
                  this.model &&
                    (null === (a = this.model) ||
                      void 0 === a ||
                      a.bindGltfScene(t, o));
                  if (s)
                    if (0 === o) {
                      var l = t.userData.PartFileNames;
                      if (l)
                        for (var h = 1; h < l.length; h++) {
                          var d = n + l[h];
                          this.load(d, "", new Map());
                        }
                    } else {
                      if (null !== this.center)
                        return (
                          (t.position.x += t.position.x - this.center.x),
                          (t.position.y += t.position.y - this.center.y),
                          (t.position.z += t.position.z - this.center.z),
                          void this.content.add(t)
                        );
                      s = !1;
                    }
                  if (
                    this.enableElementData &&
                    t.userData &&
                    t.userData.InfoFileName &&
                    null == this.model
                  ) {
                    (this.model = new u.ModelTree()),
                      this.model.bindGltfScene(t, o);
                    var c = n + t.userData.InfoFileName;
                    fetch(c)
                      .then(function (e) {
                        return e.json();
                      })
                      .then(function (e) {
                        return r.model.init(e);
                      });
                  }
                  this.clear();
                  var m =
                    s && t.userData && t.userData.ModelBoundingBox
                      ? new e.Box3().setFromArray(t.userData.ModelBoundingBox)
                      : new e.Box3().setFromObject(t),
                    p = m.getSize(new e.Vector3()).length(),
                    f = (this.center = m.getCenter(new e.Vector3()));
                  this.controls.reset(),
                    (t.position.x += t.position.x - f.x),
                    (t.position.y += t.position.y - f.y),
                    (t.position.z += t.position.z - f.z),
                    (this.controls.maxDistance = 10 * p),
                    (this.defaultCamera.near = p / 100),
                    (this.defaultCamera.far = 100 * p),
                    this.defaultCamera.updateProjectionMatrix(),
                    this.options.cameraPosition
                      ? (this.defaultCamera.position.fromArray(
                        this.options.cameraPosition
                      ),
                        this.defaultCamera.lookAt(new e.Vector3()))
                      : (this.defaultCamera.position.copy(f),
                        (this.defaultCamera.position.x += p / 2),
                        (this.defaultCamera.position.y += p / 5),
                        (this.defaultCamera.position.z += p / 2),
                        this.defaultCamera.lookAt(f)),
                    this.setCamera(y),
                    this.axesCamera.position.copy(this.defaultCamera.position),
                    this.axesCamera.lookAt(this.axesScene.position),
                    (this.axesCamera.near = p / 100),
                    (this.axesCamera.far = 100 * p),
                    this.axesCamera.updateProjectionMatrix(),
                    this.axesCorner.scale.set(p, p, p),
                    this.controls.saveState(),
                    s
                      ? ((this.content = new e.Object3D()),
                        this.content.add(t),
                        this.scene.add(this.content))
                      : (this.scene.add(t), (this.content = t)),
                    (this.state.addLights = !0),
                    this.content.traverse(function (e) {
                      e.isLight
                        ? (r.state.addLights = !1)
                        : e.isMesh &&
                        (e.material.depthWrite = !e.material.transparent);
                    }),
                    this.setClips(i),
                    this.updateLights(),
                    this.updateGUI(),
                    this.updateEnvironment(),
                    this.updateTextureEncoding(),
                    this.updateDisplay(),
                    (window.content = this.content);
                },
              },
              {
                key: "printGraph",
                value: function (e) {
                  var t = this;
                  console.group(" <" + e.type + "> " + e.name),
                    e.children.forEach(function (e) {
                      return t.printGraph(e);
                    }),
                    console.groupEnd();
                },
              },
              {
                key: "setClips",
                value: function (t) {
                  this.mixer &&
                    (this.mixer.stopAllAction(),
                      this.mixer.uncacheRoot(this.mixer.getRoot()),
                      (this.mixer = null)),
                    (this.clips = t),
                    t.length &&
                    (this.mixer = new e.AnimationMixer(this.content));
                },
              },
              {
                key: "playAllClips",
                value: function () {
                  var e = this;
                  this.clips.forEach(function (t) {
                    e.mixer.clipAction(t).reset().play(),
                      (e.state.actionStates[t.name] = !0);
                  });
                },
              },
              {
                key: "setCamera",
                value: function (e) {
                  var t = this;
                  e === y
                    ? ((this.controls.enabled = !0),
                      (this.activeCamera = this.defaultCamera))
                    : ((this.controls.enabled = !1),
                      this.content.traverse(function (i) {
                        i.isCamera && i.name === e && (t.activeCamera = i);
                      }));
                },
              },
              {
                key: "updateTextureEncoding",
                value: function () {
                  var t =
                    "sRGB" === this.state.textureEncoding
                      ? e.sRGBEncoding
                      : e.LinearEncoding;
                  T(this.content, function (e) {
                    e.map && (e.map.encoding = t),
                      e.emissiveMap && (e.emissiveMap.encoding = t),
                      (e.map || e.emissiveMap) && (e.needsUpdate = !0);
                  });
                },
              },
              {
                key: "updateLights",
                value: function () {
                  var e = this.state,
                    t = this.lights;
                  e.addLights && !t.length
                    ? this.addLights()
                    : !e.addLights && t.length && this.removeLights(),
                    (this.renderer.toneMappingExposure = e.exposure),
                    2 === t.length &&
                    ((t[0].intensity = e.ambientIntensity),
                      t[0].color.setHex(e.ambientColor),
                      (t[1].intensity = e.directIntensity),
                      t[1].color.setHex(e.directColor));
                },
              },
              {
                key: "addLights",
                value: function () {
                  var t = this.state;
                  if (this.options.preset === S.ASSET_GENERATOR) {
                    var i = new e.HemisphereLight();
                    return (
                      (i.name = "hemi_light"),
                      this.scene.add(i),
                      void this.lights.push(i)
                    );
                  }
                  var n = new e.AmbientLight(
                    t.ambientColor,
                    t.ambientIntensity
                  );
                  (n.name = "ambient_light"), this.defaultCamera.add(n);
                  var a = new e.DirectionalLight(
                    t.directColor,
                    t.directIntensity
                  );
                  a.position.set(0.5, 0, 0.866),
                    (a.name = "main_light"),
                    this.defaultCamera.add(a),
                    this.lights.push(n, a);
                },
              },
              {
                key: "removeLights",
                value: function () {
                  this.lights.forEach(function (e) {
                    return e.parent.remove(e);
                  }),
                    (this.lights.length = 0);
                },
              },
              {
                key: "updateEnvironment",
                value: function () {
                  var e = this,
                    t = d.environments.filter(function (t) {
                      return t.name === e.state.environment;
                    })[0];
                  this.getCubeMapTexture(t).then(function (t) {
                    var i = t.envMap;
                    (i && e.state.background) ||
                      e.activeCamera !== e.defaultCamera
                      ? e.scene.remove(e.vignette)
                      : e.scene.add(e.vignette),
                      (e.scene.environment = i),
                      (e.scene.background = e.state.background ? i : null);
                  });
                },
              },
              {
                key: "getCubeMapTexture",
                value: function (t) {
                  var i = this,
                    n = t.path;
                  return n
                    ? ((n = x + n),
                      new Promise(function (t, a) {
                        new o.RGBELoader().setDataType(e.UnsignedByteType).load(
                          n,
                          function (e) {
                            var n =
                              i.pmremGenerator.fromEquirectangular(e).texture;
                            i.pmremGenerator.dispose(), t({ envMap: n });
                          },
                          void 0,
                          a
                        );
                      }))
                    : Promise.resolve({ envMap: null });
                },
              },
              {
                key: "updateDisplay",
                value: function () {
                  var t = this;
                  this.skeletonHelpers.length &&
                    this.skeletonHelpers.forEach(function (e) {
                      return t.scene.remove(e);
                    }),
                    T(this.content, function (e) {
                      e.wireframe = t.state.wireframe;
                    }),
                    this.content.traverse(function (i) {
                      if (i.isMesh && i.skeleton && t.state.skeleton) {
                        var n = new e.SkeletonHelper(
                          i.skeleton.bones[0].parent
                        );
                        (n.material.linewidth = 3),
                          t.scene.add(n),
                          t.skeletonHelpers.push(n);
                      }
                    }),
                    this.state.grid !== Boolean(this.gridHelper) &&
                    (this.state.grid
                      ? ((this.gridHelper = new e.GridHelper()),
                        (this.axesHelper = new e.AxesHelper()),
                        (this.axesHelper.renderOrder = 999),
                        (this.axesHelper.onBeforeRender = function (e) {
                          return e.clearDepth();
                        }),
                        this.scene.add(this.gridHelper),
                        this.scene.add(this.axesHelper))
                      : (this.scene.remove(this.gridHelper),
                        this.scene.remove(this.axesHelper),
                        (this.gridHelper = null),
                        (this.axesHelper = null),
                        this.axesRenderer.clear()));
                },
              },
              {
                key: "updateBackground",
                value: function () {
                  this.vignette.style({
                    colors: [this.state.bgColor1, this.state.bgColor2],
                  });
                },
              },
              {
                key: "addAxesHelper",
                value: function () {
                  (this.axesDiv = document.createElement("div")),
                    this.el.appendChild(this.axesDiv),
                    this.axesDiv.classList.add("axes");
                  var t = this.axesDiv,
                    i = t.clientWidth,
                    n = t.clientHeight;
                  (this.axesScene = new e.Scene()),
                    (this.axesCamera = new e.PerspectiveCamera(
                      50,
                      i / n,
                      0.1,
                      10
                    )),
                    this.axesScene.add(this.axesCamera),
                    (this.axesRenderer = new e.WebGLRenderer({ alpha: !0 })),
                    this.axesRenderer.setPixelRatio(window.devicePixelRatio),
                    this.axesRenderer.setSize(
                      this.axesDiv.clientWidth,
                      this.axesDiv.clientHeight
                    ),
                    (this.axesCamera.up = this.defaultCamera.up),
                    (this.axesCorner = new e.AxesHelper(5)),
                    this.axesScene.add(this.axesCorner),
                    this.axesDiv.appendChild(this.axesRenderer.domElement);
                },
              },
              {
                key: "addGUI",
                value: function () {
                  var t = this,
                    i = (this.gui = new h.GUI({
                      autoPlace: !1,
                      width: 260,
                      hideable: !0,
                    })),
                    n = i.addFolder("Display");
                  n.add(this.state, "background").onChange(function () {
                    return t.updateEnvironment();
                  }),
                    n.add(this.state, "wireframe").onChange(function () {
                      return t.updateDisplay();
                    }),
                    n.add(this.state, "skeleton").onChange(function () {
                      return t.updateDisplay();
                    }),
                    n.add(this.state, "grid").onChange(function () {
                      return t.updateDisplay();
                    }),
                    n.add(this.controls, "autoRotate"),
                    n.add(this.controls, "screenSpacePanning");
                  var a = n.addColor(this.state, "bgColor1"),
                    r = n.addColor(this.state, "bgColor2");
                  a.onChange(function () {
                    return t.updateBackground();
                  }),
                    r.onChange(function () {
                      return t.updateBackground();
                    });
                  var s = i.addFolder("Lighting");
                  s
                    .add(this.state, "textureEncoding", ["sRGB", "Linear"])
                    .onChange(function () {
                      return t.updateTextureEncoding();
                    }),
                    s
                      .add(this.renderer, "outputEncoding", {
                        sRGB: e.sRGBEncoding,
                        Linear: e.LinearEncoding,
                      })
                      .onChange(function () {
                        (t.renderer.outputEncoding = Number(
                          t.renderer.outputEncoding
                        )),
                          T(t.content, function (e) {
                            e.needsUpdate = !0;
                          });
                      }),
                    s
                      .add(
                        this.state,
                        "environment",
                        d.environments.map(function (e) {
                          return e.name;
                        })
                      )
                      .onChange(function () {
                        return t.updateEnvironment();
                      }),
                    [
                      s.add(this.state, "exposure", 0, 2),
                      s.add(this.state, "addLights").listen(),
                      s.add(this.state, "ambientIntensity", 0, 2),
                      s.addColor(this.state, "ambientColor"),
                      s.add(this.state, "directIntensity", 0, 4),
                      s.addColor(this.state, "directColor"),
                    ].forEach(function (e) {
                      return e.onChange(function () {
                        return t.updateLights();
                      });
                    }),
                    (this.animFolder = i.addFolder("Animation")),
                    (this.animFolder.domElement.style.display = "none"),
                    this.animFolder
                      .add(this.state, "playbackSpeed", 0, 1)
                      .onChange(function (e) {
                        t.mixer && (t.mixer.timeScale = e);
                      }),
                    this.animFolder.add(
                      {
                        playAll: function () {
                          return t.playAllClips();
                        },
                      },
                      "playAll"
                    ),
                    (this.morphFolder = i.addFolder("Morph Targets")),
                    (this.morphFolder.domElement.style.display = "none"),
                    (this.cameraFolder = i.addFolder("Cameras")),
                    (this.cameraFolder.domElement.style.display = "none");
                  var o = i.addFolder("Performance"),
                    l = document.createElement("li");
                  (this.stats.dom.style.position = "static"),
                    l.appendChild(this.stats.dom),
                    l.classList.add("gui-stats"),
                    o.__ul.appendChild(l);
                  var c = document.createElement("div");
                  this.el.appendChild(c),
                    c.classList.add("gui-wrap"),
                    c.appendChild(i.domElement),
                    i.open();
                },
              },
              {
                key: "updateGUI",
                value: function () {
                  var e = this;
                  (this.cameraFolder.domElement.style.display = "none"),
                    this.morphCtrls.forEach(function (e) {
                      return e.remove();
                    }),
                    (this.morphCtrls.length = 0),
                    (this.morphFolder.domElement.style.display = "none"),
                    this.animCtrls.forEach(function (e) {
                      return e.remove();
                    }),
                    (this.animCtrls.length = 0),
                    (this.animFolder.domElement.style.display = "none");
                  var t = [],
                    i = [];
                  if (
                    (this.content.traverse(function (e) {
                      e.isMesh && e.morphTargetInfluences && i.push(e),
                        e.isCamera &&
                        ((e.name =
                          e.name || "VIEWER__camera_".concat(t.length + 1)),
                          t.push(e.name));
                    }),
                      t.length)
                  ) {
                    (this.cameraFolder.domElement.style.display = ""),
                      this.cameraCtrl && this.cameraCtrl.remove();
                    var n = [y].concat(t);
                    (this.cameraCtrl = this.cameraFolder.add(
                      this.state,
                      "camera",
                      n
                    )),
                      this.cameraCtrl.onChange(function (t) {
                        return e.setCamera(t);
                      });
                  }
                  if (
                    (i.length &&
                      ((this.morphFolder.domElement.style.display = ""),
                        i.forEach(function (t) {
                          if (t.morphTargetInfluences.length) {
                            var i = e.morphFolder.add(
                              { name: t.name || "Untitled" },
                              "name"
                            );
                            e.morphCtrls.push(i);
                          }
                          for (
                            var n = function (i) {
                              var n = e.morphFolder
                                .add(t.morphTargetInfluences, i, 0, 1, 0.01)
                                .listen();
                              Object.keys(t.morphTargetDictionary).forEach(
                                function (e) {
                                  e &&
                                    t.morphTargetDictionary[e] === i &&
                                    n.name(e);
                                }
                              ),
                                e.morphCtrls.push(n);
                            },
                            a = 0;
                            a < t.morphTargetInfluences.length;
                            a++
                          )
                            n(a);
                        })),
                      this.clips.length)
                  ) {
                    this.animFolder.domElement.style.display = "";
                    var a = (this.state.actionStates = {});
                    this.clips.forEach(function (t, i) {
                      var n;
                      (t.name = "".concat(i + 1, ". ").concat(t.name)),
                        0 === i
                          ? ((a[t.name] = !0),
                            (n = e.mixer.clipAction(t)).play())
                          : (a[t.name] = !1);
                      var r = e.animFolder.add(a, t.name).listen();
                      r.onChange(function (i) {
                        (n = n || e.mixer.clipAction(t)).setEffectiveTimeScale(
                          1
                        ),
                          i ? n.play() : n.stop();
                      }),
                        e.animCtrls.push(r);
                    });
                  }
                },
              },
              {
                key: "clear",
                value: function () {
                  this.content &&
                    (this.scene.remove(this.content),
                      this.content.traverse(function (e) {
                        e.isMesh && e.geometry.dispose();
                      }),
                      T(this.content, function (e) {
                        M.forEach(function (t) {
                          e[t] && e[t].dispose();
                        });
                      }));
                },
              },
            ]),
            n
          );
        })();
        function T(e, t) {
          e.traverse(function (e) {
            e.isMesh &&
              (Array.isArray(e.material) ? e.material : [e.material]).forEach(
                t
              );
          });
        }
        function P() {
          return (
            [
              "iPad Simulator",
              "iPhone Simulator",
              "iPod Simulator",
              "iPad",
              "iPhone",
              "iPod",
            ].includes(navigator.platform) ||
            (navigator.userAgent.includes("Mac") && "ontouchend" in document)
          );
        }
        (exports.Viewer = R),
          (window.Viewer = R),
          (window.ViewerSceneTree = u.ModelTree),
          (window.THREE = e),
          (window.queryString = l.default);
      },
      {
        three: "gBK8",
        "three/examples/jsm/libs/stats.module.js": "CCS2",
        "three/examples/jsm/loaders/GLTFLoader.js": "S3Gv",
        "three/examples/jsm/loaders/KTX2Loader.js": "phQK",
        "three/examples/jsm/loaders/DRACOLoader.js": "FYxH",
        "three/examples/jsm/libs/meshopt_decoder.module.js": "FK1n",
        "three/examples/jsm/controls/OrbitControls.js": "x87H",
        "three/examples/jsm/loaders/RGBELoader.js": "WoxW",
        "query-string": "TuMS",
        "dat.gui": "ArXC",
        "../assets/environment/index.js": "Xcza",
        "../lib/three-vignette.js": "aQrt",
        "./BimAngle/Gltf/ThreeJS/ModelTree.js": "kXkO",
      },
    ],
  },
  {},
  ["ET0b"],
  null
);
